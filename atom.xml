<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bean的博客</title>
  
  <subtitle>命之沧桑，唯有破风前行！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wangbin26.com/"/>
  <updated>2018-05-08T05:46:18.067Z</updated>
  <id>http://www.wangbin26.com/</id>
  
  <author>
    <name>Bean</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>约翰内斯堡（一）</title>
    <link href="http://www.wangbin26.com/2018/05/08/%E7%BA%A6%E7%BF%B0%E5%86%85%E6%96%AF%E5%A0%A1(%E4%B8%80)/"/>
    <id>http://www.wangbin26.com/2018/05/08/约翰内斯堡(一)/</id>
    <published>2018-05-08T05:00:38.000Z</published>
    <updated>2018-05-08T05:46:18.067Z</updated>
    
    <content type="html"><![CDATA[<p>当地时间2018年5月8号，我来到了南非最大的城市–约翰内斯堡，开始了为期一个月的生活。<br>在这之前我对约堡的印象是“乱、抢劫、犯罪之都”，同时这里也是</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当地时间2018年5月8号，我来到了南非最大的城市–约翰内斯堡，开始了为期一个月的生活。&lt;br&gt;在这之前我对约堡的印象是“乱、抢劫、犯罪之都”，同时这里也是&lt;/p&gt;

      
    
    </summary>
    
      <category term="游记" scheme="http://www.wangbin26.com/categories/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="文学" scheme="http://www.wangbin26.com/categories/%E6%B8%B8%E8%AE%B0/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="约翰内斯堡" scheme="http://www.wangbin26.com/tags/%E7%BA%A6%E7%BF%B0%E5%86%85%E6%96%AF%E5%A0%A1/"/>
    
      <category term="印象南非" scheme="http://www.wangbin26.com/tags/%E5%8D%B0%E8%B1%A1%E5%8D%97%E9%9D%9E/"/>
    
  </entry>
  
  <entry>
    <title>你的生命里住着怎样的另一个自己</title>
    <link href="http://www.wangbin26.com/2017/04/24/%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E9%87%8C%E4%BD%8F%E7%9D%80%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1/"/>
    <id>http://www.wangbin26.com/2017/04/24/你的生命里住着怎样的另一个自己/</id>
    <published>2017-04-24T08:47:31.000Z</published>
    <updated>2018-04-27T08:24:21.513Z</updated>
    
    <content type="html"><![CDATA[<p> 想起早年读过的半则神话故事。</p><p>  远古时候有一渔者，终日在无妄之海捕鱼而生，有一日，迷失于一片海域，漂了一万两千年终于走出来，海水边搁浅着一叶扁舟，无人，无风，无鸟雀。他走近小船，看到一本上古秘籍，一页一页翻去，边颔首边赞叹，翻至最后一页，发现竟画着自己，与自己背靠背坐着一位书生，旁边还有两行字，一行：行文有际，……。后面的字被海书浸湿，看不清。又一行：猎海无涯，……。后面的字被一团黑墨盖住。叉弃书生衣摆之侧，笔置渔人篷发之间。</p><p>感兴趣的故事总是残篇断简。</p><p>神秘的预言若被印证，立刻觉得冥冥之中，有一只大手搅弄着风云，大气象之下的芸芸众生，越觉得微乎其微，虽杳渺，仍对细节着迷，就如有一个时刻，会莫名努力关注着一个闯进浮生半日的生命，而忽略了周遭的喧喧嚷嚷，任由故事里的人入了现实，而自己隐进故事。<br>这一隐一现之间，命运就生出枝杈，生命就此丰盈起来。</p><p>1<br>渔人猎到何种鱼都不足为奇。<br>他擎叉的表情，他趟开草丛时四溅的水珠，他肩头划落的流星是以怎样的轨迹陨落，这些附着在故事本体的细微，才是一个可以讲出精彩故事的人的谈资。</p><p>而让渔人双眼放光的，终究是那些闯入眼帘的猎物。他布下重重陷井后，渴望着第二日，能够看到扑腾着的，那些误入岐途的鱼啊、贝啊的。</p><p>这天，他挽了叉，摸着黑出海。<br>这天，他收了网，摸着黑回到家中。<br>他从怀里取出从后海山涯上捡拾到的一方岩石，岩石上刻着一幅图，一男子单腿脆在渔船上，双手似掷叉，却不见叉，渔人寻思半晌，顺着那男子目光的方向画了一支渔叉。<br>这样才踏实，他说。</p><p>夜晚入梦，他怀抱一轮月在浓雾里四野奔走，耳边隐隐有细碎的咳嗽，静立细听时，悄无声息，夺步而走时，又戚戚地回响于耳畔，他看不清自己的表情，却能看到完整的自己被白日的那片岩石群裹挟着，他内心有方向，而双脚无感，脚底接壤着的这片土地，让他瞬间立成一株静物。</p><p>走吧，走吧。他对自己说。<br>身子重得仍旧迈不开腿，正犹疑时，听到猎犬狂吠，继而又听院子里“咣当”一声，不知何物从高处坠落，先砸在磨盘上然后滚落到地上，骨碌碌地，滚了一段距离。</p><p>他没起身，只是定睛看着窗外那一轮晧月，然后想起自己怀中的那一轮，他双臂环抱了一下，仿佛月光被尽数拢入，脸上现出宁静的光芒。<br>第二天一早，渔人粗粗洗了脸，吃了饭，便直奔后海那个有画的岩石群，他想知道，那支鱼叉投向了哪个方向，叉中了什么。</p><p>2<br>我发现，每人在讲述同一件事时，多少都会掺杂自己的一些意思，根本无法还原故事本身。即便司马迁有着怀揣一颗努力还原史实本真的初愿去写《史记》的心，在遣词造句上，还是会不动声色地糅进自己的偏好。寥寥数语的，或为不熟知或觉得微不足道；浓墨重彩的，或因事件撞击了历史的支柱，本身就足够分量，愿不愿意都得费些笔墨，这两者中间的事件，就去看一些形容词的使用，那里藏着他个人的意思。</p><p>因为觉得自己粗浅，给自己取昵称时，虽然向往，却仍不太敢用那些美好来粉饰，倘若骨子里与之不匹，一来倒了众人胃口，二来再牵连着人们对这词语生出俗意，才真正难堪。细想，昵称没取过几个，但拈了来就一直未改，虽俗了些，我却愿意用日复一日积攒起来的浅浅的、羞涩的美好，从内向外开出一朵花来，纵然这花一半盛开着自卑。</p><p>名字会被一些人遇见，遇见的人会先从名字里窥一些蛛丝蚂迹。这样一想，觉得气馁，转念又想，一个人倘若真的把一个俗名让人们唤得风生水起，亦或超凡脱俗，这才是大境界，比如《红楼梦》里的宝玉。<br>多数人的名字是代号，但一定有例外。<br>有人因为人而记住名字，有人因名字而记住人。</p><p>3<br>渔人徒步于岩画幽壑。页岩上每条线的刻画，都让他想到那个手拿凿斧的人，用力气与技巧勾勒出的另种意义。</p><p>这是神谕吧，他秉承着流传与启示的职责，想渡一种修为于不朽。渔人想。画面上大多的飞禽走兽识得，即或斧凿之人用了写意或象形，他也能猜出，他不关心这些，他想知道，那个单腿脆在渔船的渔人的叉被定格在何处。</p><p>有的寻找是一种无意识的驱动，计划再周详，也会有变数。<br>这一日，他的叉松下来，斑鸠咕咕响于林隙，野鹿饮水，鸥鸟翔于海天，他的眼神只穿梭于众多线条中。<br>……<br>故事说到这儿，再讲述不下去。<br>因为，听到一个声音说，将事件推至洪荒，便可无稽，这是人们惯用的伎俩，有人用来隐藏秘密，有人用来使事件合理。又想，这未免有失偏颇，生命本身就具偶然性，生命本来就是一场有去无回的无稽之谈。<br>所以，还是继续吧。</p><p>渔人有过设想，鱼叉或者射向一种奔跑，或者逆风正穿过船畔，只是那画中人让他觉得，他忽尔是他，又忽尔不是。他拎着那把叉一寻就是十四万年，林子绿了又黄，河水解冻又冰封，他日日来此，发蓬髭虬，再后来，他自己都不知为什么来这里。</p><p>他的眼神有深夜的气象，日头再如何猖獗，他所望之处，那些被焦烤着的混沌，清的上升，浊的下沉。他的胸腔有和熙的味道，再冰冷的长夜遇到他，会自动退守，会瓦解，会让野花开了合，合了开，只是他自己不知。<br>于是，他学着凿斧手，在一片页岩上刻下一个符号，形似一支叉。<br>那就是我。他想。以后，他每日都会来这里，与这个符号对视。</p><p>4<br>前几天，读到一篇《葵花》的文，文中有段话说“世上再也找不到（比葵花）更大的傻子了。”“世界上居然有那么傻的花朵，开的那么大，那么笨，拼命三郎似的，整天追逐着日头找晒，无疑是疯了，是自找毁灭”。</p><p>读完后，我一直在乐。然后想起葵花的花语：沉默的爱，没有说出口的爱。想来，这位定义葵花花语的人，一定也是个傻子。</p><p>每朵花都美好，每个美好里都有不为人知的成长历程，比如烂漫夸张的向日葵，它的花语里分明住着一株含羞草，它有颗敏感的心，有人只看到葵藿倾阳，我却觉得，它是在诠释，什么叫命定的遇见。</p><p>不必期待人人懂。懂的自然懂，不懂的说了也不懂。</p><p>5<br>与那个符号对视得久了，渔人想要跳出一种局囿。<br>无妄海越深邃，猎物越丰沛，也愈发让他觉得孤独，这状态夜以继日地席卷着他，看花开，看花谢，有时他觉得自己是一棵树上的叶子，风过之处，无舵无浆般随波逐流，有时又觉得自己是枚果实，丰盈的果肉包裹着一颗内核，期待绽裂。</p><p>又过数年，渔人提着叉又去与那个符号对坐，因经年循着固定的路线行走，逶逶迤迤的，在荒草夹岸的荒滩里，辟出一条小径，其中利石变得圆滚，野草顺势伏地，齐腰的青蒿散发出清凉的味道，蚊虫远之，邪气避之，绿油油的样子，让人觉得吹过的风都是凉爽的。</p><p>这天，当走那个符号前时，他下意识地一惊。<br>他发现他的符号上隐隐被补缀了另一个图案，近看，他发现是支毛笔，毫管与叉尖相齐，毫端与叉尾相对。</p><p>6<br>有些词于我很惊艳。<br>被惊艳后，会念念不忘。会在心里生出根，生出枝杈，会在某个合适的情境中将它安放。是什么力量在暗中让人一遍遍索引一种未知，比如说，深夜时候潜入的梦，白天的时候一晃而过的无意识的念头，又比如，那惊艳到我的字符触动了哪根弦，一个短瞬，迸发出高于感观与触觉的异常兴奋。</p><p>科学家的血液里藏有异冷的因子。他们平静地排列组合一堆数字时，理性的让人悲观，在他们得到的结论不符合我的想法时，我宁愿相信前世，或者玄学，那里住着另一个我，和那另一个我的过往世界，我如何舍得割舍与她的因果缘缘。</p><p>“生命的实质似乎是绝望与惊骇”，这话又真实的让人生怯，无所谓对与错吧，谁又知道谁经历了什么，又有几个人能够跳出一种局限，放眼于一种阔大，我们都是蝼蚁吧，按部就班地生活，所有的经历与眼界放进宇宙中，会另人发笑从而闭嘴。</p><p>我想，如果，另个我真的存在于三界之内，我想知道，她可常常像我一般，想念而向往，心照不宣又如影随形。</p><p>7<br>然后，渔人突然有了写字的冲动，或者说，有了倾诉的愿望。<br>于是树木与岩壁随处可见他的文，有的三五言，有的成阙成赋。</p><p>又过百十万年，有一天在渡口遇一中榜书生返乡，两个一见如故，一番寒暄后，竟是同乡又是同枝。</p><p>于是邀至家，秉烛夜话，酒到酣处，书生舞叉，渔人弄墨，书生褪去长衫，渔人瞥见他的肩头有一胎记，形似一支渔叉。</p><p>8<br>故事到此就结束了。<br>敲完这些文字，当晚有梦，梦见似是而非的自己亲临了一个梦境，梦境里有大片的月光，大片的海水，大片的沙滩。<br>还梦到，我在沙滩上睡成贝壳的姿势，他在长一声短一声唤我的名字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 想起早年读过的半则神话故事。&lt;/p&gt;
&lt;p&gt;  远古时候有一渔者，终日在无妄之海捕鱼而生，有一日，迷失于一片海域，漂了一万两千年终于走出来，海水边搁浅着一叶扁舟，无人，无风，无鸟雀。他走近小船，看到一本上古秘籍，一页一页翻去，边颔首边赞叹，翻至最后一页，发现竟画着自己，与
      
    
    </summary>
    
      <category term="文学" scheme="http://www.wangbin26.com/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="生活" scheme="http://www.wangbin26.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="散文" scheme="http://www.wangbin26.com/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>js基础理论知识</title>
    <link href="http://www.wangbin26.com/2016/08/16/js%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.wangbin26.com/2016/08/16/js基础理论知识/</id>
    <published>2016-08-16T19:05:26.000Z</published>
    <updated>2018-04-26T14:41:39.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局变量-局部变量-变量声明-变量赋值"><a href="#全局变量-局部变量-变量声明-变量赋值" class="headerlink" title="全局变量 局部变量 变量声明 变量赋值"></a>全局变量 局部变量 变量声明 变量赋值</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//全局变量</span><br><span class="line">var sum;   //变量声明</span><br><span class="line">sum = 10； //变量赋值</span><br><span class="line">function fn() &#123;</span><br><span class="line">    //局部变量</span><br><span class="line">    var sum = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    console.log(sum) // undefined</span><br></pre></td></tr></table></figure><h2 id="变量和函数声明提升定义"><a href="#变量和函数声明提升定义" class="headerlink" title="变量和函数声明提升定义"></a>变量和函数声明提升定义</h2><ul><li><p>当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//变量声明提升</span><br><span class="line">function test()&#123;</span><br><span class="line">    var a = &quot;1&quot;;</span><br><span class="line">    var f = function() &#123;&#125;;</span><br><span class="line">    var b = &quot;2&quot;;</span><br><span class="line">    var c = &quot;3&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">、、上述代码等价于 </span><br><span class="line">function test() &#123;</span><br><span class="line">    var a,f,b,c;</span><br><span class="line">    a = &quot;1&quot;;</span><br><span class="line">    f = function()&#123;&#125;;</span><br><span class="line">    b = &quot;2&quot;;</span><br><span class="line">    c = &quot;3&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量作用域和执行环境"><a href="#变量作用域和执行环境" class="headerlink" title="变量作用域和执行环境"></a>变量作用域和执行环境</h2><h3 id="如何寻找全局变量"><a href="#如何寻找全局变量" class="headerlink" title="如何寻找全局变量"></a>如何寻找全局变量</h3><ol><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li><li>未定义直接赋值的变量自动声明为拥有全局作用域  – 比如 all1 all2</li><li>所有window对象的属性拥有全局作用域，我们也可以通过如下方式定义一个全局变量：window.name=11<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// a: 由于变量声明提升，这里a变量时存在的，但是是undefined</span><br><span class="line">var sum = 0;</span><br><span class="line">var a = 10</span><br><span class="line">all1 = 1000</span><br><span class="line">function test() &#123;</span><br><span class="line">    //这个时候由于变量声明提升，a变量已经声明，并且值是undefined</span><br><span class="line">    console.log(a);</span><br><span class="line">    all2 = 200;</span><br><span class="line">    //foo是一个函数，解析的时候会提升，所以能够访问到</span><br><span class="line">    console.log(foo());</span><br><span class="line">    //如果省略下面这句  输出结果是什么</span><br><span class="line">    //var a = 1</span><br><span class="line">    function foo()&#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数值型<blockquote><p>int整数： 1,2,3</p></blockquote></li><li>float 浮点型： 1.2</li><li>字符串型<blockquote><p>string: “a” “b”</p></blockquote></li><li>布尔型<blockquote><p>boolean: true,false</p></blockquote></li><li>对象<blockquote><p>object: 默认值:null</p></blockquote></li><li>未定义<blockquote><p>undefined:本身只有一个值，就是它本身 </p></blockquote></li></ul><h3 id="数据类型检查"><a href="#数据类型检查" class="headerlink" title="数据类型检查"></a>数据类型检查</h3><ul><li>数据类型检查方法: typeof()</li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>tostring 可以将其他类型转化成字符串<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2></li><li>算术运算符 +（加）  ——（减）  *（乘） /（除） %(取余数)</li><li>复合赋值运算符 -= += *= /= %=</li><li>自增自减运算符 – ++</li><li>比较运算符 &gt; &lt; &gt;= &lt;= ==(比较的时候做类型转换) ===（全等于：值 数据类型都一样才算相等） !=</li><li>逻辑运算符 &amp;&amp; 与 |或 ！非</li><li>三元运算符 ?<h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3></li><li><p>逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n </p></li><li><p>逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=8*2,x*4 </span><br><span class="line">/*整个表达式的值为64，x的值为16*/ </span><br><span class="line"></span><br><span class="line">(x=8*2,x*4),x*2 </span><br><span class="line">/*整个表达式的值为128，x的值为16*/ </span><br><span class="line">x=(z=5,5*2) </span><br><span class="line">/*整个表达式为赋值表达式，它的值为10，z的值为5*/ </span><br><span class="line"></span><br><span class="line">x=z=5,5*2 </span><br><span class="line">/*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/</span><br></pre></td></tr></table></figure><h2 id="短路表达式"><a href="#短路表达式" class="headerlink" title="短路表达式"></a>短路表达式</h2><ul><li>关联记忆法则：<br>大家只要记住||,然后通过关联性记住&amp;&amp;<br>如何记忆&amp;&amp;：两个字，和||相反<br>| | :  如果左边的true就返回左边 否则返回右边<br>&amp;&amp;: 如果左边返回的true就返回右边 否则返回左边<h3 id="短路表达式基础-amp-用法"><a href="#短路表达式基础-amp-用法" class="headerlink" title="短路表达式基础 - ||&amp; 用法"></a>短路表达式基础 - ||&amp; 用法</h3></li><li>1 是true 0 是false</li><li>字符串除了空字符串外都是true  </li><li>function 和 object都是true  </li><li>null 和 undefined都是false <h3 id="短路表达式可以简化if语句"><a href="#短路表达式可以简化if语句" class="headerlink" title="短路表达式可以简化if语句"></a>短路表达式可以简化if语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前：</span><br><span class="line">if (myobj) &#123;</span><br><span class="line">    doSomething(myobj);</span><br><span class="line">    &#125;</span><br><span class="line">后：</span><br><span class="line">myobj &amp;&amp; doSomething(myobj);</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>知道函数其实就是一个工具，我们只需要学会使用工具就可以实现某个功能</li><li><p>这就是封装性</p><h3 id="document对象对象-–工具包"><a href="#document对象对象-–工具包" class="headerlink" title="document对象对象 –工具包"></a>document对象对象 –工具包</h3><p>  getElementById() | 根据元素 id 得到元素（第一个）<br>  getElementsByName() | 根据元素 name 得到元素对象的集合<br>  getElementsByTagName() | 根据指定标签名得到元素对象的集合<br>  write() | 向文档写 HTML 表达式 或 JavaScript 代码</p></li><li><p>document.title   //设置文档标题等价于HTML的<title>标签</title></p></li><li>document.bgColor           //设置页面背景色</li><li>document.fgColor           //设置前景色(文本颜色)</li><li>document.linkColor         //未点击过的链接颜色</li><li>document.alinkColor        //激活链接(焦点在此链接上)的颜色</li><li>document.vlinkColor        //已点击过的链接颜色</li><li>document.URL               //设置URL属性从而在同一窗口打开另一网页</li><li>document.fileCreatedDate   //文件建立日期，只读属性</li><li>document.fileModifiedDate  //文件修改日期，只读属性</li><li>document.fileSize          //文件大小，只读属性</li><li>document.cookie            //设置和读出cookie</li><li>document.charset           //设置字符集 简体中文:gb2312</li></ul><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><ul><li><p>indexOf(): 返回某个指定的字符串值在字符串中首次出现的位置,从 0 开始的，数组中没找到字符串则返回 -1，对大小写敏感！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">document.write(str.indexOf(&quot;Hello&quot;) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(str.indexOf(&quot;World&quot;) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(str.indexOf(&quot;world&quot;))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">0</span><br><span class="line">-1</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p>charAt() 方法可返回指定位置的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">document.write(str.charAt(1))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">e</span><br></pre></td></tr></table></figure></li><li><p>concat() 方法用于连接两个或多个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str1=&quot;Hello &quot;</span><br><span class="line">var str2=&quot;world!&quot;</span><br><span class="line">document.write(str1.concat(str2))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure></li><li><p>slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;Hello happy world!&quot;</span><br><span class="line">document.write(str.slice(6,11))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">happy</span><br></pre></td></tr></table></figure></li><li><p>subStr()： 可在字符串中抽取从 start 下标开始的指定数目的字符。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">document.write(str.substr(3))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出:</span><br><span class="line">lo world!</span><br></pre></td></tr></table></figure><ul><li><p>substring(): 用于提取字符串中介于两个指定下标之间的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">document.write(str.substring(3))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">lo world!</span><br></pre></td></tr></table></figure></li><li><p>charAt(): 可返回指定位置的字符。<br>请注意，JavaScript 并没有一种有别于字符串类型的字符数据类型，所以返回的字符是长度为 1 的字符串。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">document.write(str.charAt(1))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">e</span><br></pre></td></tr></table></figure><ul><li>split(): 用于把一个字符串分割成字符串数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var str=&quot;How are you doing today?&quot;</span><br><span class="line"></span><br><span class="line">document.write(str.split(&quot; &quot;) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(str.split(&quot;&quot;) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(str.split(&quot; &quot;,3))</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">How,are,you,doing,today?</span><br><span class="line">H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?</span><br><span class="line">How,are,you</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h2><ul><li><p>join() 方法用于把数组中的所有元素放入一个字符串,元素是通过指定的分隔符进行分隔的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr.join())</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas</span><br></pre></td></tr></table></figure></li><li><p>slice() 方法可从已有的数组中返回选定的元素。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr.slice(1) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas</span><br><span class="line">John,Thomas</span><br><span class="line">George,John,Thomas</span><br></pre></td></tr></table></figure><ul><li><p>concat() 方法用于连接两个或多个数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var a = [1,2,3];</span><br><span class="line">document.write(a.concat(4,5));</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">1,2,3,4,5</span><br></pre></td></tr></table></figure></li><li><p>pop() 方法用于删除并返回数组的最后一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr)</span><br><span class="line"></span><br><span class="line">document.write(&quot;&lt;br /&gt;&quot;)</span><br><span class="line"></span><br><span class="line">document.write(arr.pop())</span><br><span class="line"></span><br><span class="line">document.write(&quot;&lt;br /&gt;&quot;)</span><br><span class="line"></span><br><span class="line">document.write(arr)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas</span><br><span class="line">Thomas</span><br><span class="line">George,John</span><br></pre></td></tr></table></figure></li><li><p>push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr.push(&quot;James&quot;) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas</span><br><span class="line">4</span><br><span class="line">George,John,Thomas,James</span><br></pre></td></tr></table></figure></li><li><p>reverse() 方法用于颠倒数组中元素的顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr.reverse())</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas</span><br><span class="line">Thomas,John,George</span><br></pre></td></tr></table></figure></li><li><p>shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr.shift() + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas</span><br><span class="line">George</span><br><span class="line">John,Thomas</span><br></pre></td></tr></table></figure></li><li><p>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line">arr[3] = &quot;James&quot;</span><br><span class="line">arr[4] = &quot;Adrew&quot;</span><br><span class="line">arr[5] = &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">arr.splice(2,0,&quot;William&quot;)</span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">输出：</span><br><span class="line">George,John,Thomas,James,Adrew,Martin</span><br><span class="line">George,John,William,Thomas,James,Adrew,Martin</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局变量-局部变量-变量声明-变量赋值&quot;&gt;&lt;a href=&quot;#全局变量-局部变量-变量声明-变量赋值&quot; class=&quot;headerlink&quot; title=&quot;全局变量 局部变量 变量声明 变量赋值&quot;&gt;&lt;/a&gt;全局变量 局部变量 变量声明 变量赋值&lt;/h2&gt; &lt;fig
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="js基础理论知识" scheme="http://www.wangbin26.com/tags/js%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
      <category term="js" scheme="http://www.wangbin26.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>面向对象基础</title>
    <link href="http://www.wangbin26.com/2016/07/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.wangbin26.com/2016/07/13/面向对象基础/</id>
    <published>2016-07-13T16:09:38.000Z</published>
    <updated>2018-04-25T15:35:54.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象铺垫-对象创建方式总结"><a href="#面向对象铺垫-对象创建方式总结" class="headerlink" title="面向对象铺垫-对象创建方式总结"></a>面向对象铺垫-对象创建方式总结</h1><h2 id="第一种：创建对象的方式，json方式"><a href="#第一种：创建对象的方式，json方式" class="headerlink" title="第一种：创建对象的方式，json方式"></a>第一种：创建对象的方式，json方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//推荐使用的场合： 作为函数的参数，临时只用一次的场景。比如设置函数原型对象。</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">//对象有自己的 属性 和  行为</span><br><span class="line">// 属性比如： 年龄、姓名、性别</span><br><span class="line">// 行为： 吃饭、睡觉、走路、讲课等... 动作</span><br><span class="line">var obj2 = &#123; </span><br><span class="line">    name: &apos;laoma&apos;, </span><br><span class="line">    age: 18, </span><br><span class="line">    sayHi: function()&#123;</span><br><span class="line">        console.log( name + &apos;say hi&apos; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//添加其他属性：</span><br><span class="line">obj2.newProp = 123;// js的动态特性，如果没有要访问的属性，直接添加属性。</span><br><span class="line"></span><br><span class="line">// 缺点： 不能作为对象创建的模板，也就是不能用new进行构造新对象。</span><br><span class="line"></span><br><span class="line">//=================================================</span><br></pre></td></tr></table></figure><h2 id="第二种：-创建面向对象的方式：-new-Object-的方式。-不推荐使用。"><a href="#第二种：-创建面向对象的方式：-new-Object-的方式。-不推荐使用。" class="headerlink" title="第二种： 创建面向对象的方式： new Object()的方式。 不推荐使用。"></a>第二种： 创建面向对象的方式： new Object()的方式。 不推荐使用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj3 = new Object();</span><br><span class="line">//添加属性</span><br><span class="line">obj3.name = &apos;kitty&apos;;</span><br><span class="line">obj3.sayHi = function() &#123;</span><br><span class="line">    console.log( name + &apos; &apos; + &apos;say hi&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//跟上面的方式一样，只能临时用一下这个对象，不想作为new的构造模板是可以的。</span><br></pre></td></tr></table></figure><h2 id="第三种：-构造函数构造对象方法"><a href="#第三种：-构造函数构造对象方法" class="headerlink" title="第三种： 构造函数构造对象方法"></a>第三种： 构造函数构造对象方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//把 一个函数对象 当做构造函数来使用，一般要把 函数对象的首字母大写</span><br><span class="line">function Persion() &#123;</span><br><span class="line">    this.name = &apos;123&apos;; // 通过this可以直接给 构造出来的对象添加属性。</span><br><span class="line">    this.sayHi = function() &#123;</span><br><span class="line">        console.log( this.name );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">var p  = new Persion(); </span><br><span class="line">//** new 运算符的作用：</span><br><span class="line">// 第一步：</span><br><span class="line">// 执行构造函数（new后面的那个函数），在构</span><br><span class="line">//造函数内部创建一个空对象，</span><br><span class="line">// 第二步： 把上面的空对象跟构造函数的原型对象进行关联。</span><br><span class="line">// 第三步：然后把this 指向当前空对象</span><br><span class="line">//在构造函数执行结束后，把空对象返回 给 p</span><br><span class="line"></span><br><span class="line">console.log( p.name ); //p.name 从构造函数里面创建的。</span><br><span class="line">p.sayHi(); //在此方法内部的 this执行 p对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//绘制原型 和 构造函数 和对象之间的关系。</span><br></pre></td></tr></table></figure><h2 id="第三种方式的升级改造版本："><a href="#第三种方式的升级改造版本：" class="headerlink" title="第三种方式的升级改造版本："></a>第三种方式的升级改造版本：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//第三种方式有个缺点： 对象的内部的函数会在每个对象中都存一份</span><br><span class="line">//如果创建的对象非常多的话，那么非常浪费内存。函数的行为是所有对象</span><br><span class="line">//可以共有，不需要每个对象都保存一份。所以，可以把函数放到原型中</span><br><span class="line">//进行声明，那么所有对象都有了公共的函数，而且内存中只保留一份。</span><br><span class="line">//所有的属性写到对象的内部</span><br><span class="line">//第三种的升级版：</span><br><span class="line">function Sprite() &#123;</span><br><span class="line">    this.name = &apos;123&apos;;</span><br><span class="line">    this.age = 19;</span><br><span class="line">&#125;</span><br><span class="line">Sprite.prototype = &#123;</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    init: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//继续升级： 把属性的设置做成参数化：</span><br><span class="line">function Sprite( sname, sage ) &#123;</span><br><span class="line">    this.name  = sname || &apos;&apos;;</span><br><span class="line">    this.age = sage || 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sprite.prototype = &#123;</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    init: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//问题： 1、调用者如果传递参数的顺序发生变化，那么废了</span><br><span class="line">//问题： 2、 参数增减都会导致函数声明变化，调用的地方也可能发生变化。</span><br><span class="line">//如何解决：继续升级</span><br><span class="line">function Sprite( option ) &#123;  //我用一个对象把所有参数覆盖。灵活性就很强了。</span><br><span class="line">                             //顺序无所谓，添加参数也无所谓了。</span><br><span class="line">    this.name  = option.sname || &apos;&apos;;</span><br><span class="line">    this.age = option.sage || 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sprite.prototype = &#123;</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    init: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//继续优化，把初始化的代码 放到init函数中</span><br><span class="line">function Sprite( option ) &#123;  //我用一个对象把所有参数覆盖。灵活性就很强了。</span><br><span class="line">                             //顺序无所谓，添加参数也无所谓了。</span><br><span class="line">    this.init( option );</span><br><span class="line">&#125;</span><br><span class="line">Sprite.prototype = &#123;</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    init: function( option ) &#123;</span><br><span class="line">        this.name  = option.sname || &apos;&apos;;</span><br><span class="line">        this.age = option.sage || 18;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//以后的canvas课程的开发暂时先用这种的方式</span><br></pre></td></tr></table></figure><hr><h2 id="补充js方法调用的四种模式"><a href="#补充js方法调用的四种模式" class="headerlink" title="补充js方法调用的四种模式"></a>补充js方法调用的四种模式</h2><ul><li><p>方法调用模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Persion() &#123;</span><br><span class="line">    var name1 = &quot;itcast&quot;,</span><br><span class="line">    age1 = 19,</span><br><span class="line">    show1 = function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        age : age1,</span><br><span class="line">        name : name1,</span><br><span class="line">        show : show1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Persion();</span><br><span class="line">p.show();  //在show方法中的this指向了p对象。</span><br></pre></td></tr></table></figure></li><li><p>函数调用模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function add( a, b) &#123;</span><br><span class="line">    this.result = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add( 3, 9 ); //此方法执行的时候，this指向了window</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></li><li><p>构造器调用模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Persion（）&#123;</span><br><span class="line">    this.name = &quot;123&quot;;</span><br><span class="line">    this.age = 19;</span><br><span class="line">    this.show = function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Persion();</span><br><span class="line">p.show();//  在show方法中方法this，指向了p对象实例。</span><br></pre></td></tr></table></figure></li><li><p>call 和 apply调用模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">    this.result = a + b;s           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p  = &#123;&#125;;        //定义一个空对象。</span><br><span class="line">add.call(p,3,4);    //在这个方法调用的时候，this指向了p</span><br><span class="line">console.log(p.result);</span><br><span class="line"></span><br><span class="line">//apply和call是一样的用法，只不过apply第二个参数用数组进行传递。</span><br></pre></td></tr></table></figure></li></ul><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>：函数执行之前，会先将函数中所有的变量，挪到最前面去声明。</p><h3 id="函数名提升"><a href="#函数名提升" class="headerlink" title="函数名提升"></a>函数名提升</h3><p>： script中脚本，在执行之前，会先把脚本中的所有的函数先进行编译解析，然后执行普通的js代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象铺垫-对象创建方式总结&quot;&gt;&lt;a href=&quot;#面向对象铺垫-对象创建方式总结&quot; class=&quot;headerlink&quot; title=&quot;面向对象铺垫-对象创建方式总结&quot;&gt;&lt;/a&gt;面向对象铺垫-对象创建方式总结&lt;/h1&gt;&lt;h2 id=&quot;第一种：创建对象的方式，j
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面向对象" scheme="http://www.wangbin26.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>ES6 class的继承</title>
    <link href="http://www.wangbin26.com/2016/07/10/ES6%20class%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.wangbin26.com/2016/07/10/ES6 class的继承/</id>
    <published>2016-07-10T14:58:44.000Z</published>
    <updated>2018-04-27T07:53:14.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。<br>undefined</p><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。<br>undefined</p><p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。<br>undefined</p><p>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。</p><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。<br>undefined</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。<br>undefined</p><p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p><p>下面是生成子类实例的代码。<br>undefined</p><p>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。</p><p>最后，父类的静态方法，也会被子类继承。<br>undefined</p><p>上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。<br>undefined</p><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h1 id="3-super-关键字"><a href="#3-super-关键字" class="headerlink" title="3.super 关键字"></a>3.super 关键字</h1><p>super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。<br>undefined</p><p>上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。</p><p>注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。<br>undefined</p><p>上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。</p><p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。<br>undefined</p><p>上面代码中，super()用在B类的m方法之中，就会造成句法错误。</p><p>第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。<br>undefined</p><p>上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</p><p>这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。<br>undefined</p><p>上面代码中，p是父类A实例的属性，super.p就引用不到它。</p><p>如果属性定义在父类的原型对象上，super就可以取到。<br>undefined</p><p>上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。</p><p>ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。<br>undefined</p><p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p><p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。<br>undefined</p><p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p><p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。<br>undefined</p><p>上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。</p><p>另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。<br>undefined</p><p>上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。</p><p>注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。<br>undefined</p><p>上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。<br>undefined</p><p>上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。</p><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。<br>undefined</p><h1 id="4-类的-prototype-属性和proto属性"><a href="#4-类的-prototype-属性和proto属性" class="headerlink" title="4.类的 prototype 属性和proto属性"></a>4.类的 prototype 属性和<strong>proto</strong>属性</h1><p>大多数浏览器的 ES5 实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。</p><p>（1）子类的<strong>proto</strong>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类prototype属性的<strong>proto</strong>属性，表示方法的继承，总是指向父类的prototype属性。<br>undefined</p><p>上面代码中，子类B的<strong>proto</strong>属性指向父类A，子类B的prototype属性的<strong>proto</strong>属性指向父类A的prototype属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。<br>undefined</p><p>《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。<br>undefined</p><p>因此，就得到了上面的结果。<br>undefined</p><p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（<strong>proto</strong>属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。<br>undefined</p><p>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p><p>下面，讨论三种特殊情况。</p><p>第一种特殊情况，子类继承Object类。<br>undefined</p><p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p><p>第二种特殊情况，不存在任何继承。<br>undefined</p><p>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.<strong>proto</strong>指向构造函数（Object）的prototype属性。</p><p>第三种特殊情况，子类继承null。<br>undefined</p><p>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回的对象不继承任何方法，所以它的<strong>proto</strong>指向Function.prototype，即实质上执行了下面的代码。<br>undefined</p><p>实例的 <strong>proto</strong> 属性<br>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。<br>undefined</p><p>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。<br>undefined</p><p>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p><h1 id="5-原生构造函数的继承"><a href="#5-原生构造函数的继承" class="headerlink" title="5.原生构造函数的继承"></a>5.原生构造函数的继承</h1><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。</p><p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()<br>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。<br>undefined</p><p>上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。<br>undefined</p><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p><p>ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。</p><p>下面的例子中，我们想让一个普通对象继承Error对象。<br>undefined</p><p>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p><p>ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。<br>undefined</p><p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。</p><p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。<br>undefined</p><p>上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义Error子类的例子，可以用来定制报错时的行为。<br>undefined</p><p>注意，继承Object的子类，有一个行为差异。<br>undefined</p><p>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。</p><h1 id="6-Mixin-模式的实现"><a href="#6-Mixin-模式的实现" class="headerlink" title="6.Mixin 模式的实现"></a>6.Mixin 模式的实现</h1><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。<br>undefined</p><p>上面代码中，c对象是a对象和b对象的合成，具有两者的接口。</p><p>下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。<br>undefined</p><p>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。<br>undefined</p><footer><strong>阮一峰</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">ECMAScript 6 入门</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h1&gt;&lt;p&gt;Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript6" scheme="http://www.wangbin26.com/tags/ECMAScript6/"/>
    
      <category term="class关键字" scheme="http://www.wangbin26.com/tags/class%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>ES6 class的基本语法</title>
    <link href="http://www.wangbin26.com/2016/07/05/ES6%20class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.wangbin26.com/2016/07/05/ES6 class的基本语法/</id>
    <published>2016-07-05T20:58:23.000Z</published>
    <updated>2018-04-27T07:53:08.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。<br>undefined</p><p>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。</p><p>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。<br>undefined</p><p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。</p><p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。<br>undefined</p><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br>undefined</p><p>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br>undefined</p><p>在类的实例上面调用方法，其实就是调用原型上的方法。<br>undefined</p><p>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p><p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。<br>undefined</p><p>prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><p><code>Point.prototype.constructor === Point // true</code><br>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。<br>undefined</p><p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。<br>undefined</p><p>上面代码采用 ES5 的写法，toString方法就是可枚举的。</p><p>类的属性名，可以采用表达式。<br>undefined</p><p>上面代码中，Square类的方法名getArea，是从表达式得到的。</p><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><p>考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。</p><h2 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h2><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>undefined</p><p>上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。</p><p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br>undefined</p><p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p><p>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。<br>undefined</p><h2 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h2><p>生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。<br>undefined</p><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。<br>undefined</p><p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。</p><p>与 ES5 一样，类的所有实例共享一个原型对象。<br>undefined</p><p>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以<strong>proto</strong>属性是相等的。</p><p>这也意味着，可以通过实例的<strong>proto</strong>属性为“类”添加方法。</p><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。<br>undefined</p><p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的<strong>proto</strong>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p><h2 id="Class-表达式"><a href="#Class-表达式" class="headerlink" title="Class 表达式"></a>Class 表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。<br>undefined</p><p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。<br>undefined</p><p>上面代码表示，Me只在 Class 内部有定义。</p><p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p><p><code>const MyClass = class { /* ... */ };</code><br>采用 Class 表达式，可以写出立即执行的 Class。<br>undefined</p><p>上面代码中，person是一个立即执行的类的实例。</p><h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。<br>undefined</p><p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。<br>undefined</p><p>上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。</p><h2 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h2><p>现有的方法<br>私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。<br>undefined</p><p>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。<br>undefined</p><p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。<br>undefined</p><p>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><p>私有属性的提案<br>与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。<br>undefined</p><p>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p><p>私有属性可以指定初始值，在构造函数执行时进行初始化。<br>undefined</p><p>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。</p><p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。<br>undefined</p><p>上面代码中，#sum()就是一个私有方法。</p><p>另外，私有属性也可以设置 getter 和 setter 方法。<br>undefined</p><p>上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。</p><h2 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h2><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。<br>undefined</p><p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。<br>undefined</p><p>另一种解决方法是使用箭头函数。<br>undefined</p><p>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。<br>undefined</p><h2 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h2><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。<br>undefined</p><p>name属性总是返回紧跟在class关键字后面的类名。</p><p>Class 的取值函数（getter）和存值函数（setter）<br>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。<br>undefined</p><p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><p>存值函数和取值函数是设置在属性的 Descriptor 对象上的。<br>undefined</p><p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。</p><h2 id="Class-的-Generator-方法"><a href="#Class-的-Generator-方法" class="headerlink" title="Class 的 Generator 方法"></a>Class 的 Generator 方法</h2><p>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。<br>undefined</p><p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p><h2 id="Class-的静态方法"><a href="#Class-的静态方法" class="headerlink" title="Class 的静态方法"></a>Class 的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br>undefined</p><p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。<br>undefined</p><p>上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。<br>undefined</p><p>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p><p>静态方法也是可以从super对象上调用的。<br>undefined</p><h2 id="Class-的静态属性和实例属性"><a href="#Class-的静态属性和实例属性" class="headerlink" title="Class 的静态属性和实例属性"></a>Class 的静态属性和实例属性</h2><p>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。<br>undefined</p><p>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。<br>undefined</p><p>目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。</p><p>###（1）类的实例属性</p><p>类的实例属性可以用等式，写入类的定义之中。<br>undefined</p><p>上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p><p>以前，我们定义实例属性，只能写在类的constructor方法里面。<br>undefined</p><p>上面代码中，构造方法constructor里面，定义了this.state属性。</p><p>有了新的写法以后，可以不在constructor方法里面定义。<br>undefined</p><p>这种写法比以前更清晰。</p><p>为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。<br>undefined</p><h3 id="（2）类的静态属性"><a href="#（2）类的静态属性" class="headerlink" title="（2）类的静态属性"></a>（2）类的静态属性</h3><p>类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。<br>undefined</p><p>同样的，这个新写法大大方便了静态属性的表达。<br>undefined</p><p>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><h2 id="new-target-属性"><a href="#new-target-属性" class="headerlink" title="new.target 属性"></a>new.target 属性</h2><p>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。<br>undefined</p><p>上面代码确保构造函数只能通过new命令调用。</p><p>Class 内部调用new.target，返回当前 Class。<br>undefined</p><p>需要注意的是，子类继承父类时，new.target会返回子类。<br>undefined</p><p>上面代码中，new.target会返回子类。</p><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。<br>undefined</p><p>上面代码中，Shape类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用new.target会报错。</p><footer><strong>阮一峰</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">ECMAScript 6 入门</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h1 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h1&gt;&lt;p&gt;JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。&lt;br&gt;unde
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript6" scheme="http://www.wangbin26.com/tags/ECMAScript6/"/>
    
      <category term="class关键字" scheme="http://www.wangbin26.com/tags/class%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>konva节选</title>
    <link href="http://www.wangbin26.com/2016/06/27/Konva%E8%8A%82%E9%80%89/"/>
    <id>http://www.wangbin26.com/2016/06/27/Konva节选/</id>
    <published>2016-06-27T08:09:38.000Z</published>
    <updated>2018-04-25T15:37:17.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="形状-Shape"><a href="#形状-Shape" class="headerlink" title="形状/Shape"></a>形状/Shape</h1><h2 id="矩形-Rect"><a href="#矩形-Rect" class="headerlink" title="矩形/Rect"></a>矩形/Rect</h2><p>矩形的创建：</p><pre><code>var rect = new Konva.Rect({    // 定位属性，左上宽高    x: 50,    y: 50,    width: 100,    height: 50,    // 样式属性    fill: &apos;green&apos;, // 填充色    stroke: &apos;black&apos;, // 描边色    strokeWidth: 4 // 描边宽度});</code></pre><h2 id="线-Line"><a href="#线-Line" class="headerlink" title="线/Line"></a>线/Line</h2><p>线的创建：</p><pre><code>var redLine = new Konva.Line({    // 定位属性，每两个数值决定一个点    points: [5, 70, 140, 23, 250, 60, 300, 20],    // 样式属性    stroke: &apos;red&apos;,     strokeWidth: 15,    lineCap: &apos;round&apos;, // 即线条的起点和终点的样式    lineJoin: &apos;round&apos;, // 每个折点的样式    dash: [33, 10], // 虚线样式，这里指每隔33个单位，有10个单位的间隔    // 闭合，可以用于绘制不规则多边形    fill: &apos;#00D2FF&apos;,    closed : true,    // 平滑度 越低过渡越平滑    tension : 1,});</code></pre><h2 id="图片-Image"><a href="#图片-Image" class="headerlink" title="图片/Image"></a>图片/Image</h2><pre><code>var img = new Konva.Image({  // 定位属性    x: 50,    y: 50,    width: 106,    height: 118,  // 资源属性 接收一个Image对象（标签）    image: imageObj,});</code></pre><h2 id="文字-Text"><a href="#文字-Text" class="headerlink" title="文字/Text"></a>文字/Text</h2><pre><code>var simpleText = new Konva.Text({    // 定位属性      x: stage.getWidth() / 2,      y: 15,    // 文本内容      text: &apos;Simple Text&apos;,    // 字体样式      fontSize: 30, // 字体大小      fontFamily: &apos;Calibri&apos;, // 字体      fill: &apos;green&apos; // 填充颜色});</code></pre><h1 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件/Event"></a>事件/Event</h1><h2 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h2><pre><code>obj.on(&apos;click&apos;, function() {    ...});obj.on(&apos;tap.s&apos;, function() {    ...});</code></pre><h2 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h2><pre><code>obj.off(&apos;click&apos;)obj.off(&apos;.s&apos;)</code></pre><h2 id="判定区域"><a href="#判定区域" class="headerlink" title="判定区域"></a>判定区域</h2><p>形状可以为hitFunc属性添加一个函数，用于自定义一个形状的点击判定区域。</p><pre><code>hitFunc: function(context) {    context.beginPath();    context.arc(0, 0, this.getOuterRadius() + 10, 0, Math.PI * 2, true);    context.closePath();    context.fillStrokeShape(this);}</code></pre><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="Tween动画"><a href="#Tween动画" class="headerlink" title="Tween动画"></a>Tween动画</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code>var tween = new Konva.Tween({    node: rect, // 目标节点    duration: 1, // 动画时间    // 结束时的属性    x: 140,    y: 90,    fill : &apos;red&apos;,    rotation: Math.PI * 2,    opacity: 1,    strokeWidth: 6,    scaleX: 1.5，    // 动画结束时的回调    onFinish:finishFn});</code></pre><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p>tween对象自带六种方法，用于控制动画播放：</p><p><code>play()</code>播放, <code>pause()</code>暂停, <code>reverse()</code>反转, <code>reset()</code>重置, <code>finish()</code>结束</p><h2 id="Animation动画"><a href="#Animation动画" class="headerlink" title="Animation动画"></a>Animation动画</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间。</p><pre><code>var anim = new Konva.Animation(function(frame) {  var time = frame.time, // 动画执行的总时间      timeDiff = frame.timeDiff, // 距离上一帧的时间      frameRate = frame.frameRate; // 帧率（既1000/间隔时间）   // update stuff}, layer);anim.start();</code></pre><h3 id="控制-1"><a href="#控制-1" class="headerlink" title="控制"></a>控制</h3><p>animation对象提供start()和stop()两个方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;形状-Shape&quot;&gt;&lt;a href=&quot;#形状-Shape&quot; class=&quot;headerlink&quot; title=&quot;形状/Shape&quot;&gt;&lt;/a&gt;形状/Shape&lt;/h1&gt;&lt;h2 id=&quot;矩形-Rect&quot;&gt;&lt;a href=&quot;#矩形-Rect&quot; class=&quot;header
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="canvas" scheme="http://www.wangbin26.com/tags/canvas/"/>
    
      <category term="konva" scheme="http://www.wangbin26.com/tags/konva/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6编程风格</title>
    <link href="http://www.wangbin26.com/2016/06/22/ECMAScript6%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    <id>http://www.wangbin26.com/2016/06/22/ECMAScript6编程风格/</id>
    <published>2016-06-22T12:22:53.000Z</published>
    <updated>2018-04-27T07:53:00.495Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1.块级作用域"></a>1.块级作用域</h1><h2 id="（1）let-取代-var"><a href="#（1）let-取代-var" class="headerlink" title="（1）let 取代 var"></a>（1）let 取代 var</h2><p>ES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。</p>undefined<p>上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。</p><p>var命令存在变量提升效用，let命令没有这个问题。<br>undefined</p><p>上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p><p>所以，建议不再使用var命令，而是使用let命令取代。</p><h2 id="（2）全局常量和线程安全"><a href="#（2）全局常量和线程安全" class="headerlink" title="（2）全局常量和线程安全"></a>（2）全局常量和线程安全</h2><p>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。</p><p>const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。<br>undefined</p><p>const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p><p>所有的函数都应该设置为常量。</p><p>长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><h1 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h1><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。<br>undefined</p><h1 id="3-解构赋值"><a href="#3-解构赋值" class="headerlink" title="3.解构赋值"></a>3.解构赋值</h1><p>使用数组成员对变量赋值时，优先使用解构赋值。<br>undefined</p><p>函数的参数如果是对象的成员，优先使用解构赋值。<br>undefined</p><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。<br>undefined</p><h1 id="4-对象"><a href="#4-对象" class="headerlink" title="4.对象"></a>4.对象</h1><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。<br>undefined</p><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。<br>undefined</p><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。<br>undefined</p><p>上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p><p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。<br>undefined</p><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h1><p>使用扩展运算符（…）拷贝数组。<br>undefined</p><p>使用 Array.from 方法，将类似数组的对象转为数组。<br>undefined</p><h1 id="6-函数"><a href="#6-函数" class="headerlink" title="6.函数"></a>6.函数</h1><p>立即执行函数可以写成箭头函数的形式。<br>undefined</p><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。<br>undefined</p><p>箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。<br>undefined</p><p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。<br>undefined</p><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。<br>undefined</p><p>使用默认值语法设置函数参数的默认值。<br>undefined</p><h1 id="7-Map-结构"><a href="#7-Map-结构" class="headerlink" title="7.Map 结构"></a>7.Map 结构</h1><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。<br>undefined</p><h1 id="8-Class"><a href="#8-Class" class="headerlink" title="8.Class"></a>8.Class</h1><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。<br>undefined</p><p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。<br>undefined</p><h1 id="9-模块"><a href="#9-模块" class="headerlink" title="9.模块"></a>9.模块</h1><p>首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。<br>undefined</p><p>使用export取代module.exports。<br>undefined</p><p>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。</p><p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。<br>undefined</p><p>如果模块默认输出一个函数，函数名的首字母应该小写。<br>undefined</p><p>如果模块默认输出一个对象，对象名的首字母应该大写。<br>undefined</p><h1 id="10-ESLint-的使用"><a href="#10-ESLint-的使用" class="headerlink" title="10.ESLint 的使用"></a>10.ESLint 的使用</h1><p>ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p><p>首先，安装 ESLint。</p><p><code>$ npm i -g eslint</code><br>然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。<br>undefined</p><p>最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。<br>undefined</p><p>现在就可以检查，当前项目的代码是否符合预设的规则。</p><p>index.js文件的代码如下。<br>undefined</p><p>使用 ESLint 检查这个文件，就会报出错误。<br>undefined</p><p>上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。</p><footer><strong>阮一峰</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">ECMAScript 6 入门</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h1 id=&quot;1-块级作用域&quot;&gt;&lt;a href=&quot;#1-块级作用域&quot; class=&quot;headerlink&quot; title=&quot;1.块级作用域&quot;&gt;&lt;/a&gt;1.块级作用域&lt;/h1&gt;&lt;h2 id=&quot;（1）let-取代-var&quot;&gt;&lt;a href=&quot;#（1）let-取
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript6" scheme="http://www.wangbin26.com/tags/ECMAScript6/"/>
    
      <category term="编程风格" scheme="http://www.wangbin26.com/tags/%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>canvas基础笔记</title>
    <link href="http://www.wangbin26.com/2016/06/12/canvas%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.wangbin26.com/2016/06/12/canvas基础/</id>
    <published>2016-06-12T08:09:38.000Z</published>
    <updated>2018-04-27T08:54:47.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、canvas简介"><a href="#一、canvas简介" class="headerlink" title="一、canvas简介"></a>一、canvas简介</h1><h2 id="1-1-什么是canvas？"><a href="#1-1-什么是canvas？" class="headerlink" title="1.1 什么是canvas？"></a>1.1 什么是canvas？</h2><ul><li><p>是HTML5提供的一种新标签</p></li><li><p>Canvas是一个矩形区域的画布，可以用JavaScript在上面绘画。控制其每一个像素。</p></li><li>canvas 标签使用 JavaScript 在网页上绘制图像，本身不具备绘图功能。</li><li>canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li><li>HTML5之前的web页面只能用一些固定样式的标签：比如p、div、h1等</li></ul><h2 id="1-2-canvas主要应用的领域"><a href="#1-2-canvas主要应用的领域" class="headerlink" title="1.2 canvas主要应用的领域"></a>1.2 canvas主要应用的领域</h2><ol><li><p>游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。<br> <a href="http://www.oschina.net/news/20143/top-25-best-html5-canvas-games-you-love-to-play" target="_blank" rel="noopener">25 超棒的 HTML5 Canvas 游戏</a></p></li><li><p><strong>可视化数据</strong>.数据图表话，比如:<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">百度的echart</a>    </p></li><li><p><strong>banner广告</strong>：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。</p></li><li><p>未来=&gt; 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。</p></li><li><p>未来=&gt; 远程计算机控制：Canvas可以让开发者更好地实现基于Web的数据传输，构建一个完美的可视化控制界面。</p></li><li><p>未来=&gt; 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。</p></li><li><p>其他可嵌入网站的内容(多用于活动页面、特效)：类似图表、音频、视频，还有许多元素能够更好地与Web融合，并且不需要任何插件。</p></li><li><p><strong>完整的canvas移动化应用</strong></p></li><li><p>目标</p><ul><li>我们不是主要做游戏开发的</li><li>要求必须会做基本的用canvas绘制的特效页面：</li><li>会用canvas做一些简单的广告、活动页面</li></ul></li><li><p>案例和项目演示</p></li><li><p>canvas的标准： </p><ul><li>最新标准：<a href="http://www.w3.org/TR/2dcontext/" target="_blank" rel="noopener">http://www.w3.org/TR/2dcontext/</a></li><li>稳定版本的标准：<a href="http://www.w3.org/TR/2013/CR-2dcontext-20130806/" target="_blank" rel="noopener">http://www.w3.org/TR/2013/CR-2dcontext-20130806/</a></li><li>目前来说，标准还在完善中。先用早期的api足够完成所有的应用<h1 id="二、canvas绘图基础"><a href="#二、canvas绘图基础" class="headerlink" title="二、canvas绘图基础"></a>二、canvas绘图基础</h1></li></ul></li></ol><h2 id="2-0-sublime配置canvas插件"><a href="#2-0-sublime配置canvas插件" class="headerlink" title="2.0 sublime配置canvas插件"></a>2.0 sublime配置canvas插件</h2><pre><code>推荐：    安装插件：AndyJS2    github地址： https://github.com/malun666/AndyJS2    直接下载到：X:\Users\用户名\AppData\Roaming\Sublime Text 3\Packages</code></pre><h2 id="2-1-Canvas标签"><a href="#2-1-Canvas标签" class="headerlink" title="2.1 Canvas标签"></a>2.1 Canvas标签</h2><h3 id="2-1-1-canvas标签语法和属性-（重点）"><a href="#2-1-1-canvas标签语法和属性-（重点）" class="headerlink" title="2.1.1 canvas标签语法和属性  （重点）"></a>2.1.1 canvas标签语法和属性  （重点）</h3><ul><li>canvas：画布油布的意思 ==英 [‘kænvəs]   美 [‘kænvəs] ==</li><li>标签名canvas，需要进行闭合。就是一普通的html标签。</li><li>可以设置width和height属性，但是属性值<strong>单位必须是px</strong>，否则忽略。</li><li>width和hegiht：默认300*150像素</li><li>注意：<ul><li>不要用CSS控制它的宽和高,会走出图片拉伸，</li><li>重新设置canvas标签的宽高属性会让画布擦除所有的内容。</li><li>可以给canvas画布设置背景色</li></ul></li></ul><h3 id="2-1-2-浏览器不兼容处理（重点）"><a href="#2-1-2-浏览器不兼容处理（重点）" class="headerlink" title="2.1.2 浏览器不兼容处理（重点）"></a>2.1.2 浏览器不兼容处理（重点）</h3><ul><li>ie9以上才支持canvas, 其他chrome、ff、苹果浏览器等都支持</li><li>只要浏览器兼容canvas，那么就会支持绝大部分api(个别最新api除外)</li><li>移动端的兼容情况非常理想，基本上随便使用</li><li>2d的支持的都非常好，3d（webgl）ie11才支持，其他都支持</li><li><p>如果浏览器不兼容，最好进行友好提示         </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：                     </span><br><span class="line">&lt;canvas id=&quot;cavsElem&quot;&gt;</span><br><span class="line">    你的浏览器不支持canvas，请升级浏览器.浏览器不支持，显示此行文本</span><br><span class="line">&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></li><li><p>浏览器不兼容，可以使用<em>flash</em>等手段进行<strong>优雅降级</strong></p></li></ul><h2 id="2-2-canvas绘图上下文context"><a href="#2-2-canvas绘图上下文context" class="headerlink" title="2.2 canvas绘图上下文context"></a>2.2 canvas绘图上下文context</h2><h3 id="2-2-1-Context：Canvas的上下文、绘制环境。（重点掌握）"><a href="#2-2-1-Context：Canvas的上下文、绘制环境。（重点掌握）" class="headerlink" title="2.2.1 Context：Canvas的上下文、绘制环境。（重点掌握）"></a>2.2.1 Context：Canvas的上下文、绘制环境。（重点掌握）</h3><ul><li>上下文：上知天文，下知地理。是所有的绘制操作api的入口或者集合。</li><li>Canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。</li><li>Context对象就是JavaScript操作Canvas的接口。<br>*使用[CanvasElement].getContext(‘2d’)来获取2D绘图上下文。        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var canvas  = document.getElementById( &apos;cavsElem&apos; ); //获得画布</span><br><span class="line">var ctx = canvas.getContext( &apos;2d&apos; );//注意：2d小写， 3d：webgl</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3-基本的绘制路径（重点）"><a href="#2-3-基本的绘制路径（重点）" class="headerlink" title="2.3 基本的绘制路径（重点）"></a>2.3 基本的绘制路径（重点）</h2><h3 id="2-3-1-canvas坐标系"><a href="#2-3-1-canvas坐标系" class="headerlink" title="2.3.1 canvas坐标系"></a>2.3.1 canvas坐标系</h3><pre><code>canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大</code></pre><p><img src="http://p7u359del.bkt.clouddn.com/canvas-x-y.png" height="532" width="730"></p><h3 id="2-3-2-设置绘制起点-moveTo"><a href="#2-3-2-设置绘制起点-moveTo" class="headerlink" title="2.3.2 设置绘制起点(moveTo)"></a>2.3.2 设置绘制起点(moveTo)</h3><pre><code>* 语法：ctx.moveTo(x, y); * 解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置* 参数：x,y 都是相对于 canvas盒子的最左上角。* 注意：**绘制线段前必须先设置起点。**</code></pre><h3 id="2-3-3-绘制直线-lineTo"><a href="#2-3-3-绘制直线-lineTo" class="headerlink" title="2.3.3 绘制直线(lineTo)"></a>2.3.3 绘制直线(lineTo)</h3><pre><code>* 语法：ctx.lineTo(x, y);* 解释：从x,y的位置绘制一条直线到起点或者上一个线头点。* 参数：x,y 线头点坐标。</code></pre><h3 id="2-3-4-路径开始和闭合"><a href="#2-3-4-路径开始和闭合" class="headerlink" title="2.3.4 路径开始和闭合"></a>2.3.4 路径开始和闭合</h3><pre><code>* 开始路径：ctx.beginPath();* 闭合路径：ctx.closePath();* 解释：如果是绘制不同状态的线段或者形状，必须使用开始新路径的方法把不同的绘制操作隔开。闭合路径会自动把最后的线头和开始的线头连在一起。* beginPath: 核心的作用是将 不同绘制的形状进行隔离，  每次执行此方法，表示重新绘制一个路径,跟之前的绘制的墨迹可以进行分开样式设置和管理。</code></pre><h3 id="2-3-5-描边-stroke"><a href="#2-3-5-描边-stroke" class="headerlink" title="2.3.5 描边(stroke)"></a>2.3.5 描边(stroke)</h3><pre><code>* 语法：ctx.stroke();* 解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行stroke* stroke: （用笔等）画；轻抚；轻挪；敲击；划尾桨；划掉；（打字时）击打键盘 英 [strəʊk]   美 [strok]</code></pre><ul><li><p>canvas绘制的基本步骤：</p><ul><li>第一步：获得上下文 =&gt;canvasElem.getContext(‘2d’);</li><li>第二步：开始路径规划 =&gt;ctx.beginPath()</li><li>第三步：移动起始点 =&gt;ctx.moveTo(x, y)</li><li>第四步：绘制线(矩形、圆形、图片…) =&gt;ctx.lineTo(x, y)</li><li>第五步：闭合路径 =&gt;ctx.closePath();</li><li>第六步：绘制描边 =&gt;ctx.stroke();<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html部分：</span><br><span class="line">    &lt;canvas id=&quot;cavsElem&quot;&gt;</span><br><span class="line">        你的浏览器不支持canvas，请升级浏览器</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">javascript部分：</span><br><span class="line"></span><br><span class="line">//===============基本绘制api====================</span><br><span class="line">//获得画布</span><br><span class="line">var canvas = document.querySelector(&apos;#cavsElem&apos;);</span><br><span class="line">var ctx = canvas.getContext(&apos;2d&apos;);  //获得上下文</span><br><span class="line"></span><br><span class="line">canvas.width = 900;     //设置标签的属性宽高</span><br><span class="line">canvas.height = 600;    //千万不要用 canvas.style.height</span><br><span class="line">canvas.style.border = &quot;1px solid #000&quot;;</span><br><span class="line"></span><br><span class="line">//绘制三角形</span><br><span class="line">ctx.beginPath();        //开始路径</span><br><span class="line">ctx.moveTo(100,100);    //三角形，左顶点</span><br><span class="line">ctx.lineTo(300, 100);   //右顶点</span><br><span class="line">ctx.lineTo(300, 300);   //底部的点</span><br><span class="line">ctx.closePath();        //结束路径</span><br><span class="line">ctx.stroke();           //描边路径</span><br></pre></td></tr></table></figure></li></ul></li><li><p>综合案例：02绘制定位表格.html</p></li><li>综合案例：03画画板.html</li></ul><h3 id="2-3-7-填充-fill"><a href="#2-3-7-填充-fill" class="headerlink" title="2.3.7 填充(fill)"></a>2.3.7 填充(fill)</h3><pre><code>* 语法：ctx.fill(); * 解释：填充，是将闭合的路径的内容填充具体的颜色。默认黑色。* 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。    以下是非0环绕原则的原理：（了解即可，非常少会用到复杂的路径）    “非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段，    使此线段的终点完全落在路径范围之外。    图2-14中的那三个箭头所描述的就是上面这个步骤。    接下来，将计数器初始化为0，    然后，每当这条线段与路径上的直线或曲线相交时，    就改变计数器的值。如果是与路径的顺时针部分相交，则加1，    如果是与路径的逆时针部分相交，则减1。若计数器的最终值不是0，那么此区域就在路径里面，在调用fill()方法时，    浏览器就会对其进行填充。    如果最终值是0，那么此区域就不在路径内部，浏览器也就不会对其进行填充了* 案例： 04填充矩形.html</code></pre><p><img src="http://p7u359del.bkt.clouddn.com/fill-0-prin.jpg" height="206" width="289"></p><h3 id="2-3-8-快速创建矩形rect-方法"><a href="#2-3-8-快速创建矩形rect-方法" class="headerlink" title="2.3.8 快速创建矩形rect()方法"></a>2.3.8 快速创建矩形rect()方法</h3><pre><code>* 语法：ctx.rect(x, y, width, height);* 解释：x, y是矩形左上角坐标， width和height都是以像素计* rect方法只是规划了矩形的路径，并没有填充和描边。* 改造案例：04填充矩形.html*rect: abbr. 矩形（rectangular）；收据（receipt）</code></pre><h3 id="2-3-9-快速创建描边矩形和填充矩形"><a href="#2-3-9-快速创建描边矩形和填充矩形" class="headerlink" title="2.3.9 快速创建描边矩形和填充矩形"></a>2.3.9 快速创建描边矩形和填充矩形</h3><pre><code>* 语法： ctx.strokeRect(x, y, width, height);    - 参数跟2.3.8相同，注意此方法绘制完路径后立即进行stroke绘制* 语法：ctx.fillRect(x, y, width, height);    - 参数跟2.3.8相同， 此方法执行完成后。立即对当前矩形进行fill填充。</code></pre><h3 id="2-3-10-清除矩形-clearRect"><a href="#2-3-10-清除矩形-clearRect" class="headerlink" title="2.3.10 清除矩形(clearRect)"></a>2.3.10 清除矩形(clearRect)</h3><pre><code>* 语法：ctx.clearRect(x, y, width, hegiht);* 解释：清除某个矩形内的绘制的内容，相当于橡皮擦。</code></pre><h2 id="2-4-绘制圆形（arc"><a href="#2-4-绘制圆形（arc" class="headerlink" title="2.4 绘制圆形（arc)"></a>2.4 绘制圆形（arc)</h2><ul><li><p>概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。</p><ul><li>语法：ctx.arc(x,y,r,sAngle,eAngle,counterclockwise);</li><li>arc:  弧（度）弧形物；天穹 英 [ɑːk]   美 [ɑrk]</li><li>counter 反击，还击；反向移动，对着干；反驳，回答  [‘kaʊntə]   美 [‘kaʊntɚ]</li><li>解释：<ul><li>x,y：圆心坐标。 </li><li>r：半径大小。</li><li>sAngle:绘制开始的角度。 圆心到最右边点是0度，顺时针方向弧度增大。</li><li>eAngel:结束的角度，注意是弧度。π</li><li>counterclockwise：是否是逆时针。true是逆时针，false：顺时针</li><li>弧度和角度的转换公式： rad = deg*Math.PI/180;  </li><li>在Math提供的方法中<strong>sin、cos等都使用的弧度</strong><br><img src="http://p7u359del.bkt.clouddn.com/arc.gif" alt="图片" title="title3">   </li></ul></li></ul></li><li><p>案例：05绘制圆形.html</p></li><li>案例：06绘制饼状图.html</li></ul><h2 id="2-5-绘制文字（会使用就可以了）"><a href="#2-5-绘制文字（会使用就可以了）" class="headerlink" title="2.5 绘制文字（会使用就可以了）"></a>2.5 绘制文字（会使用就可以了）</h2><h3 id="2-5-1-绘制上下文的文字属性-（有印象就行了）"><a href="#2-5-1-绘制上下文的文字属性-（有印象就行了）" class="headerlink" title="2.5.1 绘制上下文的文字属性 （有印象就行了）"></a>2.5.1 绘制上下文的文字属性 （有印象就行了）</h3><ul><li><p>font            设置或返回文本内容的当前字体属性</p><ul><li>font 属性使用的语法与 CSS font 属性相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：ctx.font = &quot;18px &apos;微软雅黑&apos;&quot;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>textAlign       设置或返回文本内容的当前对齐方式</p><ul><li>start :    默认。文本在指定的位置开始。</li><li>end   :    文本在指定的位置结束。</li><li>center:    文本的中心被放置在指定的位置。</li><li>left  :    文本左对齐。</li><li>right :    文本右对齐。      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 例如：ctx.textAlign = &apos;left&apos;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="http://p7u359del.bkt.clouddn.com/textAsign.png" alt="对齐图片"></p><ul><li>textBaseline      设置或返回在绘制文本时使用的当前文本基线   <ul><li>alphabetic ：   默认。文本基线是普通的字母基线。</li><li>top        ：   文本基线是 em 方框的顶端。。</li><li>hanging    ：   文本基线是悬挂基线。</li><li>middle     ：   文本基线是 em 方框的正中。</li><li>ideographic：   文本基线是em基线。</li><li>bottom     ：   文本基线是 em 方框的底端。     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： ctx.textBaseline = &apos;top&apos;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="http://p7u359del.bkt.clouddn.com/font-line1.png" alt="设置文字为主"><br><img src="http://p7u359del.bkt.clouddn.com/textBaseline.gif" height="268" width="300" alt="">  </p><h3 id="2-5-2-上下文绘制文字方法"><a href="#2-5-2-上下文绘制文字方法" class="headerlink" title="2.5.2 上下文绘制文字方法"></a>2.5.2 上下文绘制文字方法</h3><pre><code>* ctx.fillText()      在画布上绘制“被填充的”文本* ctx.strokeText()    在画布上绘制文本（无填充）* ctx.measureText()   返回包含指定文本宽度的对象</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//综合案例代码：</span><br><span class="line">ctx.moveTo( 300, 300 );</span><br><span class="line">ctx.fillStyle = &quot;purple&quot;;               //设置填充颜色为紫色</span><br><span class="line">ctx.font = &apos;20px &quot;微软雅黑&quot;&apos;;           //设置字体</span><br><span class="line">ctx.textBaseline = &quot;bottom&quot;;            //设置字体底线对齐绘制基线</span><br><span class="line">ctx.textAlign = &quot;left&quot;;                 //设置字体对齐的方式</span><br><span class="line">//ctx.strokeText( &quot;left&quot;, 450, 400 );</span><br><span class="line">ctx.fillText( &quot;Top-g&quot;, 100, 300 );        //填充文字</span><br></pre></td></tr></table></figure><h3 id="2-5-3-案例07文字绘制-html"><a href="#2-5-3-案例07文字绘制-html" class="headerlink" title="2.5.3 案例07文字绘制.html"></a>2.5.3 案例07文字绘制.html</h3><hr><h2 id="2-6-绘制图片（drawImage）-（重点）"><a href="#2-6-绘制图片（drawImage）-（重点）" class="headerlink" title="2.6 绘制图片（drawImage）  （重点）"></a>2.6 绘制图片（drawImage）  （重点）</h2><h3 id="2-6-1-基本绘制图片的方式"><a href="#2-6-1-基本绘制图片的方式" class="headerlink" title="2.6.1 基本绘制图片的方式"></a>2.6.1 基本绘制图片的方式</h3><pre><code>context.drawImage(img,x,y);参数说明： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。</code></pre><h3 id="2-6-2-在画布上绘制图像，并规定图像的宽度和高度"><a href="#2-6-2-在画布上绘制图像，并规定图像的宽度和高度" class="headerlink" title="2.6.2 在画布上绘制图像，并规定图像的宽度和高度"></a>2.6.2 在画布上绘制图像，并规定图像的宽度和高度</h3><pre><code>context.drawImage(img,x,y,width,height);   参数说明：width 绘制图片的宽度，  height：绘制图片的高度如果指定宽高，最好成比例，不然图片会被拉伸&lt;/em&gt;    等比公式：  toH = Height * toW   /  Width;  //等比              设置高 = 原高度 * 设置宽/ 原宽度;</code></pre><h3 id="2-6-3-图片裁剪，并在画布上定位被剪切的部分"><a href="#2-6-3-图片裁剪，并在画布上定位被剪切的部分" class="headerlink" title="2.6.3 图片裁剪，并在画布上定位被剪切的部分"></a>2.6.3 图片裁剪，并在画布上定位被剪切的部分</h3><pre><code>context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);参数说明：    sx,sy 裁剪的左上角坐标，    swidth：裁剪图片的高度。 sheight:裁剪的高度     其他同上</code></pre><h3 id="2-6-4-用JavaScript创建img对象"><a href="#2-6-4-用JavaScript创建img对象" class="headerlink" title="2.6.4 用JavaScript创建img对象"></a>2.6.4 用JavaScript创建img对象</h3><pre><code>第一种方式：    var img = document.getElementById(&quot;imgId&quot;);第二种方式：    var img = new Image();//这个就是 img标签的dom对象    img.src = &quot;imgs/arc.gif&quot;;    img.alt = &quot;文本信息&quot;;    img.onload = function() {        //图片加载完成后，执行此方法    }</code></pre><h3 id="2-6-5-面向对象基础复习补充："><a href="#2-6-5-面向对象基础复习补充：" class="headerlink" title="2.6.5 面向对象基础复习补充："></a>2.6.5 面向对象基础复习补充：</h3><ul><li><p>创建对象的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* var o = &#123; name: &apos;123&apos;, age: 18 &#125;; //json方式创建</span><br><span class="line">* var o = new Object();  //通过new的方式创建</span><br><span class="line">* var o = new Persion(); //通过类的构造函数创建</span><br></pre></td></tr></table></figure></li><li><p>JS中对象的属性创建方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* json的方式： var o = &#123; age: 19 &#125;;</span><br><span class="line">* 直接添加属性：var o = &#123;&#125;;  o.age = 19;//太分散了，不利于管理</span><br><span class="line">* 由于js动态语言的特性，如果属性不存在的时候，直接添加属性。</span><br><span class="line">* 构造函数添加属性</span><br><span class="line">* 原型添加公共的属性</span><br></pre></td></tr></table></figure></li><li><p>JS的构造函数的原型<br>  构造函数的原型就是：构造对象的模板，构造函数原型里面的所有的属性和方法都会共享给所有的 构造函数构造出来的所有实例。<br><img src="http://p7u359del.bkt.clouddn.com/prototype.png" height="763" width="872" alt=""></p></li><li><p>案例： 08绘制图片.html</p></li><li>案例： 09绘制图片裁剪.html</li><li>案例： 10序列帧动画.html</li><li>案例： 11面向对象版本的动画帧.html  <strong>重点</strong></li></ul><h2 id="2-6-6-补充-sublime制作代码段（推荐–已结讲过了）"><a href="#2-6-6-补充-sublime制作代码段（推荐–已结讲过了）" class="headerlink" title="2.6.6 补充 sublime制作代码段（推荐–已结讲过了）"></a>2.6.6 补充 sublime制作代码段（推荐–已结讲过了）</h2><p>第一步：sublime菜单栏→ 工具 → 制作代码段 </p><p>第二步：修改输出的sublime代码段文本</p><pre><code>&lt;snippet&gt;    &lt;content&gt;&lt;![CDATA[1、这里放要tab键 输出的内容2、 ${1:this} 占位符，tab可以进行切换，数字是切换的索引。    ：后面的是默认的文本。]]&gt;&lt;/content&gt;    &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;    &lt;tabTrigger&gt;简写的字母&lt;/tabTrigger&gt;    &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;    &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt;</code></pre><p>第三步：保存到插件的文件夹中，后缀名为：.sublime-snippet<br>比如我存放的位置：<br> C:\Users\malunmac\AppData\Roaming\Sublime Text 3\Packages\User\snippets<br><strong>snippets是我自己新建的文件夹。</strong></p><hr><h1 id="三、-canvas进阶"><a href="#三、-canvas进阶" class="headerlink" title="三、 canvas进阶"></a>三、 canvas进阶</h1><h2 id="3-1-Canvas颜色样式和阴影"><a href="#3-1-Canvas颜色样式和阴影" class="headerlink" title="3.1 Canvas颜色样式和阴影"></a>3.1 Canvas颜色样式和阴影</h2><h3 id="3-1-1-设置填充和描边的颜色（掌握）"><a href="#3-1-1-设置填充和描边的颜色（掌握）" class="headerlink" title="3.1.1 设置填充和描边的颜色（掌握）"></a>3.1.1 设置填充和描边的颜色（掌握）</h3><ul><li>fillStyle  : 设置或返回用于填充绘画的颜色</li><li>strokeStyle: 设置或返回用于笔触的颜色</li></ul><p>以上两个值都可以接受颜色名,16进制数据，rgb值，甚至rgba.<br>一般先进行设置样式然后进行绘制。</p><pre><code>例如：ctx.strokeStyle = &quot;red&quot;;      ctx.strokeStyle = &quot;#ccc&quot;;      ctx.strokeStyle = &quot;rgb(255,0,0)&quot;;      ctx.strokeStyle = &quot;rgba(255,0,0,6)&quot;;    </code></pre><h3 id="3-1-2-设置阴影（了解，少用，性能差）"><a href="#3-1-2-设置阴影（了解，少用，性能差）" class="headerlink" title="3.1.2 设置阴影（了解，少用，性能差）"></a>3.1.2 设置阴影（了解，少用，性能差）</h3><ul><li>类比于CSS3的阴影。</li><li>shadowColor  ：   设置或返回用于阴影的颜色</li><li>shadowBlur   ：   设置或返回用于阴影的模糊级别,大于1的正整数，数值越高，模糊程度越大</li><li>shadowOffsetX：   设置或返回阴影距形状的水平距离</li><li>shadowOffsetY：   设置或返回阴影距形状的垂直距离</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle = &quot;rgba(255,0,0, .9)&quot;</span><br><span class="line">ctx.shadowColor = &quot;teal&quot;;</span><br><span class="line">ctx.shadowBlur = 10;</span><br><span class="line">ctx.shadowOffsetX = 10;</span><br><span class="line">ctx.shadowOffsetY = 10;</span><br><span class="line">ctx.fillRect(100, 100, 100, 100);</span><br></pre></td></tr></table></figure><p>例如：</p><ul><li><p>案例： 12设置box盒子阴影.html</p></li><li><p>设置png图片的阴影，图片透明部分不会被投影。</p></li></ul><h2 id="3-2-复杂样式（了解）"><a href="#3-2-复杂样式（了解）" class="headerlink" title="3.2 复杂样式（了解）"></a>3.2 复杂样式（了解）</h2><h3 id="3-2-1-创建线性渐变的样式（了解）"><a href="#3-2-1-创建线性渐变的样式（了解）" class="headerlink" title="3.2.1 创建线性渐变的样式（了解）"></a>3.2.1 创建线性渐变的样式（了解）</h3><ul><li>一般不用，都是用图片代替，canvas绘制图片效率更高。</li><li>线性渐变可以用于 矩形、圆形、文字等颜色样式</li><li>线性渐变是一个对象</li><li>语法：ctx.createLinearGradient(x0,y0,x1,y1); //参数：x0,y0起始坐标，x1,y1结束坐标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">//创建线性渐变的对象，</span><br><span class="line">var grd=ctx.createLinearGradient(0,0,170,0);</span><br><span class="line">grd.addColorStop(0,&quot;black&quot;);  //添加一个渐变颜色，第一个参数介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。</span><br><span class="line">grd.addColorStop(1,&quot;white&quot;);  //添加一个渐变颜色</span><br><span class="line">ctx.fillStyle =grd;           //关键点，把渐变设置到 填充的样式</span><br></pre></td></tr></table></figure></li></ul><p>案例13设置线性渐变.html</p><h3 id="3-2-2-设置圆形渐变（径向渐变）-了解"><a href="#3-2-2-设置圆形渐变（径向渐变）-了解" class="headerlink" title="3.2.2 设置圆形渐变（径向渐变） 了解"></a>3.2.2 设置圆形渐变（径向渐变） 了解</h3><ul><li>创建放射状/圆形渐变对象。可以填充文本、形状等</li><li>context.createRadialGradient(x0,y0,r0,x1,y1,r1);</li><li>radial   半径的；放射状的；光线的；光线状的   英 [‘reɪdɪəl]   美 [‘redɪəl]</li><li><p>参数详解：</p><ul><li>x0:  渐变的开始圆的 x 坐标</li><li>y0:  渐变的开始圆的 y 坐标</li><li>r0:  开始圆的半径</li><li>x1:  渐变的结束圆的 x 坐标</li><li>y1:  渐变的结束圆的 y 坐标</li><li>r1:  结束圆的半径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var rlg = ctx.createRadialGradient(300,300,10,300,300,200);</span><br><span class="line">rlg.addColorStop(0, &apos;teal&apos;);    //添加一个渐变颜色</span><br><span class="line">rlg.addColorStop(.4, &apos;navy&apos;);</span><br><span class="line">rlg.addColorStop(1, &apos;purple&apos;);</span><br><span class="line">ctx.fillStyle = rlg;//设置 填充样式为延续渐变的样式</span><br><span class="line">ctx.fillRect(100, 100, 500, 500);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>案例14圆形渐变.html</p></li></ul><h3 id="3-2-3-绘制背景图（了解）"><a href="#3-2-3-绘制背景图（了解）" class="headerlink" title="3.2.3 绘制背景图（了解）"></a>3.2.3 绘制背景图（了解）</h3><ul><li>ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解</li><li>pattern：n. 模式；图案；样品  英 [‘pæt(ə)n]   美 [‘pætɚn]</li><li><p>第一参数：设置平铺背景的图片，第二个背景平铺的方式。</p><ul><li>image    ：   规定要使用的图片、画布或视频元素。</li><li>repeat   ：   默认。该模式在水平和垂直方向重复。</li><li>repeat-x ：   该模式只在水平方向重复。</li><li>repeat-y ：   该模式只在垂直方向重复。</li><li>no-repeat：   该模式只显示一次（不重复）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ctx=c.getContext(&quot;2d&quot;);</span><br><span class="line">var img=document.getElementById(&quot;lamp&quot;);</span><br><span class="line">var pat=ctx.createPattern(img,&quot;repeat&quot;);</span><br><span class="line">ctx.rect(0,0,150,100);</span><br><span class="line">ctx.fillStyle=pat;//  把背景图设置给填充的样式</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>案例15背景图填充.html</p></li></ul><h2 id="3-3-变换（重点）"><a href="#3-3-变换（重点）" class="headerlink" title="3.3 变换（重点）"></a>3.3 变换（重点）</h2><h3 id="3-3-1-缩放（重点）"><a href="#3-3-1-缩放（重点）" class="headerlink" title="3.3.1 缩放（重点）"></a>3.3.1 缩放（重点）</h3><ul><li>scale() 方法缩放当前绘图，更大或更小</li><li>语法：context.scale(scalewidth,scaleheight)<ul><li>scalewidth  :  缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推)</li><li>scaleheight :  缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.)<br>+注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。</li></ul></li><li>案例16缩放案例.html</li></ul><h3 id="3-3-2-位移画布（重点）"><a href="#3-3-2-位移画布（重点）" class="headerlink" title="3.3.2 位移画布（重点）"></a>3.3.2 位移画布（重点）</h3><ul><li>ctx.translate(x,y) 方法重新映射画布上的 (0,0) 位置</li><li>参数说明：<ul><li>x：   添加到水平坐标（x）上的值</li><li>y：   添加到垂直坐标（y）上的值</li></ul></li><li>发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。</li><li><p>位移画布一般配合缩放和旋转等。</p></li><li><p>案例： 17位移画布.html</p></li></ul><h3 id="3-3-3-旋转（重点）"><a href="#3-3-3-旋转（重点）" class="headerlink" title="3.3.3 旋转（重点）"></a>3.3.3 旋转（重点）</h3><ul><li>context.rotate(angle); 方法旋转当前的绘图</li><li>注意参数是弧度（PI）</li><li><p>如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。</p></li><li><p>案例：18旋转画布.html</p></li></ul><h2 id="3-3-绘制环境保存和还原（重要）"><a href="#3-3-绘制环境保存和还原（重要）" class="headerlink" title="3.3 绘制环境保存和还原（重要）"></a>3.3 绘制环境保存和还原（重要）</h2><ul><li>ctx.save()  保存当前环境的状态<ul><li>可以把当前绘制环境进行保存到缓存中。</li></ul></li><li>ctx.restore()   返回之前保存过的路径状态和属性<ul><li>获取最近缓存的ctx</li></ul></li><li>一般配合位移画布使用。</li><li>案例： 19矩形旋转案例.html</li></ul><h2 id="3-4-设置绘制环境的透明度（了解）"><a href="#3-4-设置绘制环境的透明度（了解）" class="headerlink" title="3.4 设置绘制环境的透明度（了解）"></a>3.4 设置绘制环境的透明度（了解）</h2><ul><li>context.globalAlpha=number;</li><li>number:透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。</li><li>设置透明度是全局的透明度的样式。注意是全局的。</li></ul><h2 id="3-5-画布限定区域绘制（了解）"><a href="#3-5-画布限定区域绘制（了解）" class="headerlink" title="3.5 画布限定区域绘制（了解）"></a>3.5 画布限定区域绘制（了解）</h2><ul><li>ctx.clip(); 方法从原始画布中剪切任意形状和尺寸</li><li>一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）</li><li>一般配合绘制环境的保存和还原。</li></ul><h2 id="3-6-画布保存base64编码内容（重要）"><a href="#3-6-画布保存base64编码内容（重要）" class="headerlink" title="3.6 画布保存base64编码内容（重要）"></a>3.6 画布保存base64编码内容（重要）</h2><ul><li>把canvas绘制的内容输出成base64内容。 </li><li>语法：canvas.toDataURL(type, encoderOptions);</li><li>例如：canvas.toDataURL(“image/jpg”,1);</li><li>参数说明：<ul><li>type，设置输出的类型，比如 image/png   image/jpeg等</li><li>encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩，类型为： image/jpeg 或者image/webp才起作用。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">案例1：</span><br><span class="line">var canvas = document.getElementById(&quot;canvas&quot;);</span><br><span class="line">var dataURL = canvas.toDataURL();</span><br><span class="line">console.log(dataURL);</span><br><span class="line">// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby</span><br><span class="line">// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;</span><br><span class="line"></span><br><span class="line">var img = document.querySelector(&quot;#img-demo&quot;);//拿到图片的dom对象</span><br><span class="line">img.src = canvas.toDataURL(&quot;image/png&quot;);      //将画布的内容给图片标签显示</span><br></pre></td></tr></table></figure><h2 id="3-7-画布渲染画布（重要）"><a href="#3-7-画布渲染画布（重要）" class="headerlink" title="3.7 画布渲染画布（重要）"></a>3.7 画布渲染画布（重要）</h2><ul><li>context.drawImage(img,x,y);</li><li>img参数也可以是画布，也就是把一个画布整体的渲染到另外一个画布上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var canvas1 = document.querySelector(&apos;#cavsElem1&apos;);</span><br><span class="line">var canvas2 = document.querySelector(&apos;#cavsElem2&apos;);</span><br><span class="line">var ctx1 = canvas1.getContext(&apos;2d&apos;);</span><br><span class="line">var ctx2 = canvas2.getContext(&apos;2d&apos;);</span><br><span class="line">ctx1.fillRect(20, 20, 40, 40);      //在第一个画布上绘制矩形</span><br><span class="line"></span><br><span class="line">ctx2.drawImage(canvas1, 10, 10);    //将第一个画布整体绘制到第二个画布上</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-8-了解：线条样式（了解）"><a href="#3-8-了解：线条样式（了解）" class="headerlink" title="3.8 了解：线条样式（了解）"></a>3.8 了解：线条样式（了解）</h2><ul><li>lineCap     设置或返回线条的结束端点(线头、线冒)样式<ul><li>butt  ：  默认。向线条的每个末端添加平直的边缘。<ul><li>翻译.：屁股；烟头；笑柄；靶垛；粗大的一端  英 [bʌt]   美 [bʌt]</li></ul></li><li>round ：  向线条的每个末端添加圆形线帽。</li><li>square：  向线条的每个末端添加正方形线帽。<br><img src="http://p7u359del.bkt.clouddn.com/linecap.png" height="303" width="480"><br>参考：23线的样式.html</li></ul></li><li><p>lineJoin    设置或返回两条线相交时，所创建的拐角类型</p><ul><li>bevel:   创建斜角。<ul><li>翻译. 斜角；斜面；[测] 斜角规  英 [‘bev(ə)l]   美 [‘bɛvl]</li></ul></li><li>round:   创建圆角。</li><li>miter:   默认。创建尖角<br><img src="http://p7u359del.bkt.clouddn.com/linejoin.png" height="387" width="453" alt=""></li></ul></li><li><p>lineWidth   设置或返回当前的线条宽度</p></li><li>miterLimit  设置或返回最大斜接长度<ul><li>意思:  斜接 英 [‘maɪtə]  </li><li>斜接长度指的是在两条线交汇处内角和外角之间的距离。</li><li>一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。<br><img src="http://p7u359del.bkt.clouddn.com/miterlimit.gif" height="410" width="840" alt=""></li></ul></li></ul><h2 id="3-9-了解贝塞尔曲线（知道有）"><a href="#3-9-了解贝塞尔曲线（知道有）" class="headerlink" title="3.9 了解贝塞尔曲线（知道有）"></a>3.9 了解贝塞尔曲线（知道有）</h2><h3 id="3-9-1-绘制一条二次方曲线。"><a href="#3-9-1-绘制一条二次方曲线。" class="headerlink" title="3.9.1 绘制一条二次方曲线。"></a>3.9.1 绘制一条二次方曲线。</h3><ul><li>微软的画图板中的曲线的颜色。</li><li>quadratic：二次方的意思， 英 [kwɒ’drætɪk]   美 [kwɑ’drætɪk]</li><li>Curve：曲线的意思， 英 [kɜːv]   美 [kɝv]</li><li>语法： context.quadraticCurveTo(cpx,cpy,x,y);</li><li>参数：<ul><li>cpx：   贝塞尔控制点的 x 坐标</li><li>cpy：   贝塞尔控制点的 y 坐标</li><li>x  ：   结束点的 x 坐标</li><li>y  ：   结束点的 y 坐标<br><img src="http://p7u359del.bkt.clouddn.com/quadraticcurve.gif" height="140" width="258" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(20,20);</span><br><span class="line">//绘制2次方曲线，贝赛尔曲线</span><br><span class="line">ctx.quadraticCurveTo(20,100,200,20);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-9-2-绘制贝塞尔曲线（知道有）"><a href="#3-9-2-绘制贝塞尔曲线（知道有）" class="headerlink" title="3.9.2 绘制贝塞尔曲线（知道有）"></a>3.9.2 绘制贝塞尔曲线（知道有）</h3><ul><li>绘制一条三次贝塞尔曲线</li><li>语法：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);</li><li>提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。</li><li><p>参数说明：</p><ul><li>cp1x：    第一个贝塞尔控制点的 x 坐标</li><li>cp1y：    第一个贝塞尔控制点的 y 坐标</li><li>cp2x：    第二个贝塞尔控制点的 x 坐标</li><li>cp2y：    第二个贝塞尔控制点的 y 坐标</li><li>x:        结束点的 x 坐标</li><li>y:        结束点的 y 坐标   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//绘制复杂的贝塞尔曲线</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(400,400);</span><br><span class="line">//参数说明：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);</span><br><span class="line">// cp1x： 第一个贝塞尔控制点的 x 坐标</span><br><span class="line">// cp1y： 第一个贝塞尔控制点的 y 坐标</span><br><span class="line">// cp2x： 第二个贝塞尔控制点的 x 坐标</span><br><span class="line">// cp2y： 第二个贝塞尔控制点的 y 坐标</span><br><span class="line">// x: 结束点的 x 坐标</span><br><span class="line">// y: 结束点的 y 坐标</span><br><span class="line">ctx.bezierCurveTo(500, 200, 600, 600, 700, 300);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>案例：25绘制贝塞尔曲线.html<br><img src="http://p7u359del.bkt.clouddn.com/beziercurve.gif" height="166" width="290" alt=""></p></li></ul><h2 id="3-10了解创建两条切线的弧（知道有）"><a href="#3-10了解创建两条切线的弧（知道有）" class="headerlink" title="3.10了解创建两条切线的弧（知道有）"></a>3.10了解创建两条切线的弧（知道有）</h2><ul><li>在画布上创建介于当前起点和两个点形成的夹角的切线之间的弧</li><li>语法： context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。</li><li>例如： ctx.arcTo(240, 100, 240, 110, 40);</li><li>参数：<ul><li>x1:  弧的端点1的 x 坐标</li><li>y1:  弧的端点1的 y 坐标</li><li>x2:  弧的端点2(终点)的 x 坐标</li><li>y2:  弧的端点2(终点)的 y 坐标</li><li>r :  弧的半径   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//代码demo：</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.moveTo(100,100);</span><br><span class="line">ctx.lineTo(200,100);</span><br><span class="line">//context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。</span><br><span class="line">ctx.arcTo(240, 100, 240, 110, 40);</span><br><span class="line">ctx.lineTo(240, 300);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="http://p7u359del.bkt.clouddn.com/canvas-arcto-1.png" height="311" width="427" alt=""></p><h2 id="3-11了解判断点是否在路径中（知道有）"><a href="#3-11了解判断点是否在路径中（知道有）" class="headerlink" title="3.11了解判断点是否在路径中（知道有）"></a>3.11了解判断点是否在路径中（知道有）</h2><pre><code>context.isPointInPath(x,y);//isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。//判断x,y坐标的点是否在当前的路径中。</code></pre><h2 id="3-12了解文本宽度计算（知道有）"><a href="#3-12了解文本宽度计算（知道有）" class="headerlink" title="3.12了解文本宽度计算（知道有）"></a>3.12了解文本宽度计算（知道有）</h2><pre><code>context.measureText(text).width;</code></pre><h2 id="3-13-如果以后做canvas游戏方向开发深入学习可以扩展内以下容："><a href="#3-13-如果以后做canvas游戏方向开发深入学习可以扩展内以下容：" class="headerlink" title="3.13 如果以后做canvas游戏方向开发深入学习可以扩展内以下容："></a>3.13 如果以后做canvas游戏方向开发深入学习可以扩展内以下容：</h2><ul><li>setTransform()  将当前转换重置为单位矩阵。然后运行 transform()</li><li>transform() 替换绘图的当前转换矩阵</li><li>globalCompositeOperation    设置或返回新图像如何绘制到已有的图像上</li><li>像素操作</li></ul><h1 id="四、-Canvas开发库封装"><a href="#四、-Canvas开发库封装" class="headerlink" title="四、 Canvas开发库封装"></a>四、 Canvas开发库封装</h1><h2 id="4-1封装常用的绘制函数"><a href="#4-1封装常用的绘制函数" class="headerlink" title="4.1封装常用的绘制函数"></a>4.1封装常用的绘制函数</h2><h3 id="4-1-1封装一个矩形"><a href="#4-1-1封装一个矩形" class="headerlink" title="4.1.1封装一个矩形"></a>4.1.1封装一个矩形</h3><pre><code>//思考：我们用到的矩形需要哪些绘制的东西呢？1、矩形的 x、y坐标2、矩形的宽高3、矩形的边框的线条样式、线条宽度4、矩形填充的样式5、矩形的旋转角度6、矩形的缩小放大//下面是把上面所有的功能进行封装的代码：function ItcastRect( option ) {//矩形构造函数    this._init(option);}ItcastRect.prototype = {  //矩形的原型对象    _init: function( option ) {  //初始化方法        option = option || {};        this.x = option.x === 0 ? 0 : option.x || 100;        this.y = option.y === 0 ? 0 : option.y || 100;        this.w = option.w || 100;        this.h = option.h || 100;        this.angle = option.angle === 0 ? 0 : option.angle || 0;        this.fillStyle = option.fillStyle || &apos;silver&apos;;        this.strokeStyle = option.strokeStyle || &apos;red&apos;;        this.strokeWidth = option.strokeWidth || 4;        this.scaleX = option.scaleX || 1;        this.scaleY = option.Y || 1;    },    render: function( ctx ) {//把矩形渲染到canvas中        ctx.save();        ctx.translate( this.x, this.y );//位移画布        ctx.rotate( this.angle * Math.PI / 180 );//旋转角度        ctx.scale( this.scaleX, this.scaleY );//缩放        ctx.fillStyle = this.fillStyle;        ctx.fillRect( 0, 0, this.w, this.h ); //填充矩形        ctx.lineWidth = this.strokeWidth;     //线宽        ctx.strokeStyle = this.strokeStyle;   //填充样式        ctx.strokeRect( 0,0,this.w,this.h );  //描边样式        ctx.restore();    },    constructor: ItcastRect};</code></pre><ul><li>4.1.2作业：尝试着封装一个圆形？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//封装圆形的代码的答案：不要偷看</span><br><span class="line">function ItcastCircle( option ) &#123;</span><br><span class="line">    this._init( option );</span><br><span class="line">&#125;</span><br><span class="line">ItcastCircle.prototype = &#123;</span><br><span class="line">    _init: function( option ) &#123;</span><br><span class="line">        option = option || &#123;&#125;;</span><br><span class="line">        this.x = option.x === 0 ? 0 : option.x || 100;</span><br><span class="line">        this.y = option.y === 0 ? 0 : option.y || 100;</span><br><span class="line">        this.w = option.w || 100;</span><br><span class="line">        this.h = option.h || 100;</span><br><span class="line">        this.angle = option.angle === 0 ? 0 : option.angle || 0;</span><br><span class="line">        this.fillStyle = option.fillStyle || &apos;silver&apos;;</span><br><span class="line">        this.strokeStyle = option.strokeStyle || &apos;red&apos;;</span><br><span class="line">        this.strokeWidth = option.strokeWidth || 4;</span><br><span class="line">        this.scaleX = option.scaleX || 1;</span><br><span class="line">        this.scaleY = option.Y || 1;</span><br><span class="line">        this.opactity = option.opactity || 1;</span><br><span class="line">        this.counterclockwise = </span><br><span class="line">            option.counterclockwise === true ? true : option.counterclockwise || false;</span><br><span class="line">        this.startAngle = option.startAngle == 0 ? 0 : option.startAngle || 0;</span><br><span class="line">        this.endAngle = option.endAngle == 0 ? 0 : option.endAngle || 0;</span><br><span class="line">        this.startAngle = this.startAngle * Math.PI/180;</span><br><span class="line">        this.endAngle = this.endAngle * Math.PI / 180;</span><br><span class="line">        this.r = option.r || 100;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: function( ctx ) &#123;</span><br><span class="line">        ctx.save();</span><br><span class="line">        ctx.translate( this.x, this.y);</span><br><span class="line">        ctx.scale( this.scaleX, this.scaleY );</span><br><span class="line">        ctx.rotate( this.agnle * Math.PI / 180 );</span><br><span class="line">        ctx.globalAlpha = this.opacity;</span><br><span class="line">        ctx.fillStyle = this.fillStyle;</span><br><span class="line">        ctx.strokeStyle = this.strokeStyle;</span><br><span class="line">        ctx.moveTo(0, 0);</span><br><span class="line">        ctx.arc( 0, 0, this.r, this.startAngle, this.endAngle, this.counterclockwise);</span><br><span class="line">        ctx.fill();</span><br><span class="line">        ctx.stroke();</span><br><span class="line">        ctx.restore();</span><br><span class="line">    &#125;,</span><br><span class="line">    constructor: ItcastCircle</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-第三方库使用"><a href="#4-2-第三方库使用" class="headerlink" title="4.2 第三方库使用"></a>4.2 第三方库使用</h2><ul><li><p>Rgraph vs 百度的echart</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/</span><br></pre></td></tr></table></figure></li><li><p>国产的egret引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.egret-labs.org/</span><br></pre></td></tr></table></figure></li><li><p>比较火的3d引擎：treejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://threejs.org/</span><br></pre></td></tr></table></figure></li><li><p>Konva</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">官网：http://konvajs.github.io/</span><br><span class="line">    特点：</span><br><span class="line">     * 小巧、使用方便、适合移动端和pc端</span><br><span class="line">     * 支持丰富的事件处理操作</span><br><span class="line">     * 支持类似JQuery的操作方式（顺带能复习jQueyr）</span><br><span class="line">     * 开源，可以随意更改</span><br><span class="line">     * 社区更新比较活跃，github托管源码</span><br><span class="line">     * 性能也不错</span><br></pre></td></tr></table></figure></li><li><p>其他的还有很多，希望以后能用到你们的库。</p></li></ul><h1 id="五、Konva的使用快速上手"><a href="#五、Konva的使用快速上手" class="headerlink" title="五、Konva的使用快速上手"></a>五、Konva的使用快速上手</h1><h2 id="5-1-Konva的整体理念"><a href="#5-1-Konva的整体理念" class="headerlink" title="5.1 Konva的整体理念"></a>5.1 Konva的整体理念</h2><ul><li>舞台的概念的引入。整个视图看做是一个舞台 stage</li><li>舞台中可以绘制很多个层 layer</li><li>layer下面可以有很多的group</li><li>group下面可以有 矩形、图片、其他形状等</li><li>参看：快速上手文档—查看翻译文档<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">              Stage</span><br><span class="line">                |</span><br><span class="line">         +------+------+</span><br><span class="line">         |             |</span><br><span class="line">       Layer         Layer</span><br><span class="line">         |             |</span><br><span class="line">   +-----+-----+     Shape</span><br><span class="line">   |           |</span><br><span class="line"> Group       Group</span><br><span class="line">   |           |</span><br><span class="line">   +       +---+---+</span><br><span class="line">   |       |       |</span><br><span class="line">Shape   Group    Shape</span><br><span class="line">           |</span><br><span class="line">           +</span><br><span class="line">           |</span><br><span class="line">         Shape</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2-Konva矩形案例"><a href="#5-2-Konva矩形案例" class="headerlink" title="5.2 Konva矩形案例"></a>5.2 Konva矩形案例</h2><h3 id="5-2-1-创建一个矩形：-Konva-Rect-option"><a href="#5-2-1-创建一个矩形：-Konva-Rect-option" class="headerlink" title="5.2.1 创建一个矩形： Konva.Rect(option);"></a>5.2.1 创建一个矩形： Konva.Rect(option);</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//Konva使用的基本案例</span><br><span class="line">//第一步：创建舞台</span><br><span class="line">var stage = new Konva.Stage(&#123;</span><br><span class="line">    container: &apos;container&apos;,     //需要存放舞台的Dom容器</span><br><span class="line">    width: window.innerWidth,   //设置全屏</span><br><span class="line">    height: window.innerHeight</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//第二步：创建层</span><br><span class="line">var layer = new Konva.Layer();  //创建一个层</span><br><span class="line">stage.add(layer);               //把层添加到舞台</span><br><span class="line"></span><br><span class="line">//第三步： 创建矩形</span><br><span class="line">var rect = new Konva.Rect(&#123;     //创建一个矩形</span><br><span class="line">    x: 100,                     //矩形的x坐标，相对其父容器的坐标</span><br><span class="line">    y: 100,                      </span><br><span class="line">    width: 100,                 //矩形的宽度</span><br><span class="line">    height: 100,                //矩形高度</span><br><span class="line">    fill: &apos;gold&apos;,               //矩形填充的颜色</span><br><span class="line">    stroke: &apos;navy&apos;,             //矩形描边的颜色</span><br><span class="line">    strokeWidth: 4,             //填充宽度</span><br><span class="line">    opactity: .2,               //矩形的透明度</span><br><span class="line">    scale: 1.2,                 //矩形的缩放 1：原来大小</span><br><span class="line">    rotation: 30,               //旋转的角度，是deg不是弧度。</span><br><span class="line">    cornerRadius: 10,           //圆角的大小（像素） </span><br><span class="line">    id: &apos;rect1&apos;,                //id属性，类似dom的id属性</span><br><span class="line">    name: &apos;rect&apos;,</span><br><span class="line">    draggable: true             //是否可以进行拖拽</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//创建一个组</span><br><span class="line">var group = new Konva.Group(&#123;</span><br><span class="line">    x: 40,      </span><br><span class="line">    y: 40,</span><br><span class="line">&#125;);</span><br><span class="line">group.add( rect );  //把矩形添加到组中</span><br><span class="line"></span><br><span class="line">//第四步： 把形状放到层中</span><br><span class="line">layer.add( group ); //把组添加到层中</span><br><span class="line">layer.draw();       //绘制层到舞台上</span><br></pre></td></tr></table></figure><h2 id="5-3-Konva的动画系统"><a href="#5-3-Konva的动画系统" class="headerlink" title="5.3 Konva的动画系统"></a>5.3 Konva的动画系统</h2><h3 id="5-3-1-tween对象-重点"><a href="#5-3-1-tween对象-重点" class="headerlink" title="5.3.1 tween对象(重点)"></a>5.3.1 tween对象(重点)</h3><ul><li>tween，英文意思：两者之间， 英 [twiːn]   美 [twin]</li><li>tween是控制Konva对象进行动画的核心对象。</li><li><p>tween可以控制所有数字类型的属性进行动画处理，比如：x, y, rotation,<br>width, height, radius, strokeWidth, opacity, scaleX等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//案例：</span><br><span class="line">var tween = new Konva.Tween(&#123;</span><br><span class="line">    node: rect,             //要进行动画的Konva对象</span><br><span class="line">    x: 300,                 //要进行动画的属性</span><br><span class="line">    opacity: .8,            </span><br><span class="line">    duration: 1,            //持续时间</span><br><span class="line">    easing: Konva.Easings.EaseIn, //动画的动画效果</span><br><span class="line">    yoyo: true,             //是否进行循环播放的设置</span><br><span class="line">    onFinish: function() &#123;</span><br><span class="line">        //动画执行结束后，执行此方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">tween.play();   //启动动画</span><br></pre></td></tr></table></figure></li><li><p>tween的控制方法</p><ul><li>tween.play(),     //播放动画</li><li>tween.pause(),    //暂停动画</li><li>tween.reverse(),  //动画逆播放</li><li>tween.reset(),    //重置动画</li><li>tween.finish(),   //立即结束动画</li><li>seek：英文：寻找 英 [siːk]   美 [sik]</li></ul></li><li><p>tween的缓动控制选项</p><ul><li>Konva.Easings.Linear            //线性</li><li>Konva.Easings.EaseIn            //缓动，先慢后快</li><li>Konva.Easings.EaseOut //先快后慢</li><li>Konva.Easings.EaseInOut //两头慢，中间快</li><li>Konva.Easings.BackEaseIn //往回来一点，然后往前冲，汽车启动类似…</li><li>Konva.Easings.BackEaseOut</li><li>Konva.Easings.BackEaseInOut </li><li>Konva.Easings.ElasticEaseIn  //橡皮筋 英 [ɪ’læstɪk]   美 [ɪ’læstɪk] </li><li>Konva.Easings.ElasticEaseOut </li><li>Konva.Easings.ElasticEaseInOut </li><li>Konva.Easings.BounceEaseIn   //弹跳；弹起，反跳；弹回  英 [baʊns]   美 [baʊns]</li><li>Konva.Easings.BounceEaseOut </li><li>Konva.Easings.BounceEaseInOut </li><li>Konva.Easings.StrongEaseIn //强力</li><li>Konva.Easings.StrongEaseOut </li><li>Konva.Easings.StrongEaseInOut </li></ul></li><li><p>动画效果参考： 29Konva动画缓动效果案例.html</p></li></ul><h3 id="5-3-2-动画to的使用"><a href="#5-3-2-动画to的使用" class="headerlink" title="5.3.2 动画to的使用"></a>5.3.2 动画to的使用</h3><ul><li>to就是对tween的封装，比较简单好用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//案例：</span><br><span class="line">var rect = new Konva.Rect(&#123;</span><br><span class="line">    x: 10,</span><br><span class="line">    y: 10,</span><br><span class="line">    width: 100,</span><br><span class="line">    height: 100,</span><br><span class="line">    fill: &apos;red&apos;</span><br><span class="line">&#125;);</span><br><span class="line">layer.add(rect);</span><br><span class="line">layer.draw();</span><br><span class="line"></span><br><span class="line">//动画系统</span><br><span class="line">rect.to(&#123;</span><br><span class="line">    x: 100,</span><br><span class="line">    y: 100,</span><br><span class="line">    opactity: .1,</span><br><span class="line">    duration: 3,</span><br><span class="line">    onFinish: function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//to: 就是对tween的简单应用。</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-3-Animate的应用"><a href="#5-3-3-Animate的应用" class="headerlink" title="5.3.3 Animate的应用"></a>5.3.3 Animate的应用</h3><ul><li>Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var anim = new Konva.Animation(function(frame) &#123;</span><br><span class="line">    //动画系统提供的frame有三个属性可以使用：</span><br><span class="line">    var time = frame.time, // 动画执行的总时间</span><br><span class="line">        timeDiff = frame.timeDiff, // 距离上一帧的时间</span><br><span class="line">        frameRate = frame.frameRate; // 帧率（既1000/间隔时间）</span><br><span class="line">   </span><br><span class="line">   //动画的动作</span><br><span class="line"></span><br><span class="line">&#125;, layer);</span><br><span class="line"></span><br><span class="line">anim.start();//启动动画</span><br><span class="line"></span><br><span class="line">//anim.stop();//结束动画</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-4-循环播放动画的实现"><a href="#5-3-4-循环播放动画的实现" class="headerlink" title="5.3.4 循环播放动画的实现"></a>5.3.4 循环播放动画的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//总体思路，使用tween 配合onFinish事件中重新播放动画，达到循环播放的效果</span><br><span class="line">var loopTween = new Konva.Tween(&#123;</span><br><span class="line">    node: star, //设置要表现动画的 Konva对象</span><br><span class="line">    rotation: 360,  //旋转360度</span><br><span class="line">    duration: 2,    //动画持续时间</span><br><span class="line">    easing: Konva.Easings.Linear,</span><br><span class="line">    onFinish: function() &#123;</span><br><span class="line">        // this === loopTween //true</span><br><span class="line">        this.reset();//重置动画</span><br><span class="line">        this.play(); //重新播放动画</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">loopTween.play();</span><br></pre></td></tr></table></figure><h3 id="5-3-5-回放且循环播放动画"><a href="#5-3-5-回放且循环播放动画" class="headerlink" title="5.3.5 回放且循环播放动画"></a>5.3.5 回放且循环播放动画</h3><ul><li>yoyo属性可以进行对动画进行播放完后，回放当前动画，并持续循环来回切换播放。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rect.to(&#123;</span><br><span class="line">    duration: 2,</span><br><span class="line">    scale: 1.5,</span><br><span class="line">    yoyo: true// 此设置也可以用于 tween</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-3-6-进度条案例"><a href="#5-3-6-进度条案例" class="headerlink" title="5.3.6 进度条案例"></a>5.3.6 进度条案例</h3><h3 id="5-3-7-传智官网案例"><a href="#5-3-7-传智官网案例" class="headerlink" title="5.3.7 传智官网案例"></a>5.3.7 传智官网案例</h3><ul><li>三角函数的补充<ul><li>Math.sin(弧度); //夹角对面的边 和 斜边的比值</li><li>Math.cos(弧度); //夹角侧边 与斜边的比值</li></ul></li><li><p>圆形上面的点的坐标的计算公式</p><ul><li>x =x0 + Math.cos(rad) * R;//x0和y0是圆心点坐标</li><li>y =y0 + Math.sin(rad) * R;//注意都是弧度<br><img src="http://p7u359del.bkt.clouddn.com/%E5%9C%86%E5%BD%A2%E7%82%B9%E7%9A%84%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" height="581" width="830" alt=""></li></ul></li><li><p>group的灵活运用</p><ul><li>konva的group很灵活，每个group都有自己的坐标系</li><li>group可以包含其他的group，可以对group做整个组的动画</li><li>group可以通过getChidren();//可以拿到直接子级元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var group = new Konva.Group(&#123;</span><br><span class="line">    x: 0,</span><br><span class="line">    y: 0</span><br><span class="line">&#125;);</span><br><span class="line">group.add(rect);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-4-Konva的事件（重要）"><a href="#5-4-Konva的事件（重要）" class="headerlink" title="5.4 Konva的事件（重要）"></a>5.4 Konva的事件（重要）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var rect = new Konva.Rect(&#123;</span><br><span class="line">    x: 100,</span><br><span class="line">    y: 100,</span><br><span class="line">    fill: &apos;red&apos;,</span><br><span class="line">    width: 200,</span><br><span class="line">    height: 200</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//绑定事件 Konva支持事件：mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, mousewheel, click, dblclick, dragstart, dragmove, and dragend</span><br><span class="line"></span><br><span class="line">rect.on(&apos;click&apos;, function()&#123;   //jQuery一模一样！！</span><br><span class="line">    console.log(&apos;^_^  ^_^&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//绑定多个事件</span><br><span class="line">rect.on(&apos;click mousemove&apos;,function(e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//解除绑定事件</span><br><span class="line">rect.off(&apos;click&apos;);             //这不是jQuery吗？</span><br><span class="line"></span><br><span class="line">//触发事件</span><br><span class="line">rect.fire(&apos;click&apos;);</span><br><span class="line"></span><br><span class="line">//取消事件冒泡</span><br><span class="line">rect.on(&apos;click&apos;, function(evt) &#123;</span><br><span class="line">  alert(&apos;You clicked the circle!&apos;);</span><br><span class="line">  evt.cancelBubble = true;      //取消事件冒泡</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="5-5-Konva的选择器"><a href="#5-5-Konva的选择器" class="headerlink" title="5.5 Konva的选择器"></a>5.5 Konva的选择器</h2><ul><li>选择方法。<ul><li>ID选择法：stage.find(‘#id’); //此方法返回的是一个数组</li><li>name选择法：group.findOne(‘.name’);//返回一个Konva对象</li><li>type选择法： group.find(‘Circle’);//查找所有的圆形Konva对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//组中查找圆形的Konva对象</span><br><span class="line">groupCircle.find(&apos;Circle&apos;).each(function( circle, index )&#123;</span><br><span class="line">    circle.setZIndex( 3 - index );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-6-饼状图案例"><a href="#5-6-饼状图案例" class="headerlink" title="5.6 饼状图案例"></a>5.6 饼状图案例</h3><ul><li>wedge: 楔形</li></ul><h3 id="5-7-柱状图案例"><a href="#5-7-柱状图案例" class="headerlink" title="5.7 柱状图案例"></a>5.7 柱状图案例</h3><ul><li>histogram n. [统计] 直方图；柱状图  英 [‘hɪstəgræm]   美 [‘hɪstəɡræm]</li></ul><h1 id="六、Canvas项目实战"><a href="#六、Canvas项目实战" class="headerlink" title="六、Canvas项目实战"></a>六、Canvas项目实战</h1><h1 id="七、Canvas优化"><a href="#七、Canvas优化" class="headerlink" title="七、Canvas优化"></a>七、Canvas优化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- requestAnim shim layer by Paul Irish --&gt;</span><br><span class="line">    window.requestAnimFrame = (function()&#123;</span><br><span class="line">      return  window.requestAnimationFrame       || </span><br><span class="line">              window.webkitRequestAnimationFrame || </span><br><span class="line">              window.mozRequestAnimationFrame    || </span><br><span class="line">              window.oRequestAnimationFrame      || </span><br><span class="line">              window.msRequestAnimationFrame     || </span><br><span class="line">              function(/* function */ callback, /* DOMElement */ element)&#123;</span><br><span class="line">                window.setTimeout(callback, 1000 / 60);</span><br><span class="line">              &#125;;</span><br><span class="line">    &#125;)();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">// example code from mr doob : http://mrdoob.com/lab/javascript/requestanimationframe/</span><br><span class="line"></span><br><span class="line">var canvas, context, toggle;</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">animate();</span><br><span class="line"></span><br><span class="line">function init() &#123;</span><br><span class="line"></span><br><span class="line">    canvas = document.createElement( &apos;canvas&apos; );</span><br><span class="line">    canvas.width = 512;</span><br><span class="line">    canvas.height = 512;</span><br><span class="line"></span><br><span class="line">    context = canvas.getContext( &apos;2d&apos; );</span><br><span class="line"></span><br><span class="line">    document.body.appendChild( canvas );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function animate() &#123;</span><br><span class="line">    requestAnimFrame( animate );</span><br><span class="line">    draw();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function draw() &#123;</span><br><span class="line"></span><br><span class="line">    var time = new Date().getTime() * 0.002;</span><br><span class="line">    var x = Math.sin( time ) * 192 + 256;</span><br><span class="line">    var y = Math.cos( time * 0.9 ) * 192 + 256;</span><br><span class="line">    toggle = !toggle;</span><br><span class="line"></span><br><span class="line">    context.fillStyle = toggle ? &apos;rgb(200,200,20)&apos; :  &apos;rgb(20,20,200)&apos;;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc( x, y, 10, 0, Math.PI * 2, true );</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、canvas简介&quot;&gt;&lt;a href=&quot;#一、canvas简介&quot; class=&quot;headerlink&quot; title=&quot;一、canvas简介&quot;&gt;&lt;/a&gt;一、canvas简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是canvas？&quot;&gt;&lt;a href=&quot;#1-1-什么是
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="canvas" scheme="http://www.wangbin26.com/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6的let和const命令</title>
    <link href="http://www.wangbin26.com/2016/06/05/ECMAScript6%E7%9A%84let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.wangbin26.com/2016/06/05/ECMAScript6的let和const命令/</id>
    <published>2016-06-05T12:43:11.000Z</published>
    <updated>2018-04-27T07:54:26.289Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="1-let-命令"><a href="#1-let-命令" class="headerlink" title="1.let 命令"></a>1.let 命令</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br>undefined</p><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p><p>for循环的计数器，就很合适使用let命令。<br>undefined</p><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p><p>下面的代码如果使用var，最后输出的是10。<br>undefined</p><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p><p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。<br>undefined</p><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br>undefined</p><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p><h2 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h2><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p><p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。<br>undefined</p><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。<br>undefined</p><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。<br>undefined</p><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p><p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。<br>undefined</p><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p><p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p><p><code>typeof undeclared_variable // &quot;undefined&quot;</code><br>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><p>有些“死区”比较隐蔽，不太容易发现。<br>undefined</p><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。<br>undefined</p><p>另外，下面的代码也会报错，与var的行为不同。<br>undefined</p><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p><p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h2 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h2><p>let不允许在相同作用域内，重复声明同一个变量。<br>undefined</p><p>因此，不能在函数内部重新声明参数。</p><p>function func(arg) {<br>  let arg; // 报错<br>}</p><p>function func(arg) {<br>  {<br>    let arg; // 不报错<br>  }<br>}</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p><p>第一种场景，内层变量可能会覆盖外层变量。<br>undefined</p><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量。<br>undefined</p><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p><h2 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h2><p>let实际上为 JavaScript 新增了块级作用域。<br>undefined</p><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p><p>ES6 允许块级作用域的任意嵌套。<br>undefined</p><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。<br>undefined</p><p>内层作用域可以定义外层作用域的同名变量。<br>undefined</p><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。<br>undefined</p><h2 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h2><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。<br>undefined</p><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。<br>undefined</p><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。<br>undefined</p><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p><p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p><p>允许在块级作用域内声明函数。<br>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。<br>同时，函数声明还会提升到所在的块级作用域的头部。<br>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p><p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。<br>undefined</p><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。<br>undefined</p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br>undefined</p><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。<br>undefined</p><h1 id="2-const-命令"><a href="#2-const-命令" class="headerlink" title="2.const 命令"></a>2.const 命令</h1><h2 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h2><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>undefined<p>上面代码表明改变常量的值会报错。</p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br>undefined</p><p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p><p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。<br>undefined</p><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。<br>undefined</p><p>上面代码在常量MAX声明之前就调用，结果报错。</p><p>const声明的常量，也与let一样不可重复声明。<br>undefined</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>undefined<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p><p>下面是另一个例子。<br>undefined</p><p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p><p>如果真的想将对象冻结，应该使用Object.freeze方法。<br>undefined</p><p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。<br>undefined</p><h2 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h2><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p><p>顶层对象的属性<br>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。<br>undefined</p><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。<br>undefined</p><p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p><h2 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h2><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p><p>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。<br>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。<br>Node 里面，顶层对象是global，但其他环境都不支持。<br>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p><p>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。<br>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。<br>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。<br>undefined</p><p>现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p><p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。<br>undefined</p><p>上面代码可以保证各种环境里面，global对象都是存在的。<br>undefined</p><p>上面代码将顶层对象放入变量global。</p><footer><strong>阮一峰</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">ECMAScript 6 入门</a></cite></footer></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;h1 id=&quot;1-let-命令&quot;&gt;&lt;a href=&quot;#1-let-命令&quot; class=&quot;headerlink&quot; title=&quot;1.let 命令&quot;&gt;&lt;/a&gt;1.let 命令&lt;/h1&gt;&lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ECMAScript6" scheme="http://www.wangbin26.com/tags/ECMAScript6/"/>
    
      <category term="let" scheme="http://www.wangbin26.com/tags/let/"/>
    
      <category term="const" scheme="http://www.wangbin26.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>移动web开发基础</title>
    <link href="http://www.wangbin26.com/2016/06/04/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.wangbin26.com/2016/06/04/移动web开发基础/</id>
    <published>2016-06-04T07:06:32.000Z</published>
    <updated>2018-04-25T15:36:06.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-布局"><a href="#1-1-布局" class="headerlink" title="1.1 布局"></a>1.1 布局</h2><h3 id="1-1-1三种布局"><a href="#1-1-1三种布局" class="headerlink" title="1.1.1三种布局"></a>1.1.1三种布局</h3><p>有最大、最小宽度的百分比自适应布局<br>适用场景：门户网站首页，图片较多的首页。<br>百分比自适应布局<br>适用场景：信息文字较多的网页，内容较多网页。<br>全屏自适应布局<br>适用场景：单页面网页，移动web app 页面。</p><p>###1.1.2Box-sizing在移动端的使用<br>在百分比定宽的页面经常使用。<br><code>*,::before,::after{    -webkit-box-sizing: border-box;/*以你的border开始计算你的宽度*/}</code></p><h2 id="1-2移动端事件"><a href="#1-2移动端事件" class="headerlink" title="1.2移动端事件"></a>1.2移动端事件</h2><p>Touch<br>touchstart：当手指触碰屏幕时候发生。不管当前有多少只手指</p><p>touchmove：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，<br>会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动</p><p>touchend：当手指离开屏幕时触发</p><p>touchcancel：系统停止跟踪触摸时候会触发。<br>例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用<br>触摸事件的响应顺序<br>1、ontouchstart<br>2、ontouchmove<br>3、ontouchend<br>4、onclick  300ms延时</p><p>Event<br>originalEvent （原生事件） 是jquery 封装的事件。<br>targetTouches 目标元素的所有当前触摸<br>changedTouches 页面上最新更改的所有触摸<br>touches 页面上的所有触摸</p><p>clientX、clientY 相对于当前屏幕的X或Y位置<br>pageX、pageY 相对于整体页面的X或Y位置</p><p>transitionEnd 过渡结束事件。<br>animationEnd 动画结束事件</p><p>移动端事件框架<br>例如 zepto  touch.js</p><p>‘swipe’,<br>‘swipeLeft’,<br>‘swipeRight’,<br>‘swipeUp’,<br>‘swipeDown’,<br>  ‘doubleTap’,<br>‘tap’,<br>‘singleTap’,<br>‘longTap’<br>都是由我们的原生touch事件封装的。</p><h2 id="1-3常见的移动端问题"><a href="#1-3常见的移动端问题" class="headerlink" title="1.3常见的移动端问题"></a>1.3常见的移动端问题</h2><h3 id="1-3-1什么是Retina-显示屏，带来了什么问题"><a href="#1-3-1什么是Retina-显示屏，带来了什么问题" class="headerlink" title="1.3.1什么是Retina 显示屏，带来了什么问题"></a>1.3.1什么是Retina 显示屏，带来了什么问题</h3><p>retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个<br>在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。<br>那么，前端的应对方案是：<br>设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2<br>//例如图片宽高为：200px*200px，那么写法如下<br>.css{width:100px;height:100px;background-size:100px 100px;}<br>其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px<br>.css{font-size:20px}</p><h3 id="1-3-2百度禁止转码"><a href="#1-3-2百度禁止转码" class="headerlink" title="1.3.2百度禁止转码"></a>1.3.2百度禁止转码</h3><p>通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：<br><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;</code></p><h3 id="1-3-3移动端手机号码识别（IOS）"><a href="#1-3-3移动端手机号码识别（IOS）" class="headerlink" title="1.3.3移动端手机号码识别（IOS）"></a>1.3.3移动端手机号码识别（IOS）</h3><p>在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：<br>1 7位数字，形如：1234567<br>2 带括号及加号的数字，形如：(+86)123456789<br>3 双连接线的数字，形如：00-00-00111<br>4 11位数字，形如：13800138000<br>可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：<br><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;</code><br>开启电话功能<br><code>&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;</code><br>开启短信功能：<br><code>&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt;</code></p><p>###1.3.4移动端邮箱识别（Android）<br>与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：<br><code>&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;</code><br>同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：<br><code>&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt;</code></p><h3 id="1-3-5ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"><a href="#1-3-5ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉" class="headerlink" title="1.3.5ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉"></a>1.3.5ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉</h3><p>ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。<br><code>{-webkit-tap-highlight-color: rgba(0,0,0,0;)}</code></p><h3 id="1-3-6webkit表单元素的默认外观怎么重置"><a href="#1-3-6webkit表单元素的默认外观怎么重置" class="headerlink" title="1.3.6webkit表单元素的默认外观怎么重置"></a>1.3.6webkit表单元素的默认外观怎么重置</h3><p><code>.css{-webkit-appearance:none;}</code></p><h3 id="1-3-7禁止文本缩放"><a href="#1-3-7禁止文本缩放" class="headerlink" title="1.3.7禁止文本缩放"></a>1.3.7禁止文本缩放</h3><p>当移动设备横竖屏切换时，文本的大小会重新计算（或者在内嵌浏览器中设置字体的大小），进行相应的缩放，当我们不需要这种情况时，可以选择禁止：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> html &#123;</span><br><span class="line">　　-webkit-text-size-adjust: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-3-8移动端禁止选中内容"><a href="#1-3-8移动端禁止选中内容" class="headerlink" title="1.3.8移动端禁止选中内容"></a>1.3.8移动端禁止选中内容</h3><p>如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.user-select-none &#123;</span><br><span class="line">  -webkit-user-select: none;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><h3 id="1-3-9如何禁止保存或拷贝图像（IOS）"><a href="#1-3-9如何禁止保存或拷贝图像（IOS）" class="headerlink" title="1.3.9如何禁止保存或拷贝图像（IOS）"></a>1.3.9如何禁止保存或拷贝图像（IOS）</h3><p>通常当你在手机或者pad上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：<br><code>img { -webkit-touch-callout: none; }</code></p><h3 id="1-3-10摇一摇功能"><a href="#1-3-10摇一摇功能" class="headerlink" title="1.3.10摇一摇功能"></a>1.3.10摇一摇功能</h3><p>HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。</p><h3 id="1-3-11-android-上去掉语音输入按钮"><a href="#1-3-11-android-上去掉语音输入按钮" class="headerlink" title="1.3.11 android 上去掉语音输入按钮"></a>1.3.11 android 上去掉语音输入按钮</h3><p>input::-webkit-input-speech-button {display: none}</p><h3 id="1-3-12移动端基础框架"><a href="#1-3-12移动端基础框架" class="headerlink" title="1.3.12移动端基础框架"></a>1.3.12移动端基础框架</h3><p>zepto.js语法与jquery几乎一样，会jquery基本会zepto；<br>搭配<br>backbone underscore<br><a href="http://daneden.github.io/animate.css/" target="_blank" rel="noopener">动画css</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-布局&quot;&gt;&lt;a href=&quot;#1-1-布局&quot; class=&quot;headerlink&quot; title=&quot;1.1 布局&quot;&gt;&lt;/a&gt;1.1 布局&lt;/h2&gt;&lt;h3 id=&quot;1-1-1三种布局&quot;&gt;&lt;a href=&quot;#1-1-1三种布局&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="移动web开发" scheme="http://www.wangbin26.com/tags/%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议</title>
    <link href="http://www.wangbin26.com/2016/05/06/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://www.wangbin26.com/2016/05/06/HTTP协议/</id>
    <published>2016-05-06T19:46:20.000Z</published>
    <updated>2018-04-24T13:48:14.930Z</updated>
    
    <content type="html"><![CDATA[<p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p><p><a href="http://www.cnblogs.com/rayray/p/3729533.html" target="_blank" rel="noopener">详细请点击</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器&lt;/p&gt;
&lt;p&gt;http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTTP协议" scheme="http://www.wangbin26.com/tags/HTTP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>CSS3基础笔记</title>
    <link href="http://www.wangbin26.com/2016/04/25/CSS3%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wangbin26.com/2016/04/25/CSS3基础笔记/</id>
    <published>2016-04-25T18:38:52.000Z</published>
    <updated>2018-04-28T03:57:33.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章CSS3简介"><a href="#第1章CSS3简介" class="headerlink" title="第1章CSS3简介"></a>第1章CSS3简介</h1><p>如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。</p><h2 id="1-1-CSS3的现状"><a href="#1-1-CSS3的现状" class="headerlink" title="1.1 CSS3的现状"></a>1.1 CSS3的现状</h2><pre><code>1、浏览器支持程度差，需要添加私有前缀2、移动端支持优于PC端3、不断改进中4、应用相对广泛</code></pre><h2 id="1-2-如何对待"><a href="#1-2-如何对待" class="headerlink" title="1.2 如何对待"></a>1.2 如何对待</h2><pre><code>1、坚持渐进增强原则2、考虑用户群体3、遵照产品的方案4、听Boss的</code></pre><h1 id="第2章准备工作"><a href="#第2章准备工作" class="headerlink" title="第2章准备工作"></a>第2章准备工作</h1><h2 id="2-1统一环境"><a href="#2-1统一环境" class="headerlink" title="2.1统一环境"></a>2.1统一环境</h2><p>由于CSS3兼容性问题的普遍存在，为了避免因兼容性带来的干扰，我们约定统一的环境，以保证学习的效率，在最后会单独说明兼容性的问题。<br>    1、Chrome浏览器 version 46+<br>    2、Firefox浏览器 firefox 42+<br>    3、PhotoShop CS6（建议）</p><h2 id="2-2如何使用手册"><a href="#2-2如何使用手册" class="headerlink" title="2.2如何使用手册"></a>2.2如何使用手册</h2><p>学会使用工具，可以让我们事半功倍。<br>[]        表示全部可选项<br>||        表示或者<br>|        表示多选一<br>？    表示0个或者1个<br>*        表示0个或者多个<br>{}        表示范围</p><h1 id="第3章基础知识"><a href="#第3章基础知识" class="headerlink" title="第3章基础知识"></a>第3章基础知识</h1><h2 id="3-1选择器"><a href="#3-1选择器" class="headerlink" title="3.1选择器"></a>3.1选择器</h2><p>CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与jQuery中所提供的绝大部分选择器兼容。</p><h3 id="3-1-1属性选择器"><a href="#3-1-1属性选择器" class="headerlink" title="3.1.1属性选择器"></a>3.1.1属性选择器</h3><p>参考手册<br>1、E[attr] 表示存在attr属性即可；<br>2、E[attr=val] 表示属性值完全等于val<br>3、E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的<br>4、E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以“-”分隔的<br>5、E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置<br>6、E[attr^=val] 表示的属性值里包含val字符并且在“开始”位置<br>7、E[attr$=val] 表示的属性值里包含val字符并且在“结束”位置</p><h3 id="3-1-2伪类选择器"><a href="#3-1-2伪类选择器" class="headerlink" title="3.1.2伪类选择器"></a>3.1.2伪类选择器</h3><p>参考手册<br>重点理解E是用来参考确定其父元素的，nth-child(n) 对应根据E元素确定的父元素的所有子元素，nth-of-type(n) 的不同之处在于其对应的是只有E元素，会忽略其子元素。（此处要配合案例加强理解）<br>E:nth-child(n) 第n个子元素，计算方法是E元素的全部兄弟元素<br>E:nth-of-type(n) 第n个子元素，计算方法只是E元素，会忽略其子元素的<br>存在<br>E:nth-last-child(n) 同E:nth-child(n) 计算顺序相反。<br>E:nth-last-of-type(n) 同E:nth-of-type(n) 计算顺序相反。<br>n遵循线性变化，其取值1、2、3、4、…<br>关于n的取值范围：<br>1、当n做为一个独立值时，n取值为n&gt;=1，例如nth-child(n)<br>2、当n做一个系数时，n取值为n&gt;=0者n&lt;0，例如nth-child(2n+1)、nth-child(-1n+5) 此处需要理解2n+1或者-n+5做为一个整体不能小于1；<br>E:only-child 表示当前以E确定的父元素，除E之外并无其它子元素（独生子）；<br>E:only-of-type表示当前以E确定的父元素， 除E之外不能包含其它和E同类型的子元素；<br>E:target 结合锚点进行使用，处于当前锚点的元素会被选中；<br>E:empty 选中没有任何子节点的E元素；</p><p>###3.1.3伪元素选择器<br>E::selection 可改变选中文本的样式<br>E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。<br>E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。<br>“:” 与 “::” 区别在于区分伪类和伪元素</p><h2 id="3-2颜色"><a href="#3-2颜色" class="headerlink" title="3.2颜色"></a>3.2颜色</h2><p>新增了RGBA、HSLA模式，其中的A 表示透明度通道，即可以设置颜色值的透明度，相较opacity，不具有继承性，即不会影响子元素的透明度。<br>Red、Green、Blue、Alpha即RGBA<br>Hue、Saturation、Lightness、Alpha即HSLA<br>R、G、B 取值范围0~255<br>H 取值范围0~360，0/360表示黑色、120表示绿色、240表示蓝色<br>S 取值范围0%~100%<br>L 取值范围0%~100%<br>A 取值范围0~1<br>关于透明度：<br>1、opacity子元素会继承父元素的透明度，在实际开发中会带来干扰；<br>2 、transparent 设置透明度时完全类似于“玻璃”一样的透明；</p><h2 id="3-3文本"><a href="#3-3文本" class="headerlink" title="3.3文本"></a>3.3文本</h2><p>参考手册<br>文字阴影与边框阴影相似，可分别设置偏移量、模糊度、颜色（可设透明度）。<br>单行文本溢出，需要配合overflow:hidden; white-space: nowrap;<br>难理解的点：<br>自已要多试着理解一下关于white-space的各个属性值之间的差异；<br>换行符指的我们在键盘上的Enter键，Enter换行符会被当成空行来对待，而由Tab、Space产生的换行，则会视为一个空格。<br>上述方法只能解决单行文本的溢出问题，多行文本溢出处理可参照下面的方法，但是有比较严重的兼容性，需要慎重选择，比较完备的多行溢出需要JS辅助完成，可自行尝试。<br>多行文本文字溢出处理，非标准属性，可应用于移动端</p><p>了解常握white-space 使用</p><h2 id="3-4边框"><a href="#3-4边框" class="headerlink" title="3.4边框"></a>3.4边框</h2><p>其边框圆角、边框阴影属性，应用十分广泛，兼容性也相对较好，具有符合渐进增强原则的特征，我们需要重点掌握。</p><h3 id="3-4-1边框圆角"><a href="#3-4-1边框圆角" class="headerlink" title="3.4.1边框圆角"></a>3.4.1边框圆角</h3><p>圆角处理时，脑中要形成圆、圆心、长半径、短半径的概念，正圆是椭圆的一种特殊情况。</p><p>可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ）<br>参考手册练习熟悉各种简写方式。</p><p>表格运用圆角需要要 border-collapse: separate;<br>当圆角半径小于或等于边框宽度时，元素内角是直角</p><p>如何在PS中查看圆角半径？</p><h3 id="3-4-2边框图片"><a href="#3-4-2边框图片" class="headerlink" title="3.4.2边框图片"></a>3.4.2边框图片</h3><p>设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图</p><p>“切割”完成后生成虚拟的9块图形，然后按对应位置设置背景，<br>其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。如下图</p><p>round 会自动调整尺寸，完整显示边框图片。</p><p>repeat 单纯平铺多余部分，会被“裁切”而不显示。</p><p>background-slice: 27 40 40 27 分别设置裁切如下图</p><h3 id="3-4-3边框阴影"><a href="#3-4-3边框阴影" class="headerlink" title="3.4.3边框阴影"></a>3.4.3边框阴影</h3><p>水平偏移量 正值向右 负值向左 垂直正值向下 负值向上。<br>模糊度是不能为负<br>关于模糊度：从一个颜色值在一定距离内进行一个渐变至透明的过程。<br>移量和扩展也是数学运算的，即正负会相互抵消。<br>偏移量和模糊度是可以相加计算，偏移量负号只代表方向。<br>设置边框阴影不会影响盒子的布局，即不会影响其兄弟元素的布局。<br>spread可以与blur、h-shadow、v-shadow相互抵消，blur不可为负值<br>可以设置多重边框阴影，实现更好的效果，增强立体感。</p><h2 id="3-5盒模型"><a href="#3-5盒模型" class="headerlink" title="3.5盒模型"></a>3.5盒模型</h2><p>关于盒模型存在两种形式，分别是W3C标准盒模型和IE盒模型，如下图所示，其区别主要在于宽度和高度的计算方式，CSS3对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。</p><p>IE模型下 width = padding + content + border;<br>W3C盒模型下 width = content<br>box-sizing: border-box  width = border + padding + content<br>box-sizing: content-box  width = content<br>IE盒模型只会出现在IE5版本和IE6+的怪异模式中。<br>怪异模式<br><a href="http://www.cnblogs.com/coco1s/p/4034937.html" target="_blank" rel="noopener">http://www.cnblogs.com/coco1s/p/4034937.html</a><br>CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box;</p><h2 id="3-6背景"><a href="#3-6背景" class="headerlink" title="3.6背景"></a>3.6背景</h2><p>背景在CSS3中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。<br>cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。<br>contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。<br>background-size 与 background-clip无关<br>background-size 与 background-origin 保持一致<br>背景图片尺寸在实际开发中应用十分广泛。<br>参照手册</p><h2 id="3-7渐变"><a href="#3-7渐变" class="headerlink" title="3.7渐变"></a>3.7渐变</h2><p>渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。<br>可分为线性渐变、径向渐变、重复渐变。<br>线性渐变指沿着某条直线朝一个方向产生渐变效果。</p><p>上图是从黄色渐变到绿色<br>必要的元素：方向、起始颜色、终止色；<br>关于方向如下图</p><p>关于颜色起止，可以设置多个色值的渐变，并且可以分别设置渐变的距离<br>如 linear-gradient(to left, yellow 10%, blue 15%, red 50%)<br>径向渐变指从一个中心点开始沿着四周产生渐变效果</p><p>特点：<br>1、辐射范围<br>2、中心点<br>3、颜色的起止<br>关于中心点：中心位置参照的是盒子的左上角<br>关于辐射范围：其半径可以不等即可以是椭圆<br>关于圆的知识同边框圆角章节的介绍</p><h2 id="3-8伸缩布局"><a href="#3-8伸缩布局" class="headerlink" title="3.8伸缩布局"></a>3.8伸缩布局</h2><p>CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用，使得开发人员一下子就过上了小康的生活。<br>伸缩盒模型经历了几次演变，大致分为旧版伸缩布局、过渡伸缩布局、新版伸缩布局，同样为了避免混淆，我们以学习新版伸缩布局为主。</p><h2 id="3-8-1新版伸缩布局"><a href="#3-8-1新版伸缩布局" class="headerlink" title="3.8.1新版伸缩布局"></a>3.8.1新版伸缩布局</h2><p>这里我们需要引入一些新的概念：<br>主轴：Flex容器的主轴主要用来配置Flex项目。<br>侧轴：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。<br>主轴和侧轴并不是固定不变的，通过flex-direction可以调整。</p><p>1、指定一个盒子为伸缩盒子 display: flex<br>2、设置属性来调整此盒的子元素的布局方式 例如 flex-direction<br>3、明确主侧轴的方向<br>4、可互换主侧轴，也可改变方向<br>其相关属性可参照源代码里的解释如flex-direction、flex-wrap、flex-flow、align-items、align-content、justify-content、align-self、flex、order等<br>另个两个版本伸缩布局其实现思路与新版基本一致，区别在于其属性及属性值不同，熟练掌握新版伸缩布局后，要参照对比另外两个版本的不同。</p><h2 id="3-9多列布局"><a href="#3-9多列布局" class="headerlink" title="3.9多列布局"></a>3.9多列布局</h2><p>类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。<br>参照手册</p><h2 id="3-10过渡"><a href="#3-10过渡" class="headerlink" title="3.10过渡"></a>3.10过渡</h2><p>过渡是CSS3中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。<br>帧动画：通过一帧一帧的关键画面按照固定顺序和速度播放。如电影胶片</p><p>补间动画：自动完成从起始状到终止状的的过度。<br>关于补间动画更多学习可查看<a href="http://mux.alimama.com/posts/1009" target="_blank" rel="noopener">http://mux.alimama.com/posts/1009</a><br>特点：当前元素只要有“属性”发生变化时，可以平滑的进行过渡。<br>transition-property设置过渡属性<br>transition-duration设置过渡时间<br>transition-timing-function设置过渡速度<br>transition-delay设置过渡延时<br>贝塞尔曲线限定了过渡的轨迹。这部分没有提及，有兴趣同学自行查阅相关资料了解一下即可。<br>以上四属性重在更解，具体细节可参考手册辅助记忆</p><h2 id="3-11动画"><a href="#3-11动画" class="headerlink" title="3.11动画"></a>3.11动画</h2><p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。<br>参考手册</p><h2 id="3-12转换"><a href="#3-12转换" class="headerlink" title="3.12转换"></a>3.12转换</h2><p>转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合即将学习的过渡和动画知识，可以取代大量之前只能靠Flash才可以实现的效果。<br>2D 转换<br>translate(x,y)  x、y 可为负值，相对自身移动，并未脱离文档流。<br>左手坐标系：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。<br>左手法则：左手握住旋转轴，竖起拇指指向旋转轴正方向，正向旋转方向就是其余手指卷曲的方向。</p><p>3D坐标轴，用X、Y、Z分别表示空间的3个维度，三条轴上互相垂直。</p><h2 id="3-13媒体查询"><a href="#3-13媒体查询" class="headerlink" title="3.13媒体查询"></a>3.13媒体查询</h2><p>由于网页呈现终端设备越来越趋向于多样化，尤其是移动终端（手机），具有不同屏幕尽寸、不同分辨率，为了保证网页能十分友好的呈现，CSS3为开发人员提供了可以识别呈现终端的方法，这样便可以有针对性的为不同的呈现终端分别进行处理，被广泛应用于响应式开发中。<br>html 标签方式：<br>css 属性方式：<br>常使用的是检测设备宽度<br>参考手册<br>第4章Web字体<br>开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。<br>支持程度比较好，甚至IE低版本浏览器也能支持。</p><h2 id="4-1字体格式"><a href="#4-1字体格式" class="headerlink" title="4.1字体格式"></a>4.1字体格式</h2><p>不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。<br>1、TureTpe(.ttf)格式<br>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；<br>2、OpenType(.otf)格式<br>.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；<br>3、Web Open Font Format(.woff)格式<br>woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；<br>4、Embedded Open Type(.eot)格式<br>.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；<br>5、SVG(.svg)格式<br>.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；<br>关于字体介绍摘自<a href="http://www.w3cplus.com/content/css3-font-face/" target="_blank" rel="noopener">http://www.w3cplus.com/content/css3-font-face/</a><br>了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。<br>推荐<a href="http://www.zhaozi.cn/、http://www.youziku.com/" target="_blank" rel="noopener">http://www.zhaozi.cn/、http://www.youziku.com/</a> 查找更多中文字体</p><h2 id="4-2字体图标"><a href="#4-2字体图标" class="headerlink" title="4.2字体图标"></a>4.2字体图标</h2><p>其实我们可以把文字理解成是一种特殊形状的图片，反之我们是不是也可以把图片制作成字体呢？<br>答案是肯定的。<br>常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体库，然后就可以像使用文字一样使用图标了。<br>优点：<br>1、将所有图标打包成字体库，减少请求；<br>2、具有矢量性，可保证清晰度；<br>3、使用灵活，便于维护；<br>Font Awesome 使用介绍<br><a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">http://fontawesome.dashgame.com/</a><br>定制自已的字体图标库<br><a href="http://iconfont.cn/" target="_blank" rel="noopener">http://iconfont.cn/</a><br><a href="https://icomoon.io/" target="_blank" rel="noopener">https://icomoon.io/</a><br>SVG<br><a href="http://www.iconsvg.com/" target="_blank" rel="noopener">http://www.iconsvg.com/</a></p><h1 id="第5章兼容性"><a href="#第5章兼容性" class="headerlink" title="第5章兼容性"></a>第5章兼容性</h1><p>通过<a href="http://caniuse.com/" target="_blank" rel="noopener">http://caniuse.com/</a> 可查询CSS3各特性的支持程度，一般兼容性处理的常见方法是为属性添加私有前缀，如不能解决，应避免使用，无需刻意去处理CSS3的兼容性问题。</p><h1 id="第6章高级应用"><a href="#第6章高级应用" class="headerlink" title="第6章高级应用"></a>第6章高级应用</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第1章CSS3简介&quot;&gt;&lt;a href=&quot;#第1章CSS3简介&quot; class=&quot;headerlink&quot; title=&quot;第1章CSS3简介&quot;&gt;&lt;/a&gt;第1章CSS3简介&lt;/h1&gt;&lt;p&gt;如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSS3" scheme="http://www.wangbin26.com/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>HTML5触摸事件</title>
    <link href="http://www.wangbin26.com/2016/04/20/HTML5%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.wangbin26.com/2016/04/20/HTML5触摸事件/</id>
    <published>2016-04-20T18:27:42.000Z</published>
    <updated>2018-04-24T13:56:00.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-HTML5触摸事件"><a href="#1-HTML5触摸事件" class="headerlink" title="1. HTML5触摸事件"></a>1. HTML5触摸事件</h1><p>HTML5中新添加了很多事件，但是由于他们的兼容问题不是很理想，应用实战性不是太强，所以在这里基本省略，咱们只分享应用广泛兼容不错的事件，日后随着兼容情况提升以后再陆续添加分享。今天为大家介绍的事件主要是触摸事件：touchstart、touchmove和touchend。</p><p>　　一开始触摸事件touchstart、touchmove和touchend是iOs版Safari浏览器为了向开发人员传达一些信息新添加的事件。因为iOs设备既没有鼠标也没有键盘，所以在为移动Safari浏览器开发交互性网页的时候，PC端的鼠标和键盘事件是不够用的。</p><p>　　在iPhone 3Gs发布的时候，其自带的移动Safari浏览器就提供了一些与触摸(touch)操作相关的新事件。随后，Android上的浏览器也实现了相同的事件。触摸事件(touch)会在用户手指放在屏幕上面的时候、在屏幕上滑动的时候或者是从屏幕上移开的时候出发。下面具体说明：</p><p>　　touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。</p><p>　　touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。</p><p>　　touchend事件：当手指从屏幕上离开的时候触发。</p><p>　　touchcancel事件：当系统停止跟踪触摸的时候触发。关于这个事件的确切出发时间，文档中并没有具体说明，咱们只能去猜测了。</p><p>　　上面的这些事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但是它们却是以兼容DOM的方式实现的。所以，每个触摸事件的event对象都提供了在鼠标实践中常见的属性：bubbles(起泡事件的类型)、cancelable(是否用 preventDefault() 方法可以取消与事件关联的默认动作)、clientX(返回当事件被触发时，鼠标指针的水平坐标)、clientY(返回当事件触发时，鼠标指针的垂直坐标)、screenX(当某个事件被触发时，鼠标指针的水平坐标)和screenY(返回当某个事件被触发时，鼠标指针的垂直坐标)。除了常见的DOM属性，触摸事件还包含下面三个用于跟踪触摸的属性。</p><p>　　touches：表示当前跟踪的触摸操作的touch对象的数组。</p><p>　　targetTouches：特定于事件目标的Touch对象的数组。</p><p>　　changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。</p><p>　　每个Touch对象包含的属性如下。</p><p>　　clientX：触摸目标在视口中的x坐标。</p><p>　　clientY：触摸目标在视口中的y坐标。</p><p>　　identifier：标识触摸的唯一ID。</p><p>　　pageX：触摸目标在页面中的x坐标。</p><p>　　pageY：触摸目标在页面中的y坐标。</p><p>　　screenX：触摸目标在屏幕中的x坐标。</p><p>　　screenY：触摸目标在屏幕中的y坐标。</p><p>　　target：触目的DOM节点目标。</p><p>　　上面的属性光这么看，果然非常繁琐，每个属性说的都是那么的细致，只有真刀实枪的来点小例子才能更加明白其中的奥妙。所以小例子如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function load ()&#123;  </span><br><span class="line">   </span><br><span class="line">    document.addEventListener(&apos;touchstart&apos;,touch, false);  </span><br><span class="line">    document.addEventListener(&apos;touchmove&apos;,touch, false);  </span><br><span class="line">    document.addEventListener(&apos;touchend&apos;,touch, false);  </span><br><span class="line">       </span><br><span class="line">    function touch (event)&#123;  </span><br><span class="line">        var event = event || window.event;  </span><br><span class="line">           </span><br><span class="line">        var oInp = document.getElementById(&quot;inp&quot;);  </span><br><span class="line">   </span><br><span class="line">        switch(event.type)&#123;  </span><br><span class="line">            case &quot;touchstart&quot;:  </span><br><span class="line">                oInp.innerHTML = &quot;Touch started (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;;  </span><br><span class="line">                break;  </span><br><span class="line">            case &quot;touchend&quot;:  </span><br><span class="line">                oInp.innerHTML = &quot;&lt;br&gt;Touch end (&quot; + event.changedTouches[0].clientX + &quot;,&quot; + event.changedTouches[0].clientY + &quot;)&quot;;  </span><br><span class="line">                break;  </span><br><span class="line">            case &quot;touchmove&quot;:  </span><br><span class="line">                event.preventDefault();  </span><br><span class="line">                oInp.innerHTML = &quot;&lt;br&gt;Touch moved (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;;  </span><br><span class="line">                break;  </span><br><span class="line">        &#125;  </span><br><span class="line">           </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">window.addEventListener(&apos;load&apos;,load, false);</span><br></pre></td></tr></table></figure><p>touches: 当前屏幕上所有触摸点的列表;</p><p>targetTouches: 当前对象上所有触摸点的列表;</p><p>changedTouches: 涉及当前(引发)事件的触摸点的列表</p><p>通过一个例子来区分一下触摸事件中的这三个属性：</p><ol><li><p>用一个手指接触屏幕，触发事件，此时这三个属性有相同的值。</p></li><li><p>用第二个手指接触屏幕，此时，touches有两个元素，每个手指触摸点为一个值。当两个手指触摸相同元素时，<br>targetTouches和touches的值相同，否则targetTouches 只有一个值。changedTouches此时只有一个值，<br>为第二个手指的触摸点，因为第二个手指是引发事件的原因</p></li><li><p>用两个手指同时接触屏幕，此时changedTouches有两个值，每一个手指的触摸点都有一个值</p></li><li><p>手指滑动时，三个值都会发生变化</p></li><li><p>一个手指离开屏幕，touches和targetTouches中对应的元素会同时移除，而changedTouches仍然会存在元素。</p></li><li><p>手指都离开屏幕之后，touches和targetTouches中将不会再有值，changedTouches还会有一个值，<br>此值为最后一个离开屏幕的手指的接触点。</p></li></ol><h1 id="2-触点坐标选取"><a href="#2-触点坐标选取" class="headerlink" title="2. 触点坐标选取"></a>2. 触点坐标选取</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touchstart和touchmove使用: e.targetTouches[0].pageX 或 (jquery)e.originalEvent.targetTouches[0].pageX</span><br><span class="line"></span><br><span class="line">touchend使用: e.changedTouches[0].pageX 或 (jquery)e.originalEvent.changedTouches[0].pageX</span><br></pre></td></tr></table></figure><h1 id="3-touchmove事件对象的获取"><a href="#3-touchmove事件对象的获取" class="headerlink" title="3.touchmove事件对象的获取"></a>3.touchmove事件对象的获取</h1><p>想要在touchmove:function(e,参数一)加一个参数，结果直接使用e.preventDefault()就会 e 报错，处理方法为使用arguments[0]获取event参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touchmove:function(e,参数一)&#123;</span><br><span class="line">　　var e=arguments[0]</span><br><span class="line">　　e.preventDefault()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-HTML5触摸事件&quot;&gt;&lt;a href=&quot;#1-HTML5触摸事件&quot; class=&quot;headerlink&quot; title=&quot;1. HTML5触摸事件&quot;&gt;&lt;/a&gt;1. HTML5触摸事件&lt;/h1&gt;&lt;p&gt;HTML5中新添加了很多事件，但是由于他们的兼容问题不是很理想，
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTML5" scheme="http://www.wangbin26.com/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>HTML5基础</title>
    <link href="http://www.wangbin26.com/2016/03/09/HTML5%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.wangbin26.com/2016/03/09/HTML5基础/</id>
    <published>2016-03-09T07:45:40.000Z</published>
    <updated>2018-04-25T15:36:15.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用普通文本描述富文本的语法<br>扩展名md,markdown</p></blockquote><h1 id="HTML5之HTML篇回顾"><a href="#HTML5之HTML篇回顾" class="headerlink" title="HTML5之HTML篇回顾"></a>HTML5之HTML篇回顾</h1><ol><li>新标签<ol><li>语义化标签</li></ol></li><li>新属性<ol><li>链接关系描述</li><li>ARIA 无障碍富互联网应用程序属性</li><li>自定义属性 data-<ol><li>可以给HTML里的所有DOM对象都可以添加一些DATA-xxx的属性</li><li>用来记录与当前DOM强相关的数据</li></ol></li></ol></li><li>智能表单<ol><li>新的表单类型<ol><li>功能型的表单类型</li></ol></li><li>虚拟键盘适配<ol><li>通过type方式指定弹出键盘</li></ol></li></ol></li><li>网页多媒体<ol><li>之前强依赖flash </li><li>音频</li><li>多媒体的dom对象有一些新的方法可以去做播放暂停</li><li>视频</li><li>了解字幕</li></ol></li><li>SVG 文件基本使用<ol><li>iframe<ol><li>iframe的作用就是在网页中挖个坑，在这个坑里再展示一个页面</li><li>svg本身也是文档 所以可以使用iframe的方式载入</li></ol></li><li>ajax 直接可以修改样式 </li></ol></li></ol><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="2-1-基础API提升"><a href="#2-1-基础API提升" class="headerlink" title="2.1. 基础API提升"></a>2.1. 基础API提升</h2><h3 id="2-1-1-新选择器"><a href="#2-1-1-新选择器" class="headerlink" title="2.1.1 新选择器"></a>2.1.1 新选择器</h3><p>JS多了一个原始支持，类似jqueryDOM选择器</p><p>document.getElementById() 需要给DOM元素设置ID<br>document.querySelector(selector) 可以通过CSS选择器的语法找到DOM元素</p><p>document.getElementsByTagName()<br>document.querySelectorAll(‘.item’)</p><p>$(‘.item’).on</p><ol><li>document.querySelector(selector); </li><li>返回第一个满足选择器条件的元素 一个dom对象</li><li>document.querySelectorAll(‘.item’);</li><li>返回所有满足该条件的元素 一个元素类型是dom类型的数组</li><li>$(‘.item’)</li><li>返回一个jQuery对象（dom元素的数组）</li><li>本质上jquery方式和qs方式都是获取DOM数组， 只不过jquery会多一些其他成员</li><li>DOM数组的每一个成员注册事件不能像jquery一样直接注册， 必须分别给每个元素注册</li><li>h5就是将我们经常需要的操作又包装一层</li></ol><h3 id="2-1-2-元素-classList"><a href="#2-1-2-元素-classList" class="headerlink" title="2.1.2 元素.classList"></a>2.1.2 元素.classList</h3><ol><li>新H5中DOM对象多了一个classList属性，是一个数组</li><li>add 添加一个新的类名</li><li>remove 删除一个的类名</li><li>contains 判断是否包含一个指定的类名 </li><li>toggle 切换一个class element.toggle(‘class-name’,[add_or_remove])</li><li>toggle函数的第二个参数true为添加 false删除</li></ol><h3 id="2-1-3-访问历史-API"><a href="#2-1-3-访问历史-API" class="headerlink" title="2.1.3 访问历史 API"></a>2.1.3 访问历史 API</h3><p>界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态<br>在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态</p><ol><li>window.history.forward(); // 前进</li><li>window.history.back(); // 后退</li><li>window.history.go(); // 刷新</li><li>通过JS可以加入一个访问状态</li><li>history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态)</li></ol><h3 id="2-1-4-全屏-API"><a href="#2-1-4-全屏-API" class="headerlink" title="2.1.4 全屏 API"></a>2.1.4 全屏 API</h3><blockquote><p>JavaScript中可以通过调用requestFullScreen()方式实现指定元素的全屏显示<br>var element = document.querySelector(‘…’);<br>element.requestFullScreen();</p></blockquote><h2 id="2-2-网页存储"><a href="#2-2-网页存储" class="headerlink" title="2.2 网页存储"></a>2.2 网页存储</h2><h3 id="2-2-1-Web-Storage"><a href="#2-2-1-Web-Storage" class="headerlink" title="2.2.1 Web Storage"></a>2.2.1 Web Storage</h3><ol><li>getItem方式获取一个不存在的键 返回空字符串</li><li>[]返回 undefined</li></ol><h3 id="2-2-2-Web-SQL"><a href="#2-2-2-Web-SQL" class="headerlink" title="2.2.2 Web SQL"></a>2.2.2 Web SQL</h3><h3 id="2-2-3-IndexedDB"><a href="#2-2-3-IndexedDB" class="headerlink" title="2.2.3 IndexedDB"></a>2.2.3 IndexedDB</h3><h2 id="2-3-文件系统"><a href="#2-3-文件系统" class="headerlink" title="2.3 文件系统"></a>2.3 文件系统</h2><h3 id="2-3-1-File-API"><a href="#2-3-1-File-API" class="headerlink" title="2.3.1 File API"></a>2.3.1 File API</h3><h3 id="2-3-2-FileReader"><a href="#2-3-2-FileReader" class="headerlink" title="2.3.2 FileReader"></a>2.3.2 FileReader</h3><h2 id="2-4-拖放操作"><a href="#2-4-拖放操作" class="headerlink" title="2.4 拖放操作"></a>2.4 拖放操作</h2><h3 id="2-4-1-网页内拖放"><a href="#2-4-1-网页内拖放" class="headerlink" title="2.4.1 网页内拖放"></a>2.4.1 网页内拖放</h3><h3 id="2-4-2-文件拖入"><a href="#2-4-2-文件拖入" class="headerlink" title="2.4.2 文件拖入"></a>2.4.2 文件拖入</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;用普通文本描述富文本的语法&lt;br&gt;扩展名md,markdown&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;HTML5之HTML篇回顾&quot;&gt;&lt;a href=&quot;#HTML5之HTML篇回顾&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="前端技术" scheme="http://www.wangbin26.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="HTML5" scheme="http://www.wangbin26.com/tags/HTML5/"/>
    
  </entry>
  
</feed>
