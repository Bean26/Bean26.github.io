<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你的生命里住着怎样的另一个自己]]></title>
    <url>%2F2017%2F04%2F24%2F%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E9%87%8C%E4%BD%8F%E7%9D%80%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[想起早年读过的半则神话故事。 远古时候有一渔者，终日在无妄之海捕鱼而生，有一日，迷失于一片海域，漂了一万两千年终于走出来，海水边搁浅着一叶扁舟，无人，无风，无鸟雀。他走近小船，看到一本上古秘籍，一页一页翻去，边颔首边赞叹，翻至最后一页，发现竟画着自己，与自己背靠背坐着一位书生，旁边还有两行字，一行：行文有际，……。后面的字被海书浸湿，看不清。又一行：猎海无涯，……。后面的字被一团黑墨盖住。叉弃书生衣摆之侧，笔置渔人篷发之间。 感兴趣的故事总是残篇断简。 神秘的预言若被印证，立刻觉得冥冥之中，有一只大手搅弄着风云，大气象之下的芸芸众生，越觉得微乎其微，虽杳渺，仍对细节着迷，就如有一个时刻，会莫名努力关注着一个闯进浮生半日的生命，而忽略了周遭的喧喧嚷嚷，任由故事里的人入了现实，而自己隐进故事。这一隐一现之间，命运就生出枝杈，生命就此丰盈起来。 1渔人猎到何种鱼都不足为奇。他擎叉的表情，他趟开草丛时四溅的水珠，他肩头划落的流星是以怎样的轨迹陨落，这些附着在故事本体的细微，才是一个可以讲出精彩故事的人的谈资。 而让渔人双眼放光的，终究是那些闯入眼帘的猎物。他布下重重陷井后，渴望着第二日，能够看到扑腾着的，那些误入岐途的鱼啊、贝啊的。 这天，他挽了叉，摸着黑出海。这天，他收了网，摸着黑回到家中。他从怀里取出从后海山涯上捡拾到的一方岩石，岩石上刻着一幅图，一男子单腿脆在渔船上，双手似掷叉，却不见叉，渔人寻思半晌，顺着那男子目光的方向画了一支渔叉。这样才踏实，他说。 夜晚入梦，他怀抱一轮月在浓雾里四野奔走，耳边隐隐有细碎的咳嗽，静立细听时，悄无声息，夺步而走时，又戚戚地回响于耳畔，他看不清自己的表情，却能看到完整的自己被白日的那片岩石群裹挟着，他内心有方向，而双脚无感，脚底接壤着的这片土地，让他瞬间立成一株静物。 走吧，走吧。他对自己说。身子重得仍旧迈不开腿，正犹疑时，听到猎犬狂吠，继而又听院子里“咣当”一声，不知何物从高处坠落，先砸在磨盘上然后滚落到地上，骨碌碌地，滚了一段距离。 他没起身，只是定睛看着窗外那一轮晧月，然后想起自己怀中的那一轮，他双臂环抱了一下，仿佛月光被尽数拢入，脸上现出宁静的光芒。第二天一早，渔人粗粗洗了脸，吃了饭，便直奔后海那个有画的岩石群，他想知道，那支鱼叉投向了哪个方向，叉中了什么。 2我发现，每人在讲述同一件事时，多少都会掺杂自己的一些意思，根本无法还原故事本身。即便司马迁有着怀揣一颗努力还原史实本真的初愿去写《史记》的心，在遣词造句上，还是会不动声色地糅进自己的偏好。寥寥数语的，或为不熟知或觉得微不足道；浓墨重彩的，或因事件撞击了历史的支柱，本身就足够分量，愿不愿意都得费些笔墨，这两者中间的事件，就去看一些形容词的使用，那里藏着他个人的意思。 因为觉得自己粗浅，给自己取昵称时，虽然向往，却仍不太敢用那些美好来粉饰，倘若骨子里与之不匹，一来倒了众人胃口，二来再牵连着人们对这词语生出俗意，才真正难堪。细想，昵称没取过几个，但拈了来就一直未改，虽俗了些，我却愿意用日复一日积攒起来的浅浅的、羞涩的美好，从内向外开出一朵花来，纵然这花一半盛开着自卑。 名字会被一些人遇见，遇见的人会先从名字里窥一些蛛丝蚂迹。这样一想，觉得气馁，转念又想，一个人倘若真的把一个俗名让人们唤得风生水起，亦或超凡脱俗，这才是大境界，比如《红楼梦》里的宝玉。多数人的名字是代号，但一定有例外。有人因为人而记住名字，有人因名字而记住人。 3渔人徒步于岩画幽壑。页岩上每条线的刻画，都让他想到那个手拿凿斧的人，用力气与技巧勾勒出的另种意义。 这是神谕吧，他秉承着流传与启示的职责，想渡一种修为于不朽。渔人想。画面上大多的飞禽走兽识得，即或斧凿之人用了写意或象形，他也能猜出，他不关心这些，他想知道，那个单腿脆在渔船的渔人的叉被定格在何处。 有的寻找是一种无意识的驱动，计划再周详，也会有变数。这一日，他的叉松下来，斑鸠咕咕响于林隙，野鹿饮水，鸥鸟翔于海天，他的眼神只穿梭于众多线条中。……故事说到这儿，再讲述不下去。因为，听到一个声音说，将事件推至洪荒，便可无稽，这是人们惯用的伎俩，有人用来隐藏秘密，有人用来使事件合理。又想，这未免有失偏颇，生命本身就具偶然性，生命本来就是一场有去无回的无稽之谈。所以，还是继续吧。 渔人有过设想，鱼叉或者射向一种奔跑，或者逆风正穿过船畔，只是那画中人让他觉得，他忽尔是他，又忽尔不是。他拎着那把叉一寻就是十四万年，林子绿了又黄，河水解冻又冰封，他日日来此，发蓬髭虬，再后来，他自己都不知为什么来这里。 他的眼神有深夜的气象，日头再如何猖獗，他所望之处，那些被焦烤着的混沌，清的上升，浊的下沉。他的胸腔有和熙的味道，再冰冷的长夜遇到他，会自动退守，会瓦解，会让野花开了合，合了开，只是他自己不知。于是，他学着凿斧手，在一片页岩上刻下一个符号，形似一支叉。那就是我。他想。以后，他每日都会来这里，与这个符号对视。 4前几天，读到一篇《葵花》的文，文中有段话说“世上再也找不到（比葵花）更大的傻子了。”“世界上居然有那么傻的花朵，开的那么大，那么笨，拼命三郎似的，整天追逐着日头找晒，无疑是疯了，是自找毁灭”。 读完后，我一直在乐。然后想起葵花的花语：沉默的爱，没有说出口的爱。想来，这位定义葵花花语的人，一定也是个傻子。 每朵花都美好，每个美好里都有不为人知的成长历程，比如烂漫夸张的向日葵，它的花语里分明住着一株含羞草，它有颗敏感的心，有人只看到葵藿倾阳，我却觉得，它是在诠释，什么叫命定的遇见。 不必期待人人懂。懂的自然懂，不懂的说了也不懂。 5与那个符号对视得久了，渔人想要跳出一种局囿。无妄海越深邃，猎物越丰沛，也愈发让他觉得孤独，这状态夜以继日地席卷着他，看花开，看花谢，有时他觉得自己是一棵树上的叶子，风过之处，无舵无浆般随波逐流，有时又觉得自己是枚果实，丰盈的果肉包裹着一颗内核，期待绽裂。 又过数年，渔人提着叉又去与那个符号对坐，因经年循着固定的路线行走，逶逶迤迤的，在荒草夹岸的荒滩里，辟出一条小径，其中利石变得圆滚，野草顺势伏地，齐腰的青蒿散发出清凉的味道，蚊虫远之，邪气避之，绿油油的样子，让人觉得吹过的风都是凉爽的。 这天，当走那个符号前时，他下意识地一惊。他发现他的符号上隐隐被补缀了另一个图案，近看，他发现是支毛笔，毫管与叉尖相齐，毫端与叉尾相对。 6有些词于我很惊艳。被惊艳后，会念念不忘。会在心里生出根，生出枝杈，会在某个合适的情境中将它安放。是什么力量在暗中让人一遍遍索引一种未知，比如说，深夜时候潜入的梦，白天的时候一晃而过的无意识的念头，又比如，那惊艳到我的字符触动了哪根弦，一个短瞬，迸发出高于感观与触觉的异常兴奋。 科学家的血液里藏有异冷的因子。他们平静地排列组合一堆数字时，理性的让人悲观，在他们得到的结论不符合我的想法时，我宁愿相信前世，或者玄学，那里住着另一个我，和那另一个我的过往世界，我如何舍得割舍与她的因果缘缘。 “生命的实质似乎是绝望与惊骇”，这话又真实的让人生怯，无所谓对与错吧，谁又知道谁经历了什么，又有几个人能够跳出一种局限，放眼于一种阔大，我们都是蝼蚁吧，按部就班地生活，所有的经历与眼界放进宇宙中，会另人发笑从而闭嘴。 我想，如果，另个我真的存在于三界之内，我想知道，她可常常像我一般，想念而向往，心照不宣又如影随形。 7然后，渔人突然有了写字的冲动，或者说，有了倾诉的愿望。于是树木与岩壁随处可见他的文，有的三五言，有的成阙成赋。 又过百十万年，有一天在渡口遇一中榜书生返乡，两个一见如故，一番寒暄后，竟是同乡又是同枝。 于是邀至家，秉烛夜话，酒到酣处，书生舞叉，渔人弄墨，书生褪去长衫，渔人瞥见他的肩头有一胎记，形似一支渔叉。 8故事到此就结束了。敲完这些文字，当晚有梦，梦见似是而非的自己亲临了一个梦境，梦境里有大片的月光，大片的海水，大片的沙滩。还梦到，我在沙滩上睡成贝壳的姿势，他在长一声短一声唤我的名字。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础理论知识]]></title>
    <url>%2F2016%2F08%2F16%2Fjs%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[全局变量 局部变量 变量声明 变量赋值 123456789//全局变量var sum; //变量声明sum = 10； //变量赋值function fn() &#123; //局部变量 var sum = 0;&#125; console.log(sum) // undefined 变量和函数声明提升定义 当前作用域内的声明都会提升到作用域的最前面，包括变量和函数的声明 12345678910111213141516//变量声明提升function test()&#123; var a = &quot;1&quot;; var f = function() &#123;&#125;; var b = &quot;2&quot;; var c = &quot;3&quot;;&#125;、、上述代码等价于 function test() &#123; var a,f,b,c; a = &quot;1&quot;; f = function()&#123;&#125;; b = &quot;2&quot;; c = &quot;3&quot;;&#125; 变量作用域和执行环境如何寻找全局变量 最外层函数和在最外层函数外面定义的变量拥有全局作用域 未定义直接赋值的变量自动声明为拥有全局作用域 – 比如 all1 all2 所有window对象的属性拥有全局作用域，我们也可以通过如下方式定义一个全局变量：window.name=1112345678910111213141516// a: 由于变量声明提升，这里a变量时存在的，但是是undefinedvar sum = 0;var a = 10all1 = 1000function test() &#123; //这个时候由于变量声明提升，a变量已经声明，并且值是undefined console.log(a); all2 = 200; //foo是一个函数，解析的时候会提升，所以能够访问到 console.log(foo()); //如果省略下面这句 输出结果是什么 //var a = 1 function foo()&#123; return 2 &#125;&#125; 数据类型 数值型 int整数： 1,2,3 float 浮点型： 1.2 字符串型 string: “a” “b” 布尔型 boolean: true,false 对象 object: 默认值:null 未定义 undefined:本身只有一个值，就是它本身 数据类型检查 数据类型检查方法: typeof() 数据类型转换 tostring 可以将其他类型转化成字符串运算符 算术运算符 +（加） ——（减） *（乘） /（除） %(取余数) 复合赋值运算符 -= += *= /= %= 自增自减运算符 – ++ 比较运算符 &gt; &lt; &gt;= &lt;= ==(比较的时候做类型转换) ===（全等于：值 数据类型都一样才算相等） != 逻辑运算符 &amp;&amp; 与 |或 ！非 三元运算符 ?逗号表达式 逗号表达式的一般形式是：表达式1，表达式2，表达式3……表达式n 逗号表达式的求解过程是：先计算表达式1的值，再计算表达式2的值，……一直计算到表达式n的值。最后整个逗号表达式的值是表达式n的值。 12345678910x=8*2,x*4 /*整个表达式的值为64，x的值为16*/ (x=8*2,x*4),x*2 /*整个表达式的值为128，x的值为16*/ x=(z=5,5*2) /*整个表达式为赋值表达式，它的值为10，z的值为5*/ x=z=5,5*2 /*整个表达式为逗号表达式，它的值为10，x和z的值都为5*/ 短路表达式 关联记忆法则：大家只要记住||,然后通过关联性记住&amp;&amp;如何记忆&amp;&amp;：两个字，和||相反| | : 如果左边的true就返回左边 否则返回右边&amp;&amp;: 如果左边返回的true就返回右边 否则返回左边短路表达式基础 - ||&amp; 用法 1 是true 0 是false 字符串除了空字符串外都是true function 和 object都是true null 和 undefined都是false 短路表达式可以简化if语句123456前：if (myobj) &#123; doSomething(myobj); &#125;后：myobj &amp;&amp; doSomething(myobj); 函数 知道函数其实就是一个工具，我们只需要学会使用工具就可以实现某个功能 这就是封装性 document对象对象 –工具包 getElementById() | 根据元素 id 得到元素（第一个） getElementsByName() | 根据元素 name 得到元素对象的集合 getElementsByTagName() | 根据指定标签名得到元素对象的集合 write() | 向文档写 HTML 表达式 或 JavaScript 代码 document.title //设置文档标题等价于HTML的标签 document.bgColor //设置页面背景色 document.fgColor //设置前景色(文本颜色) document.linkColor //未点击过的链接颜色 document.alinkColor //激活链接(焦点在此链接上)的颜色 document.vlinkColor //已点击过的链接颜色 document.URL //设置URL属性从而在同一窗口打开另一网页 document.fileCreatedDate //文件建立日期，只读属性 document.fileModifiedDate //文件修改日期，只读属性 document.fileSize //文件大小，只读属性 document.cookie //设置和读出cookie document.charset //设置字符集 简体中文:gb2312 字符串对象 indexOf(): 返回某个指定的字符串值在字符串中首次出现的位置,从 0 开始的，数组中没找到字符串则返回 -1，对大小写敏感！ 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.indexOf(&quot;Hello&quot;) + &quot;&lt;br /&gt;&quot;)document.write(str.indexOf(&quot;World&quot;) + &quot;&lt;br /&gt;&quot;)document.write(str.indexOf(&quot;world&quot;))&lt;/script&gt;输出:0-16 charAt() 方法可返回指定位置的字符。 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.charAt(1))&lt;/script&gt;输出：e concat() 方法用于连接两个或多个字符串。 123456789&lt;script type=&quot;text/javascript&quot;&gt;var str1=&quot;Hello &quot;var str2=&quot;world!&quot;document.write(str1.concat(str2))&lt;/script&gt;输出：Hello world! slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello happy world!&quot;document.write(str.slice(6,11))&lt;/script&gt;输出：happy subStr()： 可在字符串中抽取从 start 下标开始的指定数目的字符。 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.substr(3))&lt;/script&gt;输出:lo world! substring(): 用于提取字符串中介于两个指定下标之间的字符 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.substring(3))&lt;/script&gt;输出：lo world! charAt(): 可返回指定位置的字符。请注意，JavaScript 并没有一种有别于字符串类型的字符数据类型，所以返回的字符是长度为 1 的字符串。 12345678&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;Hello world!&quot;document.write(str.charAt(1))&lt;/script&gt;输出：e split(): 用于把一个字符串分割成字符串数组12345678910111213&lt;script type=&quot;text/javascript&quot;&gt;var str=&quot;How are you doing today?&quot;document.write(str.split(&quot; &quot;) + &quot;&lt;br /&gt;&quot;)document.write(str.split(&quot;&quot;) + &quot;&lt;br /&gt;&quot;)document.write(str.split(&quot; &quot;,3))&lt;/script&gt;输出：How,are,you,doing,today?H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?How,are,you 数组对象 join() 方法用于把数组中的所有元素放入一个字符串,元素是通过指定的分隔符进行分隔的。 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr.join())&lt;/script&gt;输出：George,John,Thomas slice() 方法可从已有的数组中返回选定的元素。 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.slice(1) + &quot;&lt;br /&gt;&quot;)document.write(arr)&lt;/script&gt;输出：George,John,ThomasJohn,ThomasGeorge,John,Thomas concat() 方法用于连接两个或多个数组。 12345678&lt;script type=&quot;text/javascript&quot;&gt;var a = [1,2,3];document.write(a.concat(4,5));&lt;/script&gt;输出：1,2,3,4,5 pop() 方法用于删除并返回数组的最后一个元素。 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr)document.write(&quot;&lt;br /&gt;&quot;)document.write(arr.pop())document.write(&quot;&lt;br /&gt;&quot;)document.write(arr)&lt;/script&gt;输出：George,John,ThomasThomasGeorge,John push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.push(&quot;James&quot;) + &quot;&lt;br /&gt;&quot;)document.write(arr)&lt;/script&gt;输出：George,John,Thomas4George,John,Thomas,James reverse() 方法用于颠倒数组中元素的顺序。 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.reverse())&lt;/script&gt;输出：George,John,ThomasThomas,John,George shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(3)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)document.write(arr.shift() + &quot;&lt;br /&gt;&quot;)document.write(arr)&lt;/script&gt;输出：George,John,ThomasGeorgeJohn,Thomas splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt;var arr = new Array(6)arr[0] = &quot;George&quot;arr[1] = &quot;John&quot;arr[2] = &quot;Thomas&quot;arr[3] = &quot;James&quot;arr[4] = &quot;Adrew&quot;arr[5] = &quot;Martin&quot;document.write(arr + &quot;&lt;br /&gt;&quot;)arr.splice(2,0,&quot;William&quot;)document.write(arr + &quot;&lt;br /&gt;&quot;)&lt;/script&gt;输出：George,John,Thomas,James,Adrew,MartinGeorge,John,William,Thomas,James,Adrew,Martin]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>js基础理论知识</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础]]></title>
    <url>%2F2016%2F07%2F13%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[面向对象铺垫-对象创建方式总结第一种：创建对象的方式，json方式123456789101112131415161718//推荐使用的场合： 作为函数的参数，临时只用一次的场景。比如设置函数原型对象。var obj = &#123;&#125;;//对象有自己的 属性 和 行为// 属性比如： 年龄、姓名、性别// 行为： 吃饭、睡觉、走路、讲课等... 动作var obj2 = &#123; name: &apos;laoma&apos;, age: 18, sayHi: function()&#123; console.log( name + &apos;say hi&apos; ); &#125;&#125;;//添加其他属性：obj2.newProp = 123;// js的动态特性，如果没有要访问的属性，直接添加属性。// 缺点： 不能作为对象创建的模板，也就是不能用new进行构造新对象。//================================================= 第二种： 创建面向对象的方式： new Object()的方式。 不推荐使用。12345678var obj3 = new Object();//添加属性obj3.name = &apos;kitty&apos;;obj3.sayHi = function() &#123; console.log( name + &apos; &apos; + &apos;say hi&apos;);&#125;;//跟上面的方式一样，只能临时用一下这个对象，不想作为new的构造模板是可以的。 第三种： 构造函数构造对象方法12345678910111213141516171819202122//把 一个函数对象 当做构造函数来使用，一般要把 函数对象的首字母大写function Persion() &#123; this.name = &apos;123&apos;; // 通过this可以直接给 构造出来的对象添加属性。 this.sayHi = function() &#123; console.log( this.name ); &#125;;&#125; var p = new Persion(); //** new 运算符的作用：// 第一步：// 执行构造函数（new后面的那个函数），在构//造函数内部创建一个空对象，// 第二步： 把上面的空对象跟构造函数的原型对象进行关联。// 第三步：然后把this 指向当前空对象//在构造函数执行结束后，把空对象返回 给 pconsole.log( p.name ); //p.name 从构造函数里面创建的。p.sayHi(); //在此方法内部的 this执行 p对象。//绘制原型 和 构造函数 和对象之间的关系。 第三种方式的升级改造版本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//第三种方式有个缺点： 对象的内部的函数会在每个对象中都存一份//如果创建的对象非常多的话，那么非常浪费内存。函数的行为是所有对象//可以共有，不需要每个对象都保存一份。所以，可以把函数放到原型中//进行声明，那么所有对象都有了公共的函数，而且内存中只保留一份。//所有的属性写到对象的内部//第三种的升级版：function Sprite() &#123; this.name = &apos;123&apos;; this.age = 19;&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function() &#123; &#125;&#125;;//继续升级： 把属性的设置做成参数化：function Sprite( sname, sage ) &#123; this.name = sname || &apos;&apos;; this.age = sage || 18;&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function() &#123; &#125;&#125;;//问题： 1、调用者如果传递参数的顺序发生变化，那么废了//问题： 2、 参数增减都会导致函数声明变化，调用的地方也可能发生变化。//如何解决：继续升级function Sprite( option ) &#123; //我用一个对象把所有参数覆盖。灵活性就很强了。 //顺序无所谓，添加参数也无所谓了。 this.name = option.sname || &apos;&apos;; this.age = option.sage || 18;&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function() &#123; &#125;&#125;;//继续优化，把初始化的代码 放到init函数中function Sprite( option ) &#123; //我用一个对象把所有参数覆盖。灵活性就很强了。 //顺序无所谓，添加参数也无所谓了。 this.init( option );&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function( option ) &#123; this.name = option.sname || &apos;&apos;; this.age = option.sage || 18; &#125;&#125;;//以后的canvas课程的开发暂时先用这种的方式 补充js方法调用的四种模式 方法调用模式 12345678910111213141516function Persion() &#123; var name1 = &quot;itcast&quot;, age1 = 19, show1 = function() &#123; console.log(this.name); &#125;; return &#123; age : age1, name : name1, show : show1 &#125;;&#125;var p = new Persion();p.show(); //在show方法中的this指向了p对象。 函数调用模式 1234567function add( a, b) &#123; this.result = a + b;&#125;add( 3, 9 ); //此方法执行的时候，this指向了windowconsole.log(result); 构造器调用模式 12345678910function Persion（）&#123; this.name = &quot;123&quot;; this.age = 19; this.show = function()&#123; console.log(this.name); &#125;;&#125;var p = new Persion();p.show();// 在show方法中方法this，指向了p对象实例。 call 和 apply调用模式 123456789function add(a,b)&#123; this.result = a + b;s &#125;var p = &#123;&#125;; //定义一个空对象。add.call(p,3,4); //在这个方法调用的时候，this指向了pconsole.log(p.result);//apply和call是一样的用法，只不过apply第二个参数用数组进行传递。 变量提升：函数执行之前，会先将函数中所有的变量，挪到最前面去声明。 函数名提升： script中脚本，在执行之前，会先把脚本中的所有的函数先进行编译解析，然后执行普通的js代码。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 class的继承]]></title>
    <url>%2F2016%2F07%2F10%2FES6%20class%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[1.简介Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。12345class Point &#123;&#125;class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + &apos; &apos; + super.toString(); // 调用父类的toString() &#125;&#125; 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。12345678class Point &#123; /* ... */ &#125;class ColorPoint extends Point &#123; constructor() &#123; &#125;&#125;let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。123456789class ColorPoint extends Point &#123;&#125;// 等同于class ColorPoint extends Point &#123; constructor(...args) &#123; super(...args); &#125;&#125; 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 &#125;&#125; 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。1234let cp = new ColorPoint(25, 8, &apos;green&apos;);cp instanceof ColorPoint // truecp instanceof Point // true 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。 最后，父类的静态方法，也会被子类继承。12345678910class A &#123; static hello() &#123; console.log(&apos;hello world&apos;); &#125;&#125;class B extends A &#123;&#125;B.hello() // hello world 上面代码中，hello()是A类的静态方法，B继承A，也继承了A的静态方法。12345# 2. Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 3.super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。1234567class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125; 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。123456789101112class A &#123; constructor() &#123; console.log(new.target.name); &#125;&#125;class B extends A &#123; constructor() &#123; super(); &#125;&#125;new A() // Anew B() // B 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。1234567class A &#123;&#125;class B extends A &#123; m() &#123; super(); // 报错 &#125;&#125; 上面代码中，super()用在B类的m方法之中，就会造成句法错误。 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。1234567891011121314class A &#123; p() &#123; return 2; &#125;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.p()); // 2 &#125;&#125;let b = new B(); 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。1234567891011121314class A &#123; constructor() &#123; this.p = 2; &#125;&#125;class B extends A &#123; get m() &#123; return super.p; &#125;&#125;let b = new B();b.m // undefined 上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。1234567891011class A &#123;&#125;A.prototype.x = 2;class B extends A &#123; constructor() &#123; super(); console.log(super.x) // 2 &#125;&#125;let b = new B(); 上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。123456789101112131415161718192021222324class Parent &#123; static myMethod(msg) &#123; console.log(&apos;static&apos;, msg); &#125; myMethod(msg) &#123; console.log(&apos;instance&apos;, msg); &#125;&#125;class Child extends Parent &#123; static myMethod(msg) &#123; super.myMethod(msg); &#125; myMethod(msg) &#123; super.myMethod(msg); &#125;&#125;Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 2 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; static print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; static m() &#123; super.print(); &#125;&#125;B.x = 3;B.m() // 3 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。12345678class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super); // 报错 &#125;&#125; 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。12345678910class A &#123;&#125;class B extends A &#123; constructor() &#123; super(); console.log(super.valueOf() instanceof B); // true &#125;&#125;let b = new B(); 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super使得this指向B的实例，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。1234567var obj = &#123; toString() &#123; return &quot;MyObject: &quot; + super.toString(); &#125;&#125;;obj.toString(); // MyObject: [object Object] 4.类的 prototype 属性和proto属性大多数浏览器的 ES5 实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上面代码中，子类B的proto属性指向父类A，子类B的prototype属性的proto属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。12345678910111213class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。1234Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 因此，就得到了上面的结果。1234567Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（proto属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。12345678Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype;extends 的继承目标extends关键字后面可以跟多种类型的值。class B extends A &#123;&#125; 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论三种特殊情况。 第一种特殊情况，子类继承Object类。12345class A extends Object &#123;&#125;A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种特殊情况，不存在任何继承。12345class A &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.proto指向构造函数（Object）的prototype属性。 第三种特殊情况，子类继承null。12345class A extends null &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === undefined // true 这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回的对象不继承任何方法，所以它的proto指向Function.prototype，即实质上执行了下面的代码。123class C extends null &#123; constructor() &#123; return Object.create(null); &#125;&#125; 实例的 proto 属性子类实例的proto属性的proto属性，指向父类实例的proto属性。也就是说，子类的原型的原型，是父类的原型。12345var p1 = new Point(2, 3);var p2 = new ColorPoint(2, 3, &apos;red&apos;);p2.__proto__ === p1.__proto__ // falsep2.__proto__.__proto__ === p1.__proto__ // true 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的proto.proto属性，可以修改父类实例的行为。12345p2.__proto__.__proto__.printName = function () &#123; console.log(&apos;Ha&apos;);&#125;;p1.printName() // &quot;Ha&quot; 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 5.原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript 的原生构造函数大致有下面这些。 Boolean()Number()String()Array()Date()Function()RegExp()Error()Object()以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。123456789101112function MyArray() &#123; Array.apply(this, arguments);&#125;MyArray.prototype = Object.create(Array.prototype, &#123; constructor: &#123; value: MyArray, writable: true, configurable: true, enumerable: true &#125;&#125;); 上面代码定义了一个继承 Array 的MyArray类。但是，这个类的行为与Array完全不一致。123456var colors = new MyArray();colors[0] = &quot;red&quot;;colors.length // 0colors.length = 0;colors[0] // &quot;red&quot; 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 下面的例子中，我们想让一个普通对象继承Error对象。1234567var e = &#123;&#125;;Object.getOwnPropertyNames(Error.call(e))// [ &apos;stack&apos; ]Object.getOwnPropertyNames(e)// [] 上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。123456789101112class MyArray extends Array &#123; constructor(...args) &#123; super(...args); &#125;&#125;var arr = new MyArray();arr[0] = 12;arr.length // 1arr.length = 0;arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6 可以自定义原生数据结构（比如Array、String等）的子类，这是 ES5 无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。1234567891011121314151617181920212223242526272829class VersionedArray extends Array &#123; constructor() &#123; super(); this.history = [[]]; &#125; commit() &#123; this.history.push(this.slice()); &#125; revert() &#123; this.splice(0, this.length, ...this.history[this.history.length - 1]); &#125;&#125;var x = new VersionedArray();x.push(1);x.push(2);x // [1, 2]x.history // [[]]x.commit();x.history // [[], [1, 2]]x.push(3);x // [1, 2, 3]x.history // [[], [1, 2]]x.revert();x // [1, 2] 上面代码中，VersionedArray会通过commit方法，将自己的当前状态生成一个版本快照，存入history属性。revert方法用来将数组重置为最新一次保存的版本。除此之外，VersionedArray依然是一个普通数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子，可以用来定制报错时的行为。1234567891011121314151617181920212223class ExtendableError extends Error &#123; constructor(message) &#123; super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; &#125;&#125;class MyError extends ExtendableError &#123; constructor(m) &#123; super(m); &#125;&#125;var myerror = new MyError(&apos;ll&apos;);myerror.message // &quot;ll&quot;myerror instanceof Error // truemyerror.name // &quot;MyError&quot;myerror.stack// Error// at MyError.ExtendableError// ... 注意，继承Object的子类，有一个行为差异。1234567class NewObj extends Object&#123; constructor()&#123; super(...arguments); &#125;&#125;var o = new NewObj(&#123;attr: true&#125;);o.attr === true // false 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为 ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数。 6.Mixin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。1234567const a = &#123; a: &apos;a&apos;&#125;;const b = &#123; b: &apos;b&apos;&#125;;const c = &#123;...a, ...b&#125;; // &#123;a: &apos;a&apos;, b: &apos;b&apos;&#125; 上面代码中，c对象是a对象和b对象的合成，具有两者的接口。 下面是一个更完备的实现，将多个类的接口“混入”（mix in）另一个类。12345678910111213141516171819202122function mix(...mixins) &#123; class Mix &#123;&#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝实例属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125; 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。123class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>class关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 class的基本语法]]></title>
    <url>%2F2016%2F07%2F05%2FES6%20class%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。123456class Point &#123; // ...&#125;typeof Point // &quot;function&quot;Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。12345678class Bar &#123; doStuff() &#123; console.log(&apos;stuff&apos;); &#125;&#125;var b = new Bar();b.doStuff() // &quot;stuff&quot; 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。123456789101112131415161718192021class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 Point.prototype.constructor === Point // true另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。123456789101112var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [&quot;toString&quot;]Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;] 上面代码采用 ES5 的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。1234567891011let methodName = &apos;getArea&apos;;class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 上面代码中，Square类的方法名getArea，是从表达式得到的。 严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without &apos;new&apos; 类的实例对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&apos;x&apos;) // truepoint.hasOwnProperty(&apos;y&apos;) // truepoint.hasOwnProperty(&apos;toString&apos;) // falsepoint.__proto__.hasOwnProperty(&apos;toString&apos;) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以proto属性是相等的。 这也意味着，可以通过实例的proto属性为“类”添加方法。 proto 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return &apos;Oops&apos; &#125;;p1.printName() // &quot;Oops&quot;p2.printName() // &quot;Oops&quot;var p3 = new Point(4,2);p3.printName() // &quot;Oops&quot; 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 Class 表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ };采用 Class 表达式，可以写出立即执行的 Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;);person.sayName(); // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 私有方法和私有属性现有的方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。1234567891011121314151617const bar = Symbol(&apos;bar&apos;);const snaf = Symbol(&apos;snaf&apos;);export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 私有属性的提案与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。12345678910class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get x() &#123; return #x &#125; set x(value) &#123; #x = +value &#125;&#125; 上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。 私有属性可以指定初始值，在构造函数执行时进行初始化。123456class Point &#123; #x = 0; constructor() &#123; #x; // 0 &#125;&#125; 之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。1234567class Foo &#123; #a; #b; #sum() &#123; return #a + #b; &#125; printSum() &#123; console.log(#sum()); &#125; constructor(a, b) &#123; #a = a; #b = b; &#125;&#125; 上面代码中，#sum()就是一个私有方法。 另外，私有属性也可以设置 getter 和 setter 方法。12345678910111213class Counter &#123; #xValue = 0; get #x() &#123; return #xValue; &#125; set #x(value) &#123; this.#xValue = value; &#125; constructor() &#123; super(); // ... &#125;&#125; 上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。12345678910111213class Logger &#123; printName(name = &apos;there&apos;) &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &apos;print&apos; of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。123456789class Logger &#123; constructor() &#123; this.printName = (name = &apos;there&apos;) =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== &apos;function&apos;) &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。12class Point &#123;&#125;Point.name // &quot;Point&quot; name属性总是返回紧跟在class关键字后面的类名。 Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// &apos;getter&apos; 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的 Descriptor 对象上的。1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, &quot;html&quot;);&quot;get&quot; in descriptor // true&quot;set&quot; in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。 Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。1234567891011class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log(&apos;hello&apos;); &#125; baz () &#123; console.log(&apos;world&apos;); &#125;&#125;Foo.bar() // hello 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。 父类的静态方法，可以被子类继承。12345678910class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // &apos;hello&apos; 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。12345678910111213class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + &apos;, too&apos;; &#125;&#125;Bar.classMethod() // &quot;hello, too&quot; Class 的静态属性和实例属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。 ###（1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。1234567class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 &#125;&#125; 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。12345678class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; 上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。12345class ReactCounter extends React.Component &#123; state = &#123; count: 0 &#125;;&#125; 这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。123456789class ReactCounter extends React.Component &#123; state; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; （2）类的静态属性类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。1234567class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; 同样的，这个新写法大大方便了静态属性的表达。12345678910// 老写法class Foo &#123; // ...&#125;Foo.prop = 1;// 新写法class Foo &#123; static prop = 1;&#125; 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;var person = new Person(&apos;张三&apos;); // 正确var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 上面代码确保构造函数只能通过new命令调用。 Class 内部调用new.target，返回当前 Class。123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error(&apos;本类不能实例化&apos;); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>class关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[konva节选]]></title>
    <url>%2F2016%2F06%2F27%2FKonva%E8%8A%82%E9%80%89%2F</url>
    <content type="text"><![CDATA[形状/Shape矩形/Rect矩形的创建： var rect = new Konva.Rect({ // 定位属性，左上宽高 x: 50, y: 50, width: 100, height: 50, // 样式属性 fill: &apos;green&apos;, // 填充色 stroke: &apos;black&apos;, // 描边色 strokeWidth: 4 // 描边宽度 }); 线/Line线的创建： var redLine = new Konva.Line({ // 定位属性，每两个数值决定一个点 points: [5, 70, 140, 23, 250, 60, 300, 20], // 样式属性 stroke: &apos;red&apos;, strokeWidth: 15, lineCap: &apos;round&apos;, // 即线条的起点和终点的样式 lineJoin: &apos;round&apos;, // 每个折点的样式 dash: [33, 10], // 虚线样式，这里指每隔33个单位，有10个单位的间隔 // 闭合，可以用于绘制不规则多边形 fill: &apos;#00D2FF&apos;, closed : true, // 平滑度 越低过渡越平滑 tension : 1, }); 图片/Imagevar img = new Konva.Image({ // 定位属性 x: 50, y: 50, width: 106, height: 118, // 资源属性 接收一个Image对象（标签） image: imageObj, }); 文字/Textvar simpleText = new Konva.Text({ // 定位属性 x: stage.getWidth() / 2, y: 15, // 文本内容 text: &apos;Simple Text&apos;, // 字体样式 fontSize: 30, // 字体大小 fontFamily: &apos;Calibri&apos;, // 字体 fill: &apos;green&apos; // 填充颜色 }); 事件/Event绑定事件obj.on(&apos;click&apos;, function() { ... }); obj.on(&apos;tap.s&apos;, function() { ... }); 移除事件obj.off(&apos;click&apos;) obj.off(&apos;.s&apos;) 判定区域形状可以为hitFunc属性添加一个函数，用于自定义一个形状的点击判定区域。 hitFunc: function(context) { context.beginPath(); context.arc(0, 0, this.getOuterRadius() + 10, 0, Math.PI * 2, true); context.closePath(); context.fillStrokeShape(this); } 动画Tween动画创建var tween = new Konva.Tween({ node: rect, // 目标节点 duration: 1, // 动画时间 // 结束时的属性 x: 140, y: 90, fill : &apos;red&apos;, rotation: Math.PI * 2, opacity: 1, strokeWidth: 6, scaleX: 1.5， // 动画结束时的回调 onFinish:finishFn }); 控制tween对象自带六种方法，用于控制动画播放： play()播放, pause()暂停, reverse()反转, reset()重置, finish()结束 Animation动画创建Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间。 var anim = new Konva.Animation(function(frame) { var time = frame.time, // 动画执行的总时间 timeDiff = frame.timeDiff, // 距离上一帧的时间 frameRate = frame.frameRate; // 帧率（既1000/间隔时间） // update stuff }, layer); anim.start(); 控制animation对象提供start()和stop()两个方法。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>konva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6编程风格]]></title>
    <url>%2F2016%2F06%2F22%2FECMAScript6%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[1.块级作用域（1）let 取代 varES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。123456&apos;use strict&apos;;if (true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 （2）全局常量和线程安全在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 2.字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 3.解构赋值使用数组成员对变量赋值时，优先使用解构赋值。12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 4.对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 5.数组使用扩展运算符（…）拷贝数组。1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用 Array.from 方法，将类似数组的对象转为数组。12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 6.函数立即执行函数可以写成箭头函数的形式。123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7.Map 结构注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; 8.Class总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9.模块首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。12345// badimport * as myObject from &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; 10.ESLint 的使用ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装 ESLint。 $ npm i -g eslint然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。12$ npm i -g eslint-config-airbnb$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用 ESLint 检查这个文件，就会报出错误。123456789$ eslint index.jsindex.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 4:5 error Unexpected var, use let or const instead no-var 5:5 error Expected indentation of 2 characters but found 4 indent✖ 5 problems (5 errors, 0 warnings) 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas基础笔记]]></title>
    <url>%2F2016%2F06%2F12%2Fcanvas%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、canvas简介1.1 什么是canvas？ 是HTML5提供的一种新标签 Canvas是一个矩形区域的画布，可以用JavaScript在上面绘画。控制其每一个像素。 canvas 标签使用 JavaScript 在网页上绘制图像，本身不具备绘图功能。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 HTML5之前的web页面只能用一些固定样式的标签：比如p、div、h1等 1.2 canvas主要应用的领域 游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。 25 超棒的 HTML5 Canvas 游戏 可视化数据.数据图表话，比如:百度的echart banner广告：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。 未来=&gt; 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。 未来=&gt; 远程计算机控制：Canvas可以让开发者更好地实现基于Web的数据传输，构建一个完美的可视化控制界面。 未来=&gt; 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。 其他可嵌入网站的内容(多用于活动页面、特效)：类似图表、音频、视频，还有许多元素能够更好地与Web融合，并且不需要任何插件。 完整的canvas移动化应用 目标 我们不是主要做游戏开发的 要求必须会做基本的用canvas绘制的特效页面： 会用canvas做一些简单的广告、活动页面 案例和项目演示 canvas的标准： 最新标准：http://www.w3.org/TR/2dcontext/ 稳定版本的标准：http://www.w3.org/TR/2013/CR-2dcontext-20130806/ 目前来说，标准还在完善中。先用早期的api足够完成所有的应用二、canvas绘图基础 2.0 sublime配置canvas插件推荐： 安装插件：AndyJS2 github地址： https://github.com/malun666/AndyJS2 直接下载到：X:\Users\用户名\AppData\Roaming\Sublime Text 3\Packages 2.1 Canvas标签2.1.1 canvas标签语法和属性 （重点） canvas：画布油布的意思 ==英 [‘kænvəs] 美 [‘kænvəs] == 标签名canvas，需要进行闭合。就是一普通的html标签。 可以设置width和height属性，但是属性值单位必须是px，否则忽略。 width和hegiht：默认300*150像素 注意： 不要用CSS控制它的宽和高,会走出图片拉伸， 重新设置canvas标签的宽高属性会让画布擦除所有的内容。 可以给canvas画布设置背景色 2.1.2 浏览器不兼容处理（重点） ie9以上才支持canvas, 其他chrome、ff、苹果浏览器等都支持 只要浏览器兼容canvas，那么就会支持绝大部分api(个别最新api除外) 移动端的兼容情况非常理想，基本上随便使用 2d的支持的都非常好，3d（webgl）ie11才支持，其他都支持 如果浏览器不兼容，最好进行友好提示 1234例如： &lt;canvas id=&quot;cavsElem&quot;&gt; 你的浏览器不支持canvas，请升级浏览器.浏览器不支持，显示此行文本&lt;/canvas&gt; 浏览器不兼容，可以使用flash等手段进行优雅降级 2.2 canvas绘图上下文context2.2.1 Context：Canvas的上下文、绘制环境。（重点掌握） 上下文：上知天文，下知地理。是所有的绘制操作api的入口或者集合。 Canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。 Context对象就是JavaScript操作Canvas的接口。*使用[CanvasElement].getContext(‘2d’)来获取2D绘图上下文。 12var canvas = document.getElementById( &apos;cavsElem&apos; ); //获得画布var ctx = canvas.getContext( &apos;2d&apos; );//注意：2d小写， 3d：webgl 2.3 基本的绘制路径（重点）2.3.1 canvas坐标系canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大 2.3.2 设置绘制起点(moveTo)* 语法：ctx.moveTo(x, y); * 解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置 * 参数：x,y 都是相对于 canvas盒子的最左上角。 * 注意：**绘制线段前必须先设置起点。** 2.3.3 绘制直线(lineTo)* 语法：ctx.lineTo(x, y); * 解释：从x,y的位置绘制一条直线到起点或者上一个线头点。 * 参数：x,y 线头点坐标。 2.3.4 路径开始和闭合* 开始路径：ctx.beginPath(); * 闭合路径：ctx.closePath(); * 解释：如果是绘制不同状态的线段或者形状，必须使用开始新路径的方法把不同的绘制操作隔开。闭合路径会自动把最后的线头和开始的线头连在一起。 * beginPath: 核心的作用是将 不同绘制的形状进行隔离， 每次执行此方法，表示重新绘制一个路径,跟之前的绘制的墨迹可以进行分开样式设置和管理。 2.3.5 描边(stroke)* 语法：ctx.stroke(); * 解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行stroke * stroke: （用笔等）画；轻抚；轻挪；敲击；划尾桨；划掉；（打字时）击打键盘 英 [strəʊk] 美 [strok] canvas绘制的基本步骤： 第一步：获得上下文 =&gt;canvasElem.getContext(‘2d’); 第二步：开始路径规划 =&gt;ctx.beginPath() 第三步：移动起始点 =&gt;ctx.moveTo(x, y) 第四步：绘制线(矩形、圆形、图片…) =&gt;ctx.lineTo(x, y) 第五步：闭合路径 =&gt;ctx.closePath(); 第六步：绘制描边 =&gt;ctx.stroke();1234567891011121314151617181920212223html部分： &lt;canvas id=&quot;cavsElem&quot;&gt; 你的浏览器不支持canvas，请升级浏览器 &lt;/canvas&gt;javascript部分：//===============基本绘制api====================//获得画布var canvas = document.querySelector(&apos;#cavsElem&apos;);var ctx = canvas.getContext(&apos;2d&apos;); //获得上下文canvas.width = 900; //设置标签的属性宽高canvas.height = 600; //千万不要用 canvas.style.heightcanvas.style.border = &quot;1px solid #000&quot;;//绘制三角形ctx.beginPath(); //开始路径ctx.moveTo(100,100); //三角形，左顶点ctx.lineTo(300, 100); //右顶点ctx.lineTo(300, 300); //底部的点ctx.closePath(); //结束路径ctx.stroke(); //描边路径 综合案例：02绘制定位表格.html 综合案例：03画画板.html 2.3.7 填充(fill)* 语法：ctx.fill(); * 解释：填充，是将闭合的路径的内容填充具体的颜色。默认黑色。 * 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。 以下是非0环绕原则的原理：（了解即可，非常少会用到复杂的路径） “非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段， 使此线段的终点完全落在路径范围之外。 图2-14中的那三个箭头所描述的就是上面这个步骤。 接下来，将计数器初始化为0， 然后，每当这条线段与路径上的直线或曲线相交时， 就改变计数器的值。如果是与路径的顺时针部分相交，则加1， 如果是与路径的逆时针部分相交，则减1。若计数器的最终值不是0，那么此区域就在路径里面，在调用fill()方法时， 浏览器就会对其进行填充。 如果最终值是0，那么此区域就不在路径内部，浏览器也就不会对其进行填充了 * 案例： 04填充矩形.html 2.3.8 快速创建矩形rect()方法* 语法：ctx.rect(x, y, width, height); * 解释：x, y是矩形左上角坐标， width和height都是以像素计 * rect方法只是规划了矩形的路径，并没有填充和描边。 * 改造案例：04填充矩形.html *rect: abbr. 矩形（rectangular）；收据（receipt） 2.3.9 快速创建描边矩形和填充矩形* 语法： ctx.strokeRect(x, y, width, height); - 参数跟2.3.8相同，注意此方法绘制完路径后立即进行stroke绘制 * 语法：ctx.fillRect(x, y, width, height); - 参数跟2.3.8相同， 此方法执行完成后。立即对当前矩形进行fill填充。 2.3.10 清除矩形(clearRect)* 语法：ctx.clearRect(x, y, width, hegiht); * 解释：清除某个矩形内的绘制的内容，相当于橡皮擦。 2.4 绘制圆形（arc) 概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。 语法：ctx.arc(x,y,r,sAngle,eAngle,counterclockwise); arc: 弧（度）弧形物；天穹 英 [ɑːk] 美 [ɑrk] counter 反击，还击；反向移动，对着干；反驳，回答 [‘kaʊntə] 美 [‘kaʊntɚ] 解释： x,y：圆心坐标。 r：半径大小。 sAngle:绘制开始的角度。 圆心到最右边点是0度，顺时针方向弧度增大。 eAngel:结束的角度，注意是弧度。π counterclockwise：是否是逆时针。true是逆时针，false：顺时针 弧度和角度的转换公式： rad = deg*Math.PI/180; 在Math提供的方法中sin、cos等都使用的弧度 案例：05绘制圆形.html 案例：06绘制饼状图.html 2.5 绘制文字（会使用就可以了）2.5.1 绘制上下文的文字属性 （有印象就行了） font 设置或返回文本内容的当前字体属性 font 属性使用的语法与 CSS font 属性相同。1例如：ctx.font = &quot;18px &apos;微软雅黑&apos;&quot;; textAlign 设置或返回文本内容的当前对齐方式 start : 默认。文本在指定的位置开始。 end : 文本在指定的位置结束。 center: 文本的中心被放置在指定的位置。 left : 文本左对齐。 right : 文本右对齐。 1* 例如：ctx.textAlign = &apos;left&apos;; textBaseline 设置或返回在绘制文本时使用的当前文本基线 alphabetic ： 默认。文本基线是普通的字母基线。 top ： 文本基线是 em 方框的顶端。。 hanging ： 文本基线是悬挂基线。 middle ： 文本基线是 em 方框的正中。 ideographic： 文本基线是em基线。 bottom ： 文本基线是 em 方框的底端。 1例如： ctx.textBaseline = &apos;top&apos;; 2.5.2 上下文绘制文字方法* ctx.fillText() 在画布上绘制“被填充的”文本 * ctx.strokeText() 在画布上绘制文本（无填充） * ctx.measureText() 返回包含指定文本宽度的对象 12345678//综合案例代码：ctx.moveTo( 300, 300 );ctx.fillStyle = &quot;purple&quot;; //设置填充颜色为紫色ctx.font = &apos;20px &quot;微软雅黑&quot;&apos;; //设置字体ctx.textBaseline = &quot;bottom&quot;; //设置字体底线对齐绘制基线ctx.textAlign = &quot;left&quot;; //设置字体对齐的方式//ctx.strokeText( &quot;left&quot;, 450, 400 );ctx.fillText( &quot;Top-g&quot;, 100, 300 ); //填充文字 2.5.3 案例07文字绘制.html 2.6 绘制图片（drawImage） （重点）2.6.1 基本绘制图片的方式context.drawImage(img,x,y); 参数说明： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。 2.6.2 在画布上绘制图像，并规定图像的宽度和高度context.drawImage(img,x,y,width,height); 参数说明：width 绘制图片的宽度， height：绘制图片的高度 如果指定宽高，最好成比例，不然图片会被拉伸&lt;/em&gt; 等比公式： toH = Height * toW / Width; //等比 设置高 = 原高度 * 设置宽/ 原宽度; 2.6.3 图片裁剪，并在画布上定位被剪切的部分context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数说明： sx,sy 裁剪的左上角坐标， swidth：裁剪图片的高度。 sheight:裁剪的高度 其他同上 2.6.4 用JavaScript创建img对象第一种方式： var img = document.getElementById(&quot;imgId&quot;); 第二种方式： var img = new Image();//这个就是 img标签的dom对象 img.src = &quot;imgs/arc.gif&quot;; img.alt = &quot;文本信息&quot;; img.onload = function() { //图片加载完成后，执行此方法 } 2.6.5 面向对象基础复习补充： 创建对象的方式： 123* var o = &#123; name: &apos;123&apos;, age: 18 &#125;; //json方式创建* var o = new Object(); //通过new的方式创建* var o = new Persion(); //通过类的构造函数创建 JS中对象的属性创建方式 12345* json的方式： var o = &#123; age: 19 &#125;;* 直接添加属性：var o = &#123;&#125;; o.age = 19;//太分散了，不利于管理* 由于js动态语言的特性，如果属性不存在的时候，直接添加属性。* 构造函数添加属性* 原型添加公共的属性 JS的构造函数的原型 构造函数的原型就是：构造对象的模板，构造函数原型里面的所有的属性和方法都会共享给所有的 构造函数构造出来的所有实例。 案例： 08绘制图片.html 案例： 09绘制图片裁剪.html 案例： 10序列帧动画.html 案例： 11面向对象版本的动画帧.html 重点 2.6.6 补充 sublime制作代码段（推荐–已结讲过了）第一步：sublime菜单栏→ 工具 → 制作代码段 第二步：修改输出的sublime代码段文本 &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ 1、这里放要tab键 输出的内容 2、 ${1:this} 占位符，tab可以进行切换，数字是切换的索引。 ：后面的是默认的文本。 ]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;简写的字母&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt; &lt;/snippet&gt; 第三步：保存到插件的文件夹中，后缀名为：.sublime-snippet比如我存放的位置： C:\Users\malunmac\AppData\Roaming\Sublime Text 3\Packages\User\snippetssnippets是我自己新建的文件夹。 三、 canvas进阶3.1 Canvas颜色样式和阴影3.1.1 设置填充和描边的颜色（掌握） fillStyle : 设置或返回用于填充绘画的颜色 strokeStyle: 设置或返回用于笔触的颜色 以上两个值都可以接受颜色名,16进制数据，rgb值，甚至rgba.一般先进行设置样式然后进行绘制。 例如： ctx.strokeStyle = &quot;red&quot;; ctx.strokeStyle = &quot;#ccc&quot;; ctx.strokeStyle = &quot;rgb(255,0,0)&quot;; ctx.strokeStyle = &quot;rgba(255,0,0,6)&quot;; 3.1.2 设置阴影（了解，少用，性能差） 类比于CSS3的阴影。 shadowColor ： 设置或返回用于阴影的颜色 shadowBlur ： 设置或返回用于阴影的模糊级别,大于1的正整数，数值越高，模糊程度越大 shadowOffsetX： 设置或返回阴影距形状的水平距离 shadowOffsetY： 设置或返回阴影距形状的垂直距离 123456ctx.fillStyle = &quot;rgba(255,0,0, .9)&quot;ctx.shadowColor = &quot;teal&quot;;ctx.shadowBlur = 10;ctx.shadowOffsetX = 10;ctx.shadowOffsetY = 10;ctx.fillRect(100, 100, 100, 100); 例如： 案例： 12设置box盒子阴影.html 设置png图片的阴影，图片透明部分不会被投影。 3.2 复杂样式（了解）3.2.1 创建线性渐变的样式（了解） 一般不用，都是用图片代替，canvas绘制图片效率更高。 线性渐变可以用于 矩形、圆形、文字等颜色样式 线性渐变是一个对象 语法：ctx.createLinearGradient(x0,y0,x1,y1); //参数：x0,y0起始坐标，x1,y1结束坐标123456例如：//创建线性渐变的对象，var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,&quot;black&quot;); //添加一个渐变颜色，第一个参数介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。grd.addColorStop(1,&quot;white&quot;); //添加一个渐变颜色ctx.fillStyle =grd; //关键点，把渐变设置到 填充的样式 案例13设置线性渐变.html 3.2.2 设置圆形渐变（径向渐变） 了解 创建放射状/圆形渐变对象。可以填充文本、形状等 context.createRadialGradient(x0,y0,r0,x1,y1,r1); radial 半径的；放射状的；光线的；光线状的 英 [‘reɪdɪəl] 美 [‘redɪəl] 参数详解： x0: 渐变的开始圆的 x 坐标 y0: 渐变的开始圆的 y 坐标 r0: 开始圆的半径 x1: 渐变的结束圆的 x 坐标 y1: 渐变的结束圆的 y 坐标 r1: 结束圆的半径123456var rlg = ctx.createRadialGradient(300,300,10,300,300,200);rlg.addColorStop(0, &apos;teal&apos;); //添加一个渐变颜色rlg.addColorStop(.4, &apos;navy&apos;);rlg.addColorStop(1, &apos;purple&apos;);ctx.fillStyle = rlg;//设置 填充样式为延续渐变的样式ctx.fillRect(100, 100, 500, 500); 案例14圆形渐变.html 3.2.3 绘制背景图（了解） ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解 pattern：n. 模式；图案；样品 英 [‘pæt(ə)n] 美 [‘pætɚn] 第一参数：设置平铺背景的图片，第二个背景平铺的方式。 image ： 规定要使用的图片、画布或视频元素。 repeat ： 默认。该模式在水平和垂直方向重复。 repeat-x ： 该模式只在水平方向重复。 repeat-y ： 该模式只在垂直方向重复。 no-repeat： 该模式只显示一次（不重复）。123456var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;lamp&quot;);var pat=ctx.createPattern(img,&quot;repeat&quot;);ctx.rect(0,0,150,100);ctx.fillStyle=pat;// 把背景图设置给填充的样式ctx.fill(); 案例15背景图填充.html 3.3 变换（重点）3.3.1 缩放（重点） scale() 方法缩放当前绘图，更大或更小 语法：context.scale(scalewidth,scaleheight) scalewidth : 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight : 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.)+注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。 案例16缩放案例.html 3.3.2 位移画布（重点） ctx.translate(x,y) 方法重新映射画布上的 (0,0) 位置 参数说明： x： 添加到水平坐标（x）上的值 y： 添加到垂直坐标（y）上的值 发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。 位移画布一般配合缩放和旋转等。 案例： 17位移画布.html 3.3.3 旋转（重点） context.rotate(angle); 方法旋转当前的绘图 注意参数是弧度（PI） 如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 案例：18旋转画布.html 3.3 绘制环境保存和还原（重要） ctx.save() 保存当前环境的状态 可以把当前绘制环境进行保存到缓存中。 ctx.restore() 返回之前保存过的路径状态和属性 获取最近缓存的ctx 一般配合位移画布使用。 案例： 19矩形旋转案例.html 3.4 设置绘制环境的透明度（了解） context.globalAlpha=number; number:透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。 设置透明度是全局的透明度的样式。注意是全局的。 3.5 画布限定区域绘制（了解） ctx.clip(); 方法从原始画布中剪切任意形状和尺寸 一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域） 一般配合绘制环境的保存和还原。 3.6 画布保存base64编码内容（重要） 把canvas绘制的内容输出成base64内容。 语法：canvas.toDataURL(type, encoderOptions); 例如：canvas.toDataURL(“image/jpg”,1); 参数说明： type，设置输出的类型，比如 image/png image/jpeg等 encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩，类型为： image/jpeg 或者image/webp才起作用。 123456789案例1：var canvas = document.getElementById(&quot;canvas&quot;);var dataURL = canvas.toDataURL();console.log(dataURL);// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;var img = document.querySelector(&quot;#img-demo&quot;);//拿到图片的dom对象img.src = canvas.toDataURL(&quot;image/png&quot;); //将画布的内容给图片标签显示 3.7 画布渲染画布（重要） context.drawImage(img,x,y); img参数也可以是画布，也就是把一个画布整体的渲染到另外一个画布上。1234567var canvas1 = document.querySelector(&apos;#cavsElem1&apos;);var canvas2 = document.querySelector(&apos;#cavsElem2&apos;);var ctx1 = canvas1.getContext(&apos;2d&apos;);var ctx2 = canvas2.getContext(&apos;2d&apos;);ctx1.fillRect(20, 20, 40, 40); //在第一个画布上绘制矩形ctx2.drawImage(canvas1, 10, 10); //将第一个画布整体绘制到第二个画布上 3.8 了解：线条样式（了解） lineCap 设置或返回线条的结束端点(线头、线冒)样式 butt ： 默认。向线条的每个末端添加平直的边缘。 翻译.：屁股；烟头；笑柄；靶垛；粗大的一端 英 [bʌt] 美 [bʌt] round ： 向线条的每个末端添加圆形线帽。 square： 向线条的每个末端添加正方形线帽。参考：23线的样式.html lineJoin 设置或返回两条线相交时，所创建的拐角类型 bevel: 创建斜角。 翻译. 斜角；斜面；[测] 斜角规 英 [‘bev(ə)l] 美 [‘bɛvl] round: 创建圆角。 miter: 默认。创建尖角 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 意思: 斜接 英 [‘maɪtə] 斜接长度指的是在两条线交汇处内角和外角之间的距离。 一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。 3.9 了解贝塞尔曲线（知道有）3.9.1 绘制一条二次方曲线。 微软的画图板中的曲线的颜色。 quadratic：二次方的意思， 英 [kwɒ’drætɪk] 美 [kwɑ’drætɪk] Curve：曲线的意思， 英 [kɜːv] 美 [kɝv] 语法： context.quadraticCurveTo(cpx,cpy,x,y); 参数： cpx： 贝塞尔控制点的 x 坐标 cpy： 贝塞尔控制点的 y 坐标 x ： 结束点的 x 坐标 y ： 结束点的 y 坐标12345ctx.beginPath();ctx.moveTo(20,20);//绘制2次方曲线，贝赛尔曲线ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); 3.9.2 绘制贝塞尔曲线（知道有） 绘制一条三次贝塞尔曲线 语法：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); 提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 参数说明： cp1x： 第一个贝塞尔控制点的 x 坐标 cp1y： 第一个贝塞尔控制点的 y 坐标 cp2x： 第二个贝塞尔控制点的 x 坐标 cp2y： 第二个贝塞尔控制点的 y 坐标 x: 结束点的 x 坐标 y: 结束点的 y 坐标 123456789101112//绘制复杂的贝塞尔曲线ctx.beginPath();ctx.moveTo(400,400);//参数说明：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);// cp1x： 第一个贝塞尔控制点的 x 坐标// cp1y： 第一个贝塞尔控制点的 y 坐标// cp2x： 第二个贝塞尔控制点的 x 坐标// cp2y： 第二个贝塞尔控制点的 y 坐标// x: 结束点的 x 坐标// y: 结束点的 y 坐标ctx.bezierCurveTo(500, 200, 600, 600, 700, 300);ctx.stroke(); 案例：25绘制贝塞尔曲线.html 3.10了解创建两条切线的弧（知道有） 在画布上创建介于当前起点和两个点形成的夹角的切线之间的弧 语法： context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。 例如： ctx.arcTo(240, 100, 240, 110, 40); 参数： x1: 弧的端点1的 x 坐标 y1: 弧的端点1的 y 坐标 x2: 弧的端点2(终点)的 x 坐标 y2: 弧的端点2(终点)的 y 坐标 r : 弧的半径 12345678//代码demo：ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(200,100);//context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。ctx.arcTo(240, 100, 240, 110, 40);ctx.lineTo(240, 300);ctx.stroke(); 3.11了解判断点是否在路径中（知道有）context.isPointInPath(x,y); //isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。 //判断x,y坐标的点是否在当前的路径中。 3.12了解文本宽度计算（知道有）context.measureText(text).width; 3.13 如果以后做canvas游戏方向开发深入学习可以扩展内以下容： setTransform() 将当前转换重置为单位矩阵。然后运行 transform() transform() 替换绘图的当前转换矩阵 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 像素操作 四、 Canvas开发库封装4.1封装常用的绘制函数4.1.1封装一个矩形//思考：我们用到的矩形需要哪些绘制的东西呢？ 1、矩形的 x、y坐标 2、矩形的宽高 3、矩形的边框的线条样式、线条宽度 4、矩形填充的样式 5、矩形的旋转角度 6、矩形的缩小放大 //下面是把上面所有的功能进行封装的代码： function ItcastRect( option ) {//矩形构造函数 this._init(option); } ItcastRect.prototype = { //矩形的原型对象 _init: function( option ) { //初始化方法 option = option || {}; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || &apos;silver&apos;; this.strokeStyle = option.strokeStyle || &apos;red&apos;; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; }, render: function( ctx ) {//把矩形渲染到canvas中 ctx.save(); ctx.translate( this.x, this.y );//位移画布 ctx.rotate( this.angle * Math.PI / 180 );//旋转角度 ctx.scale( this.scaleX, this.scaleY );//缩放 ctx.fillStyle = this.fillStyle; ctx.fillRect( 0, 0, this.w, this.h ); //填充矩形 ctx.lineWidth = this.strokeWidth; //线宽 ctx.strokeStyle = this.strokeStyle; //填充样式 ctx.strokeRect( 0,0,this.w,this.h ); //描边样式 ctx.restore(); }, constructor: ItcastRect }; 4.1.2作业：尝试着封装一个圆形？123456789101112131415161718192021222324252627282930313233343536373839404142//封装圆形的代码的答案：不要偷看function ItcastCircle( option ) &#123; this._init( option );&#125;ItcastCircle.prototype = &#123; _init: function( option ) &#123; option = option || &#123;&#125;; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || &apos;silver&apos;; this.strokeStyle = option.strokeStyle || &apos;red&apos;; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; this.opactity = option.opactity || 1; this.counterclockwise = option.counterclockwise === true ? true : option.counterclockwise || false; this.startAngle = option.startAngle == 0 ? 0 : option.startAngle || 0; this.endAngle = option.endAngle == 0 ? 0 : option.endAngle || 0; this.startAngle = this.startAngle * Math.PI/180; this.endAngle = this.endAngle * Math.PI / 180; this.r = option.r || 100; &#125;, render: function( ctx ) &#123; ctx.save(); ctx.translate( this.x, this.y); ctx.scale( this.scaleX, this.scaleY ); ctx.rotate( this.agnle * Math.PI / 180 ); ctx.globalAlpha = this.opacity; ctx.fillStyle = this.fillStyle; ctx.strokeStyle = this.strokeStyle; ctx.moveTo(0, 0); ctx.arc( 0, 0, this.r, this.startAngle, this.endAngle, this.counterclockwise); ctx.fill(); ctx.stroke(); ctx.restore(); &#125;, constructor: ItcastCircle&#125;; 4.2 第三方库使用 Rgraph vs 百度的echart 1https://roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/ 国产的egret引擎 1http://www.egret-labs.org/ 比较火的3d引擎：treejs 1http://threejs.org/ Konva 12345678官网：http://konvajs.github.io/ 特点： * 小巧、使用方便、适合移动端和pc端 * 支持丰富的事件处理操作 * 支持类似JQuery的操作方式（顺带能复习jQueyr） * 开源，可以随意更改 * 社区更新比较活跃，github托管源码 * 性能也不错 其他的还有很多，希望以后能用到你们的库。 五、Konva的使用快速上手5.1 Konva的整体理念 舞台的概念的引入。整个视图看做是一个舞台 stage 舞台中可以绘制很多个层 layer layer下面可以有很多的group group下面可以有 矩形、图片、其他形状等 参看：快速上手文档—查看翻译文档1234567891011121314151617 Stage | +------+------+ | | Layer Layer | | +-----+-----+ Shape | | Group Group | | + +---+---+ | | |Shape Group Shape | + | Shape 5.2 Konva矩形案例5.2.1 创建一个矩形： Konva.Rect(option);12345678910111213141516171819202122232425262728293031323334353637383940//Konva使用的基本案例//第一步：创建舞台var stage = new Konva.Stage(&#123; container: &apos;container&apos;, //需要存放舞台的Dom容器 width: window.innerWidth, //设置全屏 height: window.innerHeight&#125;);//第二步：创建层var layer = new Konva.Layer(); //创建一个层stage.add(layer); //把层添加到舞台//第三步： 创建矩形var rect = new Konva.Rect(&#123; //创建一个矩形 x: 100, //矩形的x坐标，相对其父容器的坐标 y: 100, width: 100, //矩形的宽度 height: 100, //矩形高度 fill: &apos;gold&apos;, //矩形填充的颜色 stroke: &apos;navy&apos;, //矩形描边的颜色 strokeWidth: 4, //填充宽度 opactity: .2, //矩形的透明度 scale: 1.2, //矩形的缩放 1：原来大小 rotation: 30, //旋转的角度，是deg不是弧度。 cornerRadius: 10, //圆角的大小（像素） id: &apos;rect1&apos;, //id属性，类似dom的id属性 name: &apos;rect&apos;, draggable: true //是否可以进行拖拽&#125;);//创建一个组var group = new Konva.Group(&#123; x: 40, y: 40,&#125;);group.add( rect ); //把矩形添加到组中//第四步： 把形状放到层中layer.add( group ); //把组添加到层中layer.draw(); //绘制层到舞台上 5.3 Konva的动画系统5.3.1 tween对象(重点) tween，英文意思：两者之间， 英 [twiːn] 美 [twin] tween是控制Konva对象进行动画的核心对象。 tween可以控制所有数字类型的属性进行动画处理，比如：x, y, rotation,width, height, radius, strokeWidth, opacity, scaleX等 1234567891011121314//案例：var tween = new Konva.Tween(&#123; node: rect, //要进行动画的Konva对象 x: 300, //要进行动画的属性 opacity: .8, duration: 1, //持续时间 easing: Konva.Easings.EaseIn, //动画的动画效果 yoyo: true, //是否进行循环播放的设置 onFinish: function() &#123; //动画执行结束后，执行此方法 &#125;&#125;);tween.play(); //启动动画 tween的控制方法 tween.play(), //播放动画 tween.pause(), //暂停动画 tween.reverse(), //动画逆播放 tween.reset(), //重置动画 tween.finish(), //立即结束动画 seek：英文：寻找 英 [siːk] 美 [sik] tween的缓动控制选项 Konva.Easings.Linear //线性 Konva.Easings.EaseIn //缓动，先慢后快 Konva.Easings.EaseOut //先快后慢 Konva.Easings.EaseInOut //两头慢，中间快 Konva.Easings.BackEaseIn //往回来一点，然后往前冲，汽车启动类似… Konva.Easings.BackEaseOut Konva.Easings.BackEaseInOut Konva.Easings.ElasticEaseIn //橡皮筋 英 [ɪ’læstɪk] 美 [ɪ’læstɪk] Konva.Easings.ElasticEaseOut Konva.Easings.ElasticEaseInOut Konva.Easings.BounceEaseIn //弹跳；弹起，反跳；弹回 英 [baʊns] 美 [baʊns] Konva.Easings.BounceEaseOut Konva.Easings.BounceEaseInOut Konva.Easings.StrongEaseIn //强力 Konva.Easings.StrongEaseOut Konva.Easings.StrongEaseInOut 动画效果参考： 29Konva动画缓动效果案例.html 5.3.2 动画to的使用 to就是对tween的封装，比较简单好用。1234567891011121314151617181920212223//案例：var rect = new Konva.Rect(&#123; x: 10, y: 10, width: 100, height: 100, fill: &apos;red&apos;&#125;);layer.add(rect);layer.draw();//动画系统rect.to(&#123; x: 100, y: 100, opactity: .1, duration: 3, onFinish: function() &#123; &#125;&#125;);//to: 就是对tween的简单应用。 5.3.3 Animate的应用 Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间12345678910111213var anim = new Konva.Animation(function(frame) &#123; //动画系统提供的frame有三个属性可以使用： var time = frame.time, // 动画执行的总时间 timeDiff = frame.timeDiff, // 距离上一帧的时间 frameRate = frame.frameRate; // 帧率（既1000/间隔时间） //动画的动作&#125;, layer);anim.start();//启动动画//anim.stop();//结束动画 5.3.4 循环播放动画的实现12345678910111213//总体思路，使用tween 配合onFinish事件中重新播放动画，达到循环播放的效果var loopTween = new Konva.Tween(&#123; node: star, //设置要表现动画的 Konva对象 rotation: 360, //旋转360度 duration: 2, //动画持续时间 easing: Konva.Easings.Linear, onFinish: function() &#123; // this === loopTween //true this.reset();//重置动画 this.play(); //重新播放动画 &#125;&#125;);loopTween.play(); 5.3.5 回放且循环播放动画 yoyo属性可以进行对动画进行播放完后，回放当前动画，并持续循环来回切换播放。12345rect.to(&#123; duration: 2, scale: 1.5, yoyo: true// 此设置也可以用于 tween&#125;); 5.3.6 进度条案例5.3.7 传智官网案例 三角函数的补充 Math.sin(弧度); //夹角对面的边 和 斜边的比值 Math.cos(弧度); //夹角侧边 与斜边的比值 圆形上面的点的坐标的计算公式 x =x0 + Math.cos(rad) * R;//x0和y0是圆心点坐标 y =y0 + Math.sin(rad) * R;//注意都是弧度 group的灵活运用 konva的group很灵活，每个group都有自己的坐标系 group可以包含其他的group，可以对group做整个组的动画 group可以通过getChidren();//可以拿到直接子级元素。12345var group = new Konva.Group(&#123; x: 0, y: 0&#125;);group.add(rect); 5.4 Konva的事件（重要）123456789101112131415161718192021222324252627282930var rect = new Konva.Rect(&#123; x: 100, y: 100, fill: &apos;red&apos;, width: 200, height: 200&#125;);//绑定事件 Konva支持事件：mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, mousewheel, click, dblclick, dragstart, dragmove, and dragendrect.on(&apos;click&apos;, function()&#123; //jQuery一模一样！！ console.log(&apos;^_^ ^_^&apos;);&#125;);//绑定多个事件rect.on(&apos;click mousemove&apos;,function(e)&#123;&#125;);//解除绑定事件rect.off(&apos;click&apos;); //这不是jQuery吗？//触发事件rect.fire(&apos;click&apos;);//取消事件冒泡rect.on(&apos;click&apos;, function(evt) &#123; alert(&apos;You clicked the circle!&apos;); evt.cancelBubble = true; //取消事件冒泡&#125;); 5.5 Konva的选择器 选择方法。 ID选择法：stage.find(‘#id’); //此方法返回的是一个数组 name选择法：group.findOne(‘.name’);//返回一个Konva对象 type选择法： group.find(‘Circle’);//查找所有的圆形Konva对象1234//组中查找圆形的Konva对象groupCircle.find(&apos;Circle&apos;).each(function( circle, index )&#123; circle.setZIndex( 3 - index );&#125;); 5.6 饼状图案例 wedge: 楔形 5.7 柱状图案例 histogram n. [统计] 直方图；柱状图 英 [‘hɪstəgræm] 美 [‘hɪstəɡræm] 六、Canvas项目实战七、Canvas优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;!-- requestAnim shim layer by Paul Irish --&gt; window.requestAnimFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(/* function */ callback, /* DOMElement */ element)&#123; window.setTimeout(callback, 1000 / 60); &#125;; &#125;)(); // example code from mr doob : http://mrdoob.com/lab/javascript/requestanimationframe/var canvas, context, toggle;init();animate();function init() &#123; canvas = document.createElement( &apos;canvas&apos; ); canvas.width = 512; canvas.height = 512; context = canvas.getContext( &apos;2d&apos; ); document.body.appendChild( canvas );&#125;function animate() &#123; requestAnimFrame( animate ); draw();&#125;function draw() &#123; var time = new Date().getTime() * 0.002; var x = Math.sin( time ) * 192 + 256; var y = Math.cos( time * 0.9 ) * 192 + 256; toggle = !toggle; context.fillStyle = toggle ? &apos;rgb(200,200,20)&apos; : &apos;rgb(20,20,200)&apos;; context.beginPath(); context.arc( x, y, 10, 0, Math.PI * 2, true ); context.closePath(); context.fill();&#125;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6的let和const命令]]></title>
    <url>%2F2016%2F06%2F05%2FECMAScript6%E7%9A%84let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.let 命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // &quot;undefined&quot;上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 function func(arg) { let arg; // 报错} function func(arg) { { let arg; // 不报错 }} 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。12345678910function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; function f() &#123; console.log(&apos;I am inside!&apos;); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。12345678910111213// 浏览器的 ES6 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。1234567891011// 浏览器的 ES6 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = &apos;secret&apos;; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = &apos;secret&apos;; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错&apos;use strict&apos;;if (true) &#123; function f() &#123;&#125;&#125;// 报错&apos;use strict&apos;;if (true) function f() &#123;&#125; 2.const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。123456var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === &apos;object&apos; ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。12345678910111213141516// 方法一(typeof window !== &apos;undefined&apos; ? window : (typeof process === &apos;object&apos; &amp;&amp; typeof require === &apos;function&apos; &amp;&amp; typeof global === &apos;object&apos;) ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125; if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125; if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125; throw new Error(&apos;unable to locate global object&apos;);&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。12345// CommonJS 的写法require(&apos;system.global/shim&apos;)();// ES6 模块的写法import shim from &apos;system.global/shim&apos;; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。123456// CommonJS 的写法var global = require(&apos;system.global&apos;)();// ES6 模块的写法import getGlobal from &apos;system.global&apos;;const global = getGlobal(); 上面代码将顶层对象放入变量global。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web开发基础]]></title>
    <url>%2F2016%2F06%2F04%2F%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.1 布局1.1.1三种布局有最大、最小宽度的百分比自适应布局适用场景：门户网站首页，图片较多的首页。百分比自适应布局适用场景：信息文字较多的网页，内容较多网页。全屏自适应布局适用场景：单页面网页，移动web app 页面。 ###1.1.2Box-sizing在移动端的使用在百分比定宽的页面经常使用。*, ::before, ::after{ -webkit-box-sizing: border-box; /*以你的border开始计算你的宽度*/ } 1.2移动端事件Touchtouchstart：当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend：当手指离开屏幕时触发 touchcancel：系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用触摸事件的响应顺序1、ontouchstart2、ontouchmove3、ontouchend4、onclick 300ms延时 EventoriginalEvent （原生事件） 是jquery 封装的事件。targetTouches 目标元素的所有当前触摸changedTouches 页面上最新更改的所有触摸touches 页面上的所有触摸 clientX、clientY 相对于当前屏幕的X或Y位置pageX、pageY 相对于整体页面的X或Y位置 transitionEnd 过渡结束事件。animationEnd 动画结束事件 移动端事件框架例如 zepto touch.js ‘swipe’,‘swipeLeft’,‘swipeRight’,‘swipeUp’,‘swipeDown’, ‘doubleTap’,‘tap’,‘singleTap’,‘longTap’都是由我们的原生touch事件封装的。 1.3常见的移动端问题1.3.1什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下.css{width:100px;height:100px;background-size:100px 100px;}其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px.css{font-size:20px} 1.3.2百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; 1.3.3移动端手机号码识别（IOS）在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：1 7位数字，形如：12345672 带括号及加号的数字，形如：(+86)1234567893 双连接线的数字，形如：00-00-001114 11位数字，形如：13800138000可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;开启电话功能&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;开启短信功能：&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt; ###1.3.4移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt; 1.3.5ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 1.3.6webkit表单元素的默认外观怎么重置.css{-webkit-appearance:none;} 1.3.7禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算（或者在内嵌浏览器中设置字体的大小），进行相应的缩放，当我们不需要这种情况时，可以选择禁止：123 html &#123; -webkit-text-size-adjust: 100%;&#125; 1.3.8移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：123.user-select-none &#123; -webkit-user-select: none;｝ 1.3.9如何禁止保存或拷贝图像（IOS）通常当你在手机或者pad上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：img { -webkit-touch-callout: none; } 1.3.10摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 1.3.11 android 上去掉语音输入按钮input::-webkit-input-speech-button {display: none} 1.3.12移动端基础框架zepto.js语法与jquery几乎一样，会jquery基本会zepto；搭配backbone underscore动画css]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>移动web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2016%2F05%2F06%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器 http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态. 详细请点击]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3基础笔记]]></title>
    <url>%2F2016%2F04%2F25%2FCSS3%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第1章CSS3简介如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 1.1 CSS3的现状1、浏览器支持程度差，需要添加私有前缀 2、移动端支持优于PC端 3、不断改进中 4、应用相对广泛 1.2 如何对待1、坚持渐进增强原则 2、考虑用户群体 3、遵照产品的方案 4、听Boss的 第2章准备工作2.1统一环境由于CSS3兼容性问题的普遍存在，为了避免因兼容性带来的干扰，我们约定统一的环境，以保证学习的效率，在最后会单独说明兼容性的问题。 1、Chrome浏览器 version 46+ 2、Firefox浏览器 firefox 42+ 3、PhotoShop CS6（建议） 2.2如何使用手册学会使用工具，可以让我们事半功倍。[] 表示全部可选项|| 表示或者| 表示多选一？ 表示0个或者1个* 表示0个或者多个{} 表示范围 第3章基础知识3.1选择器CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与jQuery中所提供的绝大部分选择器兼容。 3.1.1属性选择器参考手册1、E[attr] 表示存在attr属性即可；2、E[attr=val] 表示属性值完全等于val3、E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的4、E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以“-”分隔的5、E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置6、E[attr^=val] 表示的属性值里包含val字符并且在“开始”位置7、E[attr$=val] 表示的属性值里包含val字符并且在“结束”位置 3.1.2伪类选择器参考手册重点理解E是用来参考确定其父元素的，nth-child(n) 对应根据E元素确定的父元素的所有子元素，nth-of-type(n) 的不同之处在于其对应的是只有E元素，会忽略其子元素。（此处要配合案例加强理解）E:nth-child(n) 第n个子元素，计算方法是E元素的全部兄弟元素E:nth-of-type(n) 第n个子元素，计算方法只是E元素，会忽略其子元素的存在E:nth-last-child(n) 同E:nth-child(n) 计算顺序相反。E:nth-last-of-type(n) 同E:nth-of-type(n) 计算顺序相反。n遵循线性变化，其取值1、2、3、4、…关于n的取值范围：1、当n做为一个独立值时，n取值为n&gt;=1，例如nth-child(n)2、当n做一个系数时，n取值为n&gt;=0者n&lt;0，例如nth-child(2n+1)、nth-child(-1n+5) 此处需要理解2n+1或者-n+5做为一个整体不能小于1；E:only-child 表示当前以E确定的父元素，除E之外并无其它子元素（独生子）；E:only-of-type表示当前以E确定的父元素， 除E之外不能包含其它和E同类型的子元素；E:target 结合锚点进行使用，处于当前锚点的元素会被选中；E:empty 选中没有任何子节点的E元素； ###3.1.3伪元素选择器E::selection 可改变选中文本的样式E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。“:” 与 “::” 区别在于区分伪类和伪元素 3.2颜色新增了RGBA、HSLA模式，其中的A 表示透明度通道，即可以设置颜色值的透明度，相较opacity，不具有继承性，即不会影响子元素的透明度。Red、Green、Blue、Alpha即RGBAHue、Saturation、Lightness、Alpha即HSLAR、G、B 取值范围0~255H 取值范围0~360，0/360表示黑色、120表示绿色、240表示蓝色S 取值范围0%~100%L 取值范围0%~100%A 取值范围0~1关于透明度：1、opacity子元素会继承父元素的透明度，在实际开发中会带来干扰；2 、transparent 设置透明度时完全类似于“玻璃”一样的透明； 3.3文本参考手册文字阴影与边框阴影相似，可分别设置偏移量、模糊度、颜色（可设透明度）。单行文本溢出，需要配合overflow:hidden; white-space: nowrap;难理解的点：自已要多试着理解一下关于white-space的各个属性值之间的差异；换行符指的我们在键盘上的Enter键，Enter换行符会被当成空行来对待，而由Tab、Space产生的换行，则会视为一个空格。上述方法只能解决单行文本的溢出问题，多行文本溢出处理可参照下面的方法，但是有比较严重的兼容性，需要慎重选择，比较完备的多行溢出需要JS辅助完成，可自行尝试。多行文本文字溢出处理，非标准属性，可应用于移动端 了解常握white-space 使用 3.4边框其边框圆角、边框阴影属性，应用十分广泛，兼容性也相对较好，具有符合渐进增强原则的特征，我们需要重点掌握。 3.4.1边框圆角圆角处理时，脑中要形成圆、圆心、长半径、短半径的概念，正圆是椭圆的一种特殊情况。 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ）参考手册练习熟悉各种简写方式。 表格运用圆角需要要 border-collapse: separate;当圆角半径小于或等于边框宽度时，元素内角是直角 如何在PS中查看圆角半径？ 3.4.2边框图片设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图 “切割”完成后生成虚拟的9块图形，然后按对应位置设置背景，其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。如下图 round 会自动调整尺寸，完整显示边框图片。 repeat 单纯平铺多余部分，会被“裁切”而不显示。 background-slice: 27 40 40 27 分别设置裁切如下图 3.4.3边框阴影水平偏移量 正值向右 负值向左 垂直正值向下 负值向上。模糊度是不能为负关于模糊度：从一个颜色值在一定距离内进行一个渐变至透明的过程。移量和扩展也是数学运算的，即正负会相互抵消。偏移量和模糊度是可以相加计算，偏移量负号只代表方向。设置边框阴影不会影响盒子的布局，即不会影响其兄弟元素的布局。spread可以与blur、h-shadow、v-shadow相互抵消，blur不可为负值可以设置多重边框阴影，实现更好的效果，增强立体感。 3.5盒模型关于盒模型存在两种形式，分别是W3C标准盒模型和IE盒模型，如下图所示，其区别主要在于宽度和高度的计算方式，CSS3对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。 IE模型下 width = padding + content + border;W3C盒模型下 width = contentbox-sizing: border-box width = border + padding + contentbox-sizing: content-box width = contentIE盒模型只会出现在IE5版本和IE6+的怪异模式中。怪异模式http://www.cnblogs.com/coco1s/p/4034937.htmlCSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box; 3.6背景背景在CSS3中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。background-size 与 background-clip无关background-size 与 background-origin 保持一致背景图片尺寸在实际开发中应用十分广泛。参照手册 3.7渐变渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。可分为线性渐变、径向渐变、重复渐变。线性渐变指沿着某条直线朝一个方向产生渐变效果。 上图是从黄色渐变到绿色必要的元素：方向、起始颜色、终止色；关于方向如下图 关于颜色起止，可以设置多个色值的渐变，并且可以分别设置渐变的距离如 linear-gradient(to left, yellow 10%, blue 15%, red 50%)径向渐变指从一个中心点开始沿着四周产生渐变效果 特点：1、辐射范围2、中心点3、颜色的起止关于中心点：中心位置参照的是盒子的左上角关于辐射范围：其半径可以不等即可以是椭圆关于圆的知识同边框圆角章节的介绍 3.8伸缩布局CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用，使得开发人员一下子就过上了小康的生活。伸缩盒模型经历了几次演变，大致分为旧版伸缩布局、过渡伸缩布局、新版伸缩布局，同样为了避免混淆，我们以学习新版伸缩布局为主。 3.8.1新版伸缩布局这里我们需要引入一些新的概念：主轴：Flex容器的主轴主要用来配置Flex项目。侧轴：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。主轴和侧轴并不是固定不变的，通过flex-direction可以调整。 1、指定一个盒子为伸缩盒子 display: flex2、设置属性来调整此盒的子元素的布局方式 例如 flex-direction3、明确主侧轴的方向4、可互换主侧轴，也可改变方向其相关属性可参照源代码里的解释如flex-direction、flex-wrap、flex-flow、align-items、align-content、justify-content、align-self、flex、order等另个两个版本伸缩布局其实现思路与新版基本一致，区别在于其属性及属性值不同，熟练掌握新版伸缩布局后，要参照对比另外两个版本的不同。 3.9多列布局类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。参照手册 3.10过渡过渡是CSS3中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。帧动画：通过一帧一帧的关键画面按照固定顺序和速度播放。如电影胶片 补间动画：自动完成从起始状到终止状的的过度。关于补间动画更多学习可查看http://mux.alimama.com/posts/1009特点：当前元素只要有“属性”发生变化时，可以平滑的进行过渡。transition-property设置过渡属性transition-duration设置过渡时间transition-timing-function设置过渡速度transition-delay设置过渡延时贝塞尔曲线限定了过渡的轨迹。这部分没有提及，有兴趣同学自行查阅相关资料了解一下即可。以上四属性重在更解，具体细节可参考手册辅助记忆 3.11动画动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。参考手册 3.12转换转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合即将学习的过渡和动画知识，可以取代大量之前只能靠Flash才可以实现的效果。2D 转换translate(x,y) x、y 可为负值，相对自身移动，并未脱离文档流。左手坐标系：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。左手法则：左手握住旋转轴，竖起拇指指向旋转轴正方向，正向旋转方向就是其余手指卷曲的方向。 3D坐标轴，用X、Y、Z分别表示空间的3个维度，三条轴上互相垂直。 3.13媒体查询由于网页呈现终端设备越来越趋向于多样化，尤其是移动终端（手机），具有不同屏幕尽寸、不同分辨率，为了保证网页能十分友好的呈现，CSS3为开发人员提供了可以识别呈现终端的方法，这样便可以有针对性的为不同的呈现终端分别进行处理，被广泛应用于响应式开发中。html 标签方式：css 属性方式：常使用的是检测设备宽度参考手册第4章Web字体开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。支持程度比较好，甚至IE低版本浏览器也能支持。 4.1字体格式不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。1、TureTpe(.ttf)格式.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；2、OpenType(.otf)格式.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；3、Web Open Font Format(.woff)格式woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；4、Embedded Open Type(.eot)格式.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；5、SVG(.svg)格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；关于字体介绍摘自http://www.w3cplus.com/content/css3-font-face/了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。推荐http://www.zhaozi.cn/、http://www.youziku.com/ 查找更多中文字体 4.2字体图标其实我们可以把文字理解成是一种特殊形状的图片，反之我们是不是也可以把图片制作成字体呢？答案是肯定的。常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体库，然后就可以像使用文字一样使用图标了。优点：1、将所有图标打包成字体库，减少请求；2、具有矢量性，可保证清晰度；3、使用灵活，便于维护；Font Awesome 使用介绍http://fontawesome.dashgame.com/定制自已的字体图标库http://iconfont.cn/https://icomoon.io/SVGhttp://www.iconsvg.com/ 第5章兼容性通过http://caniuse.com/ 可查询CSS3各特性的支持程度，一般兼容性处理的常见方法是为属性添加私有前缀，如不能解决，应避免使用，无需刻意去处理CSS3的兼容性问题。 第6章高级应用]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5触摸事件]]></title>
    <url>%2F2016%2F04%2F20%2FHTML5%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. HTML5触摸事件HTML5中新添加了很多事件，但是由于他们的兼容问题不是很理想，应用实战性不是太强，所以在这里基本省略，咱们只分享应用广泛兼容不错的事件，日后随着兼容情况提升以后再陆续添加分享。今天为大家介绍的事件主要是触摸事件：touchstart、touchmove和touchend。 一开始触摸事件touchstart、touchmove和touchend是iOs版Safari浏览器为了向开发人员传达一些信息新添加的事件。因为iOs设备既没有鼠标也没有键盘，所以在为移动Safari浏览器开发交互性网页的时候，PC端的鼠标和键盘事件是不够用的。 在iPhone 3Gs发布的时候，其自带的移动Safari浏览器就提供了一些与触摸(touch)操作相关的新事件。随后，Android上的浏览器也实现了相同的事件。触摸事件(touch)会在用户手指放在屏幕上面的时候、在屏幕上滑动的时候或者是从屏幕上移开的时候出发。下面具体说明： touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。 touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 touchend事件：当手指从屏幕上离开的时候触发。 touchcancel事件：当系统停止跟踪触摸的时候触发。关于这个事件的确切出发时间，文档中并没有具体说明，咱们只能去猜测了。 上面的这些事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但是它们却是以兼容DOM的方式实现的。所以，每个触摸事件的event对象都提供了在鼠标实践中常见的属性：bubbles(起泡事件的类型)、cancelable(是否用 preventDefault() 方法可以取消与事件关联的默认动作)、clientX(返回当事件被触发时，鼠标指针的水平坐标)、clientY(返回当事件触发时，鼠标指针的垂直坐标)、screenX(当某个事件被触发时，鼠标指针的水平坐标)和screenY(返回当某个事件被触发时，鼠标指针的垂直坐标)。除了常见的DOM属性，触摸事件还包含下面三个用于跟踪触摸的属性。 touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个Touch对象包含的属性如下。 clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触目的DOM节点目标。 上面的属性光这么看，果然非常繁琐，每个属性说的都是那么的细致，只有真刀实枪的来点小例子才能更加明白其中的奥妙。所以小例子如下。 123456789101112131415161718192021222324252627function load ()&#123; document.addEventListener(&apos;touchstart&apos;,touch, false); document.addEventListener(&apos;touchmove&apos;,touch, false); document.addEventListener(&apos;touchend&apos;,touch, false); function touch (event)&#123; var event = event || window.event; var oInp = document.getElementById(&quot;inp&quot;); switch(event.type)&#123; case &quot;touchstart&quot;: oInp.innerHTML = &quot;Touch started (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;; break; case &quot;touchend&quot;: oInp.innerHTML = &quot;&lt;br&gt;Touch end (&quot; + event.changedTouches[0].clientX + &quot;,&quot; + event.changedTouches[0].clientY + &quot;)&quot;; break; case &quot;touchmove&quot;: event.preventDefault(); oInp.innerHTML = &quot;&lt;br&gt;Touch moved (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;; break; &#125; &#125; &#125; window.addEventListener(&apos;load&apos;,load, false); touches: 当前屏幕上所有触摸点的列表; targetTouches: 当前对象上所有触摸点的列表; changedTouches: 涉及当前(引发)事件的触摸点的列表 通过一个例子来区分一下触摸事件中的这三个属性： 用一个手指接触屏幕，触发事件，此时这三个属性有相同的值。 用第二个手指接触屏幕，此时，touches有两个元素，每个手指触摸点为一个值。当两个手指触摸相同元素时，targetTouches和touches的值相同，否则targetTouches 只有一个值。changedTouches此时只有一个值，为第二个手指的触摸点，因为第二个手指是引发事件的原因 用两个手指同时接触屏幕，此时changedTouches有两个值，每一个手指的触摸点都有一个值 手指滑动时，三个值都会发生变化 一个手指离开屏幕，touches和targetTouches中对应的元素会同时移除，而changedTouches仍然会存在元素。 手指都离开屏幕之后，touches和targetTouches中将不会再有值，changedTouches还会有一个值，此值为最后一个离开屏幕的手指的接触点。 2. 触点坐标选取123touchstart和touchmove使用: e.targetTouches[0].pageX 或 (jquery)e.originalEvent.targetTouches[0].pageXtouchend使用: e.changedTouches[0].pageX 或 (jquery)e.originalEvent.changedTouches[0].pageX 3.touchmove事件对象的获取想要在touchmove:function(e,参数一)加一个参数，结果直接使用e.preventDefault()就会 e 报错，处理方法为使用arguments[0]获取event参数1234touchmove:function(e,参数一)&#123; var e=arguments[0] e.preventDefault()&#125;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础]]></title>
    <url>%2F2016%2F03%2F09%2FHTML5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[用普通文本描述富文本的语法扩展名md,markdown HTML5之HTML篇回顾 新标签 语义化标签 新属性 链接关系描述 ARIA 无障碍富互联网应用程序属性 自定义属性 data- 可以给HTML里的所有DOM对象都可以添加一些DATA-xxx的属性 用来记录与当前DOM强相关的数据 智能表单 新的表单类型 功能型的表单类型 虚拟键盘适配 通过type方式指定弹出键盘 网页多媒体 之前强依赖flash 音频 多媒体的dom对象有一些新的方法可以去做播放暂停 视频 了解字幕 SVG 文件基本使用 iframe iframe的作用就是在网页中挖个坑，在这个坑里再展示一个页面 svg本身也是文档 所以可以使用iframe的方式载入 ajax 直接可以修改样式 JavaScript2.1. 基础API提升2.1.1 新选择器JS多了一个原始支持，类似jqueryDOM选择器 document.getElementById() 需要给DOM元素设置IDdocument.querySelector(selector) 可以通过CSS选择器的语法找到DOM元素 document.getElementsByTagName()document.querySelectorAll(‘.item’) $(‘.item’).on document.querySelector(selector); 返回第一个满足选择器条件的元素 一个dom对象 document.querySelectorAll(‘.item’); 返回所有满足该条件的元素 一个元素类型是dom类型的数组 $(‘.item’) 返回一个jQuery对象（dom元素的数组） 本质上jquery方式和qs方式都是获取DOM数组， 只不过jquery会多一些其他成员 DOM数组的每一个成员注册事件不能像jquery一样直接注册， 必须分别给每个元素注册 h5就是将我们经常需要的操作又包装一层 2.1.2 元素.classList 新H5中DOM对象多了一个classList属性，是一个数组 add 添加一个新的类名 remove 删除一个的类名 contains 判断是否包含一个指定的类名 toggle 切换一个class element.toggle(‘class-name’,[add_or_remove]) toggle函数的第二个参数true为添加 false删除 2.1.3 访问历史 API界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态 history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态) 2.1.4 全屏 API JavaScript中可以通过调用requestFullScreen()方式实现指定元素的全屏显示var element = document.querySelector(‘…’);element.requestFullScreen(); 2.2 网页存储2.2.1 Web Storage getItem方式获取一个不存在的键 返回空字符串 []返回 undefined 2.2.2 Web SQL2.2.3 IndexedDB2.3 文件系统2.3.1 File API2.3.2 FileReader2.4 拖放操作2.4.1 网页内拖放2.4.2 文件拖入]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
</search>
