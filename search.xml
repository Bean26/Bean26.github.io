<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[西瓜味女孩]]></title>
    <url>%2F2017%2F06%2F02%2F%E8%A5%BF%E7%93%9C%E5%91%B3%E5%A5%B3%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[一天下午，我在上TU类图书，突然闻到一股西瓜的清香，我侧过头，发现是从旁边女生身上散出来的，居然还有西瓜味的香水。我看了看她，正漫不经心的浏览书籍。 后来又经过这里时发现这个女孩还在这里，我端详了一下，长得还不错，皮肤瞒好，中等长度微蓝连衣裙，加上一股淡淡西瓜清香，确实吸引人。她正捧着本大大的厚厚的书蹲坐在架子的远角，书平放在两腿上，翻过的部分立着向上，我只能看到封面。她似乎感到有人在看她，抬头，看见了我，感觉有点愣住了，然后咧嘴对我勉强笑了一下，我反射般扭过头，额头顿时微微冒出冷汗，心里嘀咕：“该死，看见美女就犯毛…”于是忙貌似正经的走开。等我又上完一波书经过这里时发现那个西瓜味的女孩不见了，我微微叹了口气，又继续工作了。 第二天下午，3点多时，又发现了那个女孩，我情不自禁的把目光投向了她，真是越看越有感觉，跟昨天一样捧着同样的书坐在同样的地方，人又漂亮，又爱学习，真是不错。 每次上书上到那个架子我总要多磨蹭磨蹭，而且每次走到她附近时，她总会把书轻轻合上，然后站起身，让我好轻松走过，每次都能闻到那股淡淡的西瓜味，啊，好有诱惑力。差不多工作要完成了，本想找个借口跟那个女孩说上两句话，可是不知什么时候人已经走了，我长长的叹了口气。 第三天，星期一。哈哈，心里窃喜，希望能再见到那个女孩，那就真说明有缘了，到时一定要要个联系方式什么的。可是过了3点了，过了4点了，还是没有见到那个西瓜味的女孩，可能有课吧，我深深叹了口气。 眼看就要走了，书又少，没什么事，开始到那个女孩的书架闲逛，我深吸气，寻找什么，但是只有一股陈旧的书的味道。无意看到了那个女孩看的那本书，我抽了出来，《外国经典建筑欣赏》，“是个艺术系或是建筑系的女生吧。”我暗想。我摸了摸封面，轻轻的打开了它，我一下子愣了——里面的图片基本上没了，只剩下一个个框框！]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[善良有什么用]]></title>
    <url>%2F2017%2F05%2F20%2F%E5%96%84%E8%89%AF%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%2F</url>
    <content type="text"><![CDATA[善良有什么用？善良可以让你找到世界上最好的老婆！ 有些程序员工作之余干私活，赚的是快钱；有些程序员工作之余研究技术，提升自己，赚的是长远收益。某种程度上，善良这种特质也是一种长远收益，当下感受不到明显收益，但是一段时间后，你会庆幸自己的善良。 ———————— 我刚开始工作的时候，为了有更多的时间学习，就在公司附近住群租房，上下铺那种，当然房间本身是很不错，很大，应该有4室，且就在黄浦江边上，是比较新的高层小区，每天叫醒我的是悠长而厚重的的轮船汽笛声，那是一段如电影如诗画般有韵味的经历。 骨子里对钓鱼充满了兴趣，因此，总会忍不住去上海周边的鱼塘钓鱼解毒。但由于自己没有时间和精力做菜，因此，钓上来的鱼如何处理就成了一个小问题。最后每次钓的鱼都全部送给非亲非故的房东阿姨（单独住一间），包括挺值钱的大青鱼也不例外。当时的我初入社会，人情世故实际上并不懂，行为准则全凭自己内心指引，送鱼这件事情就是自己内心小小的善意，并没有任何功利性的想法，也没有指望说有什么回赠之类。 但，就是这一小小的善意，悄然拨动了命运的琴弦，在日后影响了我的一生。 后来又一次，房东阿姨在厨房做鱼的时候，我正好有点时间，就去围观我的鱼，顺便想打探对面房间里面女生的一些信息。 冒着跪搓衣板的风险坦白交代，实际上我一开始想打探的是另外一个看上去比较简单的女生，或许就是因为我送鱼的那点善意，房东阿姨很认真地和我透露了下面这些信息：“那个女孩啊，不行的！跟‘教练’（一个租客，职业是健身教练）吵架，直接拿刀！” “啊？”我一愣，甚是意外，跟外在感觉完全不一样。 然后房东阿姨继续道：“倒是沈*这个姑娘很不错，真·的·很不错！” “真·的”二字房东阿姨特意加重拉伸了音强调了下！ “嗯？”我心里疑问了下，为什么我心中疑问呢？这个沈姑娘虽然也是个高个子，但是一头黄灿灿的头发，打扮公主且有些潮，就是下面这样！ 老婆的第一印象 外表看起来就是个有故事的女生，像我这样不谙世事的屌丝小白菜，第一印象并不觉得合适。好在我这人有个优点，听得见去别人的意见和建议，既然见多识广的阿姨这么说了，那我自然就会摒弃第一感觉带来的偏见，重新进行认识。 然而，对于一个内向不会说话的技术男而言，后来好长一段时间都没有和这两个女生搭上话，甚至都没见过面，直到有一天，房东阿姨特意过来跟我说，“那两个女孩要搬走了……”，然后用不断暗示的眼神看着我。那一刻，我做了这辈子做勇敢的决定，其实很多年来我一直思考，为何一直单身怎么多年，就是性格太软，畏首畏尾，如果我再这样瞻前顾后，错过这次机会，一定又会悔不当初，于是，我勇敢地敲了女生房间的门……然后门开了…… 我的小心脏就像是下坡的铁轨，噗通噗通个不停！走到屋子中间，深吸了一口气，然后开始了尴尬的台词：“听说你们马上就搬走了？既然有缘曾在同一屋檐下，要不留个手机号……” “啊！！！！！”现在想想当时说的话，我都恨不得一头撞死电脑桌上，我这是在闹那样啊…… 果不其然，屋子里只有女生们“额……”的声音，正当我感觉不妙要大势已去的时候，沈姑娘来了句“那要不留个QQ号吧？” “好”，我感觉自己从悬崖边救了回来，有QQ号也是好的，对的，成功要到了QQ号，手机号的原计划失败！ 然后，有了联系方式，我就开始慢慢接触啦，时不时QQ Q两下，然后约女孩子什么的，邀约的方式也非常的老土，好吧，我找到了当时和老婆交流的第一封邮件： 第一封交流邮件 被无情地拒绝了，再约，再拒，这次连表情都没有，也没有感谢，直接让我找别人约！ 再次拒绝 心碎 其实，此时，我已经知道希望渺茫了，就没再打扰。 其实现在想想，主要是当时太瘦，气质太屌丝，穿着像狗屎，第一印象实在太差了，一看就是上海底层要饭的，人家跟你又不熟，怎么可能和你出来看电影呢！ 然而，绝境中透露了一点光，祖上三世积的德开始显灵了，嘿，某天，沈姑娘居然QQ我让我帮忙翻译经济学文章，答辩用（估计急用，死马当活马医）。那个时候我才知道，原来妹子还是学生，就在附近的海事大学，估计因为学生党钱不多，所以住在群租房。 我去，虽然我当时的社交能力和口才是负分，但是这阅读和写作那可是才华横溢啊，翻译点经济学文章还不是砍瓜切菜，唰唰唰就弄好了，然后……没有什么然后…… 在之后的日子里，也就是偶尔帮帮小忙之类的…… 转眼一年多过去了，又是一年夏日将至，万物复苏，生机蓬勃，我又尝试约沈姑娘看电影…… 居然！居然！Oh My God! 苍天有眼，居然同意了，真不敢相信，我活了27年，第一次成功约女孩子看电影！ 后来，妹子告诉我说，后来通过一些交流，以及看我的网站和我写的文章，原来不是个坏人也不是个怪人，才决定接触看看。 后来的接触发现，我去，这个妹子实在是太赞了，我说的赞指的是内心真的很棒！非常体贴，善解人意，而且有涵养。举个例子，确定关系前约会吃饭妹子会回请，并且付钱的时候提前把钱给我，让我付，照顾男生的面子。就这一点，甩了绝大多数女孩子一条街。然后越接触越不得了，温柔体贴，非常会为人处事，独立有主见，内心果敢且坚强。而且家也是江苏的，而且家门前就是个大鱼塘，喂，出门就是鱼塘啊！我跟你们讲，写到这里，我真是感动的要哭了，我怎么这么好命呢，抓住了这么好的姑娘，一定是母上大人在天有灵。 所以，我当时的想法就是，这个妹子我非娶不可，认定了，想尽一切办法都要揽在身边！ 后来的事情你们也知道了，我成功了！别管我用什么手段，总之我成功了！现在小朋友都可以打酱油啦，嘻嘻~~ 而且一直相处很融洽，结婚3年多了，几乎就没有吵过架。做法很简单，公平就好啦，意见不一的时候听老婆的，意见一样的时候听我的。然后什么事情都把老婆放在心上就好啦，“爱妻狂魔”的称呼就是这么来的，哈哈！ 自从和老婆在一起后，整个人生都不一样了，年会那是几乎年年中奖，大奖小奖一起来。妹子的口才和为人处事能力真是，不是我吹，我就没见过更厉害的，而这一块正好我是残废，于是我就有了学习的老师了，什么时候该说什么话，一些重要邮件该怎么回复，我都会请教，都会一点一点学习，你看我现在表达能力跟刚毕业的时候完全不可同日而语！而且按照我老婆的说法，我是为数不多结婚后越来越帅的男的，肉是老婆养的（以前太瘦），头发是老婆剃的，衣服是老婆买的，你说，能不帅吗，现在形象和气质确实好了很多！ 归根结底还是老婆好，才能家和万事兴！ 回过头来看，所有这一切，都因为当初自己的善良。如果不是自己的善良，房东阿姨就不会助攻我，让我知道第一印象不看好的姑娘不是外表这样，就不会有后来的追求的举动，就会错过世界上最好的老婆。 所以善良有什么用？善良可以让你找到世界上最好的老婆！]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的生命里住着怎样的另一个自己]]></title>
    <url>%2F2017%2F04%2F24%2F%E4%BD%A0%E7%9A%84%E7%94%9F%E5%91%BD%E9%87%8C%E4%BD%8F%E7%9D%80%E6%80%8E%E6%A0%B7%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[想起早年读过的半则神话故事。 远古时候有一渔者，终日在无妄之海捕鱼而生，有一日，迷失于一片海域，漂了一万两千年终于走出来，海水边搁浅着一叶扁舟，无人，无风，无鸟雀。他走近小船，看到一本上古秘籍，一页一页翻去，边颔首边赞叹，翻至最后一页，发现竟画着自己，与自己背靠背坐着一位书生，旁边还有两行字，一行：行文有际，……。后面的字被海书浸湿，看不清。又一行：猎海无涯，……。后面的字被一团黑墨盖住。叉弃书生衣摆之侧，笔置渔人篷发之间。 感兴趣的故事总是残篇断简。 神秘的预言若被印证，立刻觉得冥冥之中，有一只大手搅弄着风云，大气象之下的芸芸众生，越觉得微乎其微，虽杳渺，仍对细节着迷，就如有一个时刻，会莫名努力关注着一个闯进浮生半日的生命，而忽略了周遭的喧喧嚷嚷，任由故事里的人入了现实，而自己隐进故事。这一隐一现之间，命运就生出枝杈，生命就此丰盈起来。 1渔人猎到何种鱼都不足为奇。他擎叉的表情，他趟开草丛时四溅的水珠，他肩头划落的流星是以怎样的轨迹陨落，这些附着在故事本体的细微，才是一个可以讲出精彩故事的人的谈资。 而让渔人双眼放光的，终究是那些闯入眼帘的猎物。他布下重重陷井后，渴望着第二日，能够看到扑腾着的，那些误入岐途的鱼啊、贝啊的。 这天，他挽了叉，摸着黑出海。这天，他收了网，摸着黑回到家中。他从怀里取出从后海山涯上捡拾到的一方岩石，岩石上刻着一幅图，一男子单腿脆在渔船上，双手似掷叉，却不见叉，渔人寻思半晌，顺着那男子目光的方向画了一支渔叉。这样才踏实，他说。 夜晚入梦，他怀抱一轮月在浓雾里四野奔走，耳边隐隐有细碎的咳嗽，静立细听时，悄无声息，夺步而走时，又戚戚地回响于耳畔，他看不清自己的表情，却能看到完整的自己被白日的那片岩石群裹挟着，他内心有方向，而双脚无感，脚底接壤着的这片土地，让他瞬间立成一株静物。 走吧，走吧。他对自己说。身子重得仍旧迈不开腿，正犹疑时，听到猎犬狂吠，继而又听院子里“咣当”一声，不知何物从高处坠落，先砸在磨盘上然后滚落到地上，骨碌碌地，滚了一段距离。 他没起身，只是定睛看着窗外那一轮晧月，然后想起自己怀中的那一轮，他双臂环抱了一下，仿佛月光被尽数拢入，脸上现出宁静的光芒。第二天一早，渔人粗粗洗了脸，吃了饭，便直奔后海那个有画的岩石群，他想知道，那支鱼叉投向了哪个方向，叉中了什么。 2我发现，每人在讲述同一件事时，多少都会掺杂自己的一些意思，根本无法还原故事本身。即便司马迁有着怀揣一颗努力还原史实本真的初愿去写《史记》的心，在遣词造句上，还是会不动声色地糅进自己的偏好。寥寥数语的，或为不熟知或觉得微不足道；浓墨重彩的，或因事件撞击了历史的支柱，本身就足够分量，愿不愿意都得费些笔墨，这两者中间的事件，就去看一些形容词的使用，那里藏着他个人的意思。 因为觉得自己粗浅，给自己取昵称时，虽然向往，却仍不太敢用那些美好来粉饰，倘若骨子里与之不匹，一来倒了众人胃口，二来再牵连着人们对这词语生出俗意，才真正难堪。细想，昵称没取过几个，但拈了来就一直未改，虽俗了些，我却愿意用日复一日积攒起来的浅浅的、羞涩的美好，从内向外开出一朵花来，纵然这花一半盛开着自卑。 名字会被一些人遇见，遇见的人会先从名字里窥一些蛛丝蚂迹。这样一想，觉得气馁，转念又想，一个人倘若真的把一个俗名让人们唤得风生水起，亦或超凡脱俗，这才是大境界，比如《红楼梦》里的宝玉。多数人的名字是代号，但一定有例外。有人因为人而记住名字，有人因名字而记住人。 3渔人徒步于岩画幽壑。页岩上每条线的刻画，都让他想到那个手拿凿斧的人，用力气与技巧勾勒出的另种意义。 这是神谕吧，他秉承着流传与启示的职责，想渡一种修为于不朽。渔人想。画面上大多的飞禽走兽识得，即或斧凿之人用了写意或象形，他也能猜出，他不关心这些，他想知道，那个单腿脆在渔船的渔人的叉被定格在何处。 有的寻找是一种无意识的驱动，计划再周详，也会有变数。这一日，他的叉松下来，斑鸠咕咕响于林隙，野鹿饮水，鸥鸟翔于海天，他的眼神只穿梭于众多线条中。……故事说到这儿，再讲述不下去。因为，听到一个声音说，将事件推至洪荒，便可无稽，这是人们惯用的伎俩，有人用来隐藏秘密，有人用来使事件合理。又想，这未免有失偏颇，生命本身就具偶然性，生命本来就是一场有去无回的无稽之谈。所以，还是继续吧。 渔人有过设想，鱼叉或者射向一种奔跑，或者逆风正穿过船畔，只是那画中人让他觉得，他忽尔是他，又忽尔不是。他拎着那把叉一寻就是十四万年，林子绿了又黄，河水解冻又冰封，他日日来此，发蓬髭虬，再后来，他自己都不知为什么来这里。 他的眼神有深夜的气象，日头再如何猖獗，他所望之处，那些被焦烤着的混沌，清的上升，浊的下沉。他的胸腔有和熙的味道，再冰冷的长夜遇到他，会自动退守，会瓦解，会让野花开了合，合了开，只是他自己不知。于是，他学着凿斧手，在一片页岩上刻下一个符号，形似一支叉。那就是我。他想。以后，他每日都会来这里，与这个符号对视。 4前几天，读到一篇《葵花》的文，文中有段话说“世上再也找不到（比葵花）更大的傻子了。”“世界上居然有那么傻的花朵，开的那么大，那么笨，拼命三郎似的，整天追逐着日头找晒，无疑是疯了，是自找毁灭”。 读完后，我一直在乐。然后想起葵花的花语：沉默的爱，没有说出口的爱。想来，这位定义葵花花语的人，一定也是个傻子。 每朵花都美好，每个美好里都有不为人知的成长历程，比如烂漫夸张的向日葵，它的花语里分明住着一株含羞草，它有颗敏感的心，有人只看到葵藿倾阳，我却觉得，它是在诠释，什么叫命定的遇见。 不必期待人人懂。懂的自然懂，不懂的说了也不懂。 5与那个符号对视得久了，渔人想要跳出一种局囿。无妄海越深邃，猎物越丰沛，也愈发让他觉得孤独，这状态夜以继日地席卷着他，看花开，看花谢，有时他觉得自己是一棵树上的叶子，风过之处，无舵无浆般随波逐流，有时又觉得自己是枚果实，丰盈的果肉包裹着一颗内核，期待绽裂。 又过数年，渔人提着叉又去与那个符号对坐，因经年循着固定的路线行走，逶逶迤迤的，在荒草夹岸的荒滩里，辟出一条小径，其中利石变得圆滚，野草顺势伏地，齐腰的青蒿散发出清凉的味道，蚊虫远之，邪气避之，绿油油的样子，让人觉得吹过的风都是凉爽的。 这天，当走那个符号前时，他下意识地一惊。他发现他的符号上隐隐被补缀了另一个图案，近看，他发现是支毛笔，毫管与叉尖相齐，毫端与叉尾相对。 6有些词于我很惊艳。被惊艳后，会念念不忘。会在心里生出根，生出枝杈，会在某个合适的情境中将它安放。是什么力量在暗中让人一遍遍索引一种未知，比如说，深夜时候潜入的梦，白天的时候一晃而过的无意识的念头，又比如，那惊艳到我的字符触动了哪根弦，一个短瞬，迸发出高于感观与触觉的异常兴奋。 科学家的血液里藏有异冷的因子。他们平静地排列组合一堆数字时，理性的让人悲观，在他们得到的结论不符合我的想法时，我宁愿相信前世，或者玄学，那里住着另一个我，和那另一个我的过往世界，我如何舍得割舍与她的因果缘缘。 “生命的实质似乎是绝望与惊骇”，这话又真实的让人生怯，无所谓对与错吧，谁又知道谁经历了什么，又有几个人能够跳出一种局限，放眼于一种阔大，我们都是蝼蚁吧，按部就班地生活，所有的经历与眼界放进宇宙中，会另人发笑从而闭嘴。 我想，如果，另个我真的存在于三界之内，我想知道，她可常常像我一般，想念而向往，心照不宣又如影随形。 7然后，渔人突然有了写字的冲动，或者说，有了倾诉的愿望。于是树木与岩壁随处可见他的文，有的三五言，有的成阙成赋。 又过百十万年，有一天在渡口遇一中榜书生返乡，两个一见如故，一番寒暄后，竟是同乡又是同枝。 于是邀至家，秉烛夜话，酒到酣处，书生舞叉，渔人弄墨，书生褪去长衫，渔人瞥见他的肩头有一胎记，形似一支渔叉。 8故事到此就结束了。敲完这些文字，当晚有梦，梦见似是而非的自己亲临了一个梦境，梦境里有大片的月光，大片的海水，大片的沙滩。还梦到，我在沙滩上睡成贝壳的姿势，他在长一声短一声唤我的名字。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础]]></title>
    <url>%2F2016%2F07%2F13%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[面向对象铺垫-对象创建方式总结第一种：创建对象的方式，json方式123456789101112131415161718//推荐使用的场合： 作为函数的参数，临时只用一次的场景。比如设置函数原型对象。var obj = &#123;&#125;;//对象有自己的 属性 和 行为// 属性比如： 年龄、姓名、性别// 行为： 吃饭、睡觉、走路、讲课等... 动作var obj2 = &#123; name: &apos;laoma&apos;, age: 18, sayHi: function()&#123; console.log( name + &apos;say hi&apos; ); &#125;&#125;;//添加其他属性：obj2.newProp = 123;// js的动态特性，如果没有要访问的属性，直接添加属性。// 缺点： 不能作为对象创建的模板，也就是不能用new进行构造新对象。//================================================= 第二种： 创建面向对象的方式： new Object()的方式。 不推荐使用。12345678var obj3 = new Object();//添加属性obj3.name = &apos;kitty&apos;;obj3.sayHi = function() &#123; console.log( name + &apos; &apos; + &apos;say hi&apos;);&#125;;//跟上面的方式一样，只能临时用一下这个对象，不想作为new的构造模板是可以的。 第三种： 构造函数构造对象方法12345678910111213141516171819202122//把 一个函数对象 当做构造函数来使用，一般要把 函数对象的首字母大写function Persion() &#123; this.name = &apos;123&apos;; // 通过this可以直接给 构造出来的对象添加属性。 this.sayHi = function() &#123; console.log( this.name ); &#125;;&#125; var p = new Persion(); //** new 运算符的作用：// 第一步：// 执行构造函数（new后面的那个函数），在构//造函数内部创建一个空对象，// 第二步： 把上面的空对象跟构造函数的原型对象进行关联。// 第三步：然后把this 指向当前空对象//在构造函数执行结束后，把空对象返回 给 pconsole.log( p.name ); //p.name 从构造函数里面创建的。p.sayHi(); //在此方法内部的 this执行 p对象。//绘制原型 和 构造函数 和对象之间的关系。 第三种方式的升级改造版本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//第三种方式有个缺点： 对象的内部的函数会在每个对象中都存一份//如果创建的对象非常多的话，那么非常浪费内存。函数的行为是所有对象//可以共有，不需要每个对象都保存一份。所以，可以把函数放到原型中//进行声明，那么所有对象都有了公共的函数，而且内存中只保留一份。//所有的属性写到对象的内部//第三种的升级版：function Sprite() &#123; this.name = &apos;123&apos;; this.age = 19;&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function() &#123; &#125;&#125;;//继续升级： 把属性的设置做成参数化：function Sprite( sname, sage ) &#123; this.name = sname || &apos;&apos;; this.age = sage || 18;&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function() &#123; &#125;&#125;;//问题： 1、调用者如果传递参数的顺序发生变化，那么废了//问题： 2、 参数增减都会导致函数声明变化，调用的地方也可能发生变化。//如何解决：继续升级function Sprite( option ) &#123; //我用一个对象把所有参数覆盖。灵活性就很强了。 //顺序无所谓，添加参数也无所谓了。 this.name = option.sname || &apos;&apos;; this.age = option.sage || 18;&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function() &#123; &#125;&#125;;//继续优化，把初始化的代码 放到init函数中function Sprite( option ) &#123; //我用一个对象把所有参数覆盖。灵活性就很强了。 //顺序无所谓，添加参数也无所谓了。 this.init( option );&#125;Sprite.prototype = &#123; sayHi: function() &#123; &#125;, init: function( option ) &#123; this.name = option.sname || &apos;&apos;; this.age = option.sage || 18; &#125;&#125;;//以后的canvas课程的开发暂时先用这种的方式 补充js方法调用的四种模式 方法调用模式 12345678910111213141516function Persion() &#123; var name1 = &quot;itcast&quot;, age1 = 19, show1 = function() &#123; console.log(this.name); &#125;; return &#123; age : age1, name : name1, show : show1 &#125;;&#125;var p = new Persion();p.show(); //在show方法中的this指向了p对象。 函数调用模式 1234567function add( a, b) &#123; this.result = a + b;&#125;add( 3, 9 ); //此方法执行的时候，this指向了windowconsole.log(result); 构造器调用模式 12345678910function Persion（）&#123; this.name = &quot;123&quot;; this.age = 19; this.show = function()&#123; console.log(this.name); &#125;;&#125;var p = new Persion();p.show();// 在show方法中方法this，指向了p对象实例。 call 和 apply调用模式 123456789function add(a,b)&#123; this.result = a + b;s &#125;var p = &#123;&#125;; //定义一个空对象。add.call(p,3,4); //在这个方法调用的时候，this指向了pconsole.log(p.result);//apply和call是一样的用法，只不过apply第二个参数用数组进行传递。 变量提升：函数执行之前，会先将函数中所有的变量，挪到最前面去声明。 函数名提升： script中脚本，在执行之前，会先把脚本中的所有的函数先进行编译解析，然后执行普通的js代码。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class的基本语法]]></title>
    <url>%2F2016%2F07%2F05%2Fclass%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.简介JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;&#125;;var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5 的构造函数Point，对应 ES6 的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。123456class Point &#123; // ...&#125;typeof Point // &quot;function&quot;Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。12345678class Bar &#123; doStuff() &#123; console.log(&apos;stuff&apos;); &#125;&#125;var b = new Bar();b.doStuff() // &quot;stuff&quot; 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。123456789101112131415161718192021class Point &#123; constructor() &#123; // ... &#125; toString() &#123; // ... &#125; toValue() &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor() &#123;&#125;, toString() &#123;&#125;, toValue() &#123;&#125;,&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 Point.prototype.constructor === Point // true另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。123456789101112var Point = function (x, y) &#123; // ...&#125;;Point.prototype.toString = function() &#123; // ...&#125;;Object.keys(Point.prototype)// [&quot;toString&quot;]Object.getOwnPropertyNames(Point.prototype)// [&quot;constructor&quot;,&quot;toString&quot;] 上面代码采用 ES5 的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。1234567891011let methodName = &apos;getArea&apos;;class Square &#123; constructor(length) &#123; // ... &#125; [methodName]() &#123; // ... &#125;&#125; 上面代码中，Square类的方法名getArea，是从表达式得到的。 严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式。 constructor 方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。1234567class Point &#123;&#125;// 等同于class Point &#123; constructor() &#123;&#125;&#125; 上面代码中，定义了一个空的类Point，JavaScript 引擎会自动为它添加一个空的constructor方法。 constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;new Foo() instanceof Foo// false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。12345678class Foo &#123; constructor() &#123; return Object.create(null); &#125;&#125;Foo()// TypeError: Class constructor Foo cannot be invoked without &apos;new&apos; 类的实例对象生成类的实例对象的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错。123456789class Point &#123; // ...&#125;// 报错var point = Point(2, 3);// 正确var point = new Point(2, 3); 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。12345678910111213141516171819202122//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;; &#125;&#125;var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty(&apos;x&apos;) // truepoint.hasOwnProperty(&apos;y&apos;) // truepoint.hasOwnProperty(&apos;toString&apos;) // falsepoint.__proto__.hasOwnProperty(&apos;toString&apos;) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。12345var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__//true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以proto属性是相等的。 这也意味着，可以通过实例的proto属性为“类”添加方法。 proto 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。12345678910var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__.printName = function () &#123; return &apos;Oops&apos; &#125;;p1.printName() // &quot;Oops&quot;p2.printName() // &quot;Oops&quot;var p3 = new Point(4,2);p3.printName() // &quot;Oops&quot; 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的proto属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。 Class 表达式与函数一样，类也可以使用表达式的形式定义。12345const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类。123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ };采用 Class 表达式，可以写出立即执行的 Class。1234567891011let person = new class &#123; constructor(name) &#123; this.name = name; &#125; sayName() &#123; console.log(this.name); &#125;&#125;(&apos;张三&apos;);person.sayName(); // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。 不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。12new Foo(); // ReferenceErrorclass Foo &#123;&#125; 上面代码中，Foo类使用在前，定义在后，这样会报错，因为 ES6 不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 私有方法和私有属性现有的方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。1234567891011121314151617const bar = Symbol(&apos;bar&apos;);const snaf = Symbol(&apos;snaf&apos;);export default class myClass&#123; // 公有方法 foo(baz) &#123; this[bar](baz); &#125; // 私有方法 [bar](baz) &#123; return this[snaf] = baz; &#125; // ...&#125;; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 私有属性的提案与私有方法一样，ES6 不支持私有属性。目前，有一个提案，为class加了私有属性。方法是在属性名之前，使用#表示。12345678910class Point &#123; #x; constructor(x = 0) &#123; #x = +x; // 写成 this.#x 亦可 &#125; get x() &#123; return #x &#125; set x(value) &#123; #x = +value &#125;&#125; 上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。 私有属性可以指定初始值，在构造函数执行时进行初始化。123456class Point &#123; #x = 0; constructor() &#123; #x; // 0 &#125;&#125; 之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 Decorator。 该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。1234567class Foo &#123; #a; #b; #sum() &#123; return #a + #b; &#125; printSum() &#123; console.log(#sum()); &#125; constructor(a, b) &#123; #a = a; #b = b; &#125;&#125; 上面代码中，#sum()就是一个私有方法。 另外，私有属性也可以设置 getter 和 setter 方法。12345678910111213class Counter &#123; #xValue = 0; get #x() &#123; return #xValue; &#125; set #x(value) &#123; this.#xValue = value; &#125; constructor() &#123; super(); // ... &#125;&#125; 上面代码中，#x是一个私有属性，它的读写都通过get #x()和set #x()来完成。 this 的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。12345678910111213class Logger &#123; printName(name = &apos;there&apos;) &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property &apos;print&apos; of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。123456789class Logger &#123; constructor() &#123; this.printName = (name = &apos;there&apos;) =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== &apos;function&apos;) &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); name 属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。12class Point &#123;&#125;Point.name // &quot;Point&quot; name属性总是返回紧跟在class关键字后面的类名。 Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。12345678910111213141516171819class MyClass &#123; constructor() &#123; // ... &#125; get prop() &#123; return &apos;getter&apos;; &#125; set prop(value) &#123; console.log(&apos;setter: &apos;+value); &#125;&#125;let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// &apos;getter&apos; 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的 Descriptor 对象上的。1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, &quot;html&quot;);&quot;get&quot; in descriptor // true&quot;set&quot; in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。 Class 的 Generator 方法如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo(&apos;hello&apos;, &apos;world&apos;)) &#123; console.log(x);&#125;// hello// world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class 的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。1234567891011class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;Foo.classMethod() // &apos;hello&apos;var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。12345678910111213class Foo &#123; static bar () &#123; this.baz(); &#125; static baz () &#123; console.log(&apos;hello&apos;); &#125; baz () &#123; console.log(&apos;world&apos;); &#125;&#125;Foo.bar() // hello 上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。 父类的静态方法，可以被子类继承。12345678910class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123;&#125;Bar.classMethod() // &apos;hello&apos; 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。12345678910111213class Foo &#123; static classMethod() &#123; return &apos;hello&apos;; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + &apos;, too&apos;; &#125;&#125;Bar.classMethod() // &quot;hello, too&quot; Class 的静态属性和实例属性静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。12345class Foo &#123;&#125;Foo.prop = 1;Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。12345678910// 以下两种写法都无效class Foo &#123; // 写法一 prop: 2 // 写法二 static prop: 2&#125;Foo.prop // undefined 目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。 ###（1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。1234567class MyClass &#123; myProp = 42; constructor() &#123; console.log(this.myProp); // 42 &#125;&#125; 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。12345678class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; 上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。12345class ReactCounter extends React.Component &#123; state = &#123; count: 0 &#125;;&#125; 这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。123456789class ReactCounter extends React.Component &#123; state; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125;&#125; （2）类的静态属性类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。1234567class MyClass &#123; static myStaticProp = 42; constructor() &#123; console.log(MyClass.myStaticProp); // 42 &#125;&#125; 同样的，这个新写法大大方便了静态属性的表达。12345678910// 老写法class Foo &#123; // ...&#125;Foo.prop = 1;// 新写法class Foo &#123; static prop = 1;&#125; 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 new.target 属性new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error(&apos;必须使用 new 命令生成实例&apos;); &#125;&#125;var person = new Person(&apos;张三&apos;); // 正确var notAPerson = Person.call(person, &apos;张三&apos;); // 报错 上面代码确保构造函数只能通过new命令调用。 Class 内部调用new.target，返回当前 Class。123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。1234567891011121314class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); // ... &#125;&#125;class Square extends Rectangle &#123; constructor(length) &#123; super(length, length); &#125;&#125;var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。1234567891011121314151617class Shape &#123; constructor() &#123; if (new.target === Shape) &#123; throw new Error(&apos;本类不能实例化&apos;); &#125; &#125;&#125;class Rectangle extends Shape &#123; constructor(length, width) &#123; super(); // ... &#125;&#125;var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[konva节选]]></title>
    <url>%2F2016%2F06%2F27%2FKonva%E8%8A%82%E9%80%89%2F</url>
    <content type="text"><![CDATA[形状/Shape矩形/Rect矩形的创建： var rect = new Konva.Rect({ // 定位属性，左上宽高 x: 50, y: 50, width: 100, height: 50, // 样式属性 fill: &apos;green&apos;, // 填充色 stroke: &apos;black&apos;, // 描边色 strokeWidth: 4 // 描边宽度 }); 线/Line线的创建： var redLine = new Konva.Line({ // 定位属性，每两个数值决定一个点 points: [5, 70, 140, 23, 250, 60, 300, 20], // 样式属性 stroke: &apos;red&apos;, strokeWidth: 15, lineCap: &apos;round&apos;, // 即线条的起点和终点的样式 lineJoin: &apos;round&apos;, // 每个折点的样式 dash: [33, 10], // 虚线样式，这里指每隔33个单位，有10个单位的间隔 // 闭合，可以用于绘制不规则多边形 fill: &apos;#00D2FF&apos;, closed : true, // 平滑度 越低过渡越平滑 tension : 1, }); 图片/Imagevar img = new Konva.Image({ // 定位属性 x: 50, y: 50, width: 106, height: 118, // 资源属性 接收一个Image对象（标签） image: imageObj, }); 文字/Textvar simpleText = new Konva.Text({ // 定位属性 x: stage.getWidth() / 2, y: 15, // 文本内容 text: &apos;Simple Text&apos;, // 字体样式 fontSize: 30, // 字体大小 fontFamily: &apos;Calibri&apos;, // 字体 fill: &apos;green&apos; // 填充颜色 }); 事件/Event绑定事件obj.on(&apos;click&apos;, function() { ... }); obj.on(&apos;tap.s&apos;, function() { ... }); 移除事件obj.off(&apos;click&apos;) obj.off(&apos;.s&apos;) 判定区域形状可以为hitFunc属性添加一个函数，用于自定义一个形状的点击判定区域。 hitFunc: function(context) { context.beginPath(); context.arc(0, 0, this.getOuterRadius() + 10, 0, Math.PI * 2, true); context.closePath(); context.fillStrokeShape(this); } 动画Tween动画创建var tween = new Konva.Tween({ node: rect, // 目标节点 duration: 1, // 动画时间 // 结束时的属性 x: 140, y: 90, fill : &apos;red&apos;, rotation: Math.PI * 2, opacity: 1, strokeWidth: 6, scaleX: 1.5， // 动画结束时的回调 onFinish:finishFn }); 控制tween对象自带六种方法，用于控制动画播放： play()播放, pause()暂停, reverse()反转, reset()重置, finish()结束 Animation动画创建Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间。 var anim = new Konva.Animation(function(frame) { var time = frame.time, // 动画执行的总时间 timeDiff = frame.timeDiff, // 距离上一帧的时间 frameRate = frame.frameRate; // 帧率（既1000/间隔时间） // update stuff }, layer); anim.start(); 控制animation对象提供start()和stop()两个方法。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>konva</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6编程风格]]></title>
    <url>%2F2016%2F06%2F22%2FECMAScript6%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[1.块级作用域（1）let 取代 varES6 提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 123456789&apos;use strict&apos;;if (true) &#123; let x = &apos;hello&apos;;&#125;for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125; 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。123456&apos;use strict&apos;;if (true) &#123; console.log(x); // ReferenceError let x = &apos;hello&apos;;&#125; 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 （2）全局常量和线程安全在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。12345678910// badvar a = 1, b = 2, c = 3;// goodconst a = 1;const b = 2;const c = 3;// bestconst [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript 可能会有多线程的实现（比如 Intel 公司的 River Trail 那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 2.字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。1234567891011// badconst a = &quot;foobar&quot;;const b = &apos;foo&apos; + a + &apos;bar&apos;;// acceptableconst c = `foobar`;// goodconst a = &apos;foobar&apos;;const b = `foo$&#123;a&#125;bar`;const c = &apos;foobar&apos;; 3.解构赋值使用数组成员对变量赋值时，优先使用解构赋值。12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。1234567891011121314// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125; 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。1234567891011// badfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// goodfunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 4.对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。12345678910111213// badconst a = &#123; k1: v1, k2: v2, &#125;;const b = &#123; k1: v1, k2: v2&#125;;// goodconst a = &#123; k1: v1, k2: v2 &#125;;const b = &#123; k1: v1, k2: v2,&#125;; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。1234567891011// badconst a = &#123;&#125;;a.x = 3;// if reshape unavoidableconst a = &#123;&#125;;Object.assign(a, &#123; x: 3 &#125;);// goodconst a = &#123; x: null &#125;;a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。12345678910111213// badconst obj = &#123; id: 5, name: &apos;San Francisco&apos;,&#125;;obj[getKey(&apos;enabled&apos;)] = true;// goodconst obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true,&#125;; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。1234567891011121314151617181920212223var ref = &apos;some value&apos;;// badconst atom = &#123; ref: ref, value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; ref, value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 5.数组使用扩展运算符（…）拷贝数组。1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用 Array.from 方法，将类似数组的对象转为数组。12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 6.函数立即执行函数可以写成箭头函数的形式。123(() =&gt; &#123; console.log(&apos;Welcome to the Internet.&apos;);&#125;)(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。123456789101112// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x;&#125;);// best[1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this。1234567891011// badconst self = this;const boundMethod = function(...params) &#123; return method.apply(self, params);&#125;// acceptableconst boundMethod = method.bind(this);// bestconst boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用默认值语法设置函数参数的默认值。123456789// badfunction handleThings(opts) &#123; opts = opts || &#123;&#125;;&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 7.Map 结构注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。12345678910111213let map = new Map(arr);for (let key of map.keys()) &#123; console.log(key);&#125;for (let value of map.values()) &#123; console.log(value);&#125;for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125; 8.Class总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。123456789101112131415161718192021// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。12345678910111213141516// badconst inherits = require(&apos;inherits&apos;);function PeekableQueue(contents) &#123; Queue.apply(this, contents);&#125;inherits(PeekableQueue, Queue);PeekableQueue.prototype.peek = function() &#123; return this._queue[0];&#125;// goodclass PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125;&#125; 9.模块首先，Module 语法是 JavaScript 模块的标准写法，坚持使用这种写法。使用import取代require。1234567// badconst moduleA = require(&apos;moduleA&apos;);const func1 = moduleA.func1;const func2 = moduleA.func2;// goodimport &#123; func1, func2 &#125; from &apos;moduleA&apos;; 使用export取代module.exports。123456789101112131415161718192021// commonJS的写法var React = require(&apos;react&apos;);var Breadcrumbs = React.createClass(&#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;);module.exports = Breadcrumbs;// ES6的写法import React from &apos;react&apos;;class Breadcrumbs extends React.Component &#123; render() &#123; return &lt;nav /&gt;; &#125;&#125;;export default Breadcrumbs; 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。12345// badimport * as myObject from &apos;./importModule&apos;;// goodimport myObject from &apos;./importModule&apos;; 如果模块默认输出一个函数，函数名的首字母应该小写。1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。123456const StyleGuide = &#123; es6: &#123; &#125;&#125;;export default StyleGuide; 10.ESLint 的使用ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装 ESLint。 $ npm i -g eslint然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。12$ npm i -g eslint-config-airbnb$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react 最后，在项目的根目录下新建一个.eslintrc文件，配置 ESLint。123&#123; &quot;extends&quot;: &quot;eslint-config-airbnb&quot;&#125; 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。12345678var unusued = &apos;I have no purpose!&apos;;function greet() &#123; var message = &apos;Hello, World!&apos;; alert(message);&#125;greet(); 使用 ESLint 检查这个文件，就会报出错误。123456789$ eslint index.jsindex.js 1:1 error Unexpected var, use let or const instead no-var 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 4:5 error Unexpected var, use let or const instead no-var 5:5 error Expected indentation of 2 characters but found 4 indent✖ 5 problems (5 errors, 0 warnings) 上面代码说明，原文件有五个错误，其中两个是不应该使用var命令，而要使用let或const；一个是定义了变量，却没有使用；另外两个是行首缩进为 4 个空格，而不是规定的 2 个空格。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas基础笔记]]></title>
    <url>%2F2016%2F06%2F12%2Fcanvas%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、canvas简介1.1 什么是canvas？（了解） 是HTML5提供的一种新标签 12&lt;canvas&gt;&lt;/canvas&gt; 英 [&apos;kænvəs] 美 [&apos;kænvəs] 帆布 画布 Canvas是一个矩形区域的画布，可以用JavaScript在上面绘画。控制其每一个像素。 canvas 标签使用 JavaScript 在网页上绘制图像，本身不具备绘图功能。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 HTML5之前的web页面只能用一些固定样式的标签：比如p、div、h1等 1.2 canvas主要应用的领域（了解） 游戏：canvas在基于Web的图像显示方面比Flash更加立体、更加精巧，canvas游戏在流畅度和跨平台方面更牛。 25 超棒的 HTML5 Canvas 游戏 可视化数据.数据图表话，比如:百度的echart banner广告：Flash曾经辉煌的时代，智能手机还未曾出现。现在以及未来的智能机时代，HTML5技术能够在banner广告上发挥巨大作用，用Canvas实现动态的广告效果再合适不过。 未来=&gt; 模拟器：无论从视觉效果还是核心功能方面来说，模拟器产品可以完全由JavaScript来实现。 未来=&gt; 远程计算机控制：Canvas可以让开发者更好地实现基于Web的数据传输，构建一个完美的可视化控制界面。 未来=&gt; 图形编辑器：Photoshop图形编辑器将能够100%基于Web实现。 其他可嵌入网站的内容(多用于活动页面、特效)：类似图表、音频、视频，还有许多元素能够更好地与Web融合，并且不需要任何插件。 完整的canvas移动化应用 我们课程的目标 我们不是主要做游戏开发的 要求必须会做基本的用canvas绘制的特效页面：比如，传智前端官网。 会用canvas做一些简单的广告、活动页面 我们课程的案例和项目演示 canvas的标准： 最新标准：http://www.w3.org/TR/2dcontext/ 稳定版本的标准：http://www.w3.org/TR/2013/CR-2dcontext-20130806/ 目前来说，标准还在完善中。先用早期的api足够完成所有的应用二、canvas绘图基础 2.0 sublime配置canvas插件（推荐）推荐： 安装插件：AndyJS2 github地址： https://github.com/malun666/AndyJS2 直接下载到：X:\Users\用户名\AppData\Roaming\Sublime Text 3\Packages 2.1 Canvas标签2.1.1 canvas标签语法和属性 （重点） canvas：画布油布的意思 ==英 [‘kænvəs] 美 [‘kænvəs] == 标签名canvas，需要进行闭合。就是一普通的html标签。 可以设置width和height属性，但是属性值单位必须是px，否则忽略。 width和hegiht：默认300*150像素 注意： 不要用CSS控制它的宽和高,会走出图片拉伸， 重新设置canvas标签的宽高属性会让画布擦除所有的内容。 可以给canvas画布设置背景色 2.1.2 浏览器不兼容处理（重点） ie9以上才支持canvas, 其他chrome、ff、苹果浏览器等都支持 只要浏览器兼容canvas，那么就会支持绝大部分api(个别最新api除外) 移动端的兼容情况非常理想，基本上随便使用 2d的支持的都非常好，3d（webgl）ie11才支持，其他都支持 如果浏览器不兼容，最好进行友好提示 1234例如： &lt;canvas id=&quot;cavsElem&quot;&gt; 你的浏览器不支持canvas，请升级浏览器.浏览器不支持，显示此行文本&lt;/canvas&gt; 浏览器不兼容，可以使用flash等手段进行优雅降级 2.2 canvas绘图上下文context2.2.1 Context：Canvas的上下文、绘制环境。（重点掌握） 上下文：上知天文，下知地理。是所有的绘制操作api的入口或者集合。 Canvas自身无法绘制任何内容。Canvas的绘图是使用JavaScript操作的。 Context对象就是JavaScript操作Canvas的接口。*使用[CanvasElement].getContext(‘2d’)来获取2D绘图上下文。 12var canvas = document.getElementById( &apos;cavsElem&apos; ); //获得画布var ctx = canvas.getContext( &apos;2d&apos; );//注意：2d小写， 3d：webgl 2.3 基本的绘制路径（重点）2.3.1 canvas坐标系canvas坐标系，从最左上角0,0开始。x向右增大， y向下增大 2.3.2 设置绘制起点(moveTo)* 语法：ctx.moveTo(x, y); * 解释：设置上下文绘制路径的起点。相当于移动画笔到某个位置 * 参数：x,y 都是相对于 canvas盒子的最左上角。 * 注意：**绘制线段前必须先设置起点。** 2.3.3 绘制直线(lineTo)* 语法：ctx.lineTo(x, y); * 解释：从x,y的位置绘制一条直线到起点或者上一个线头点。 * 参数：x,y 线头点坐标。 2.3.4 路径开始和闭合* 开始路径：ctx.beginPath(); * 闭合路径：ctx.closePath(); * 解释：如果是绘制不同状态的线段或者形状，必须使用开始新路径的方法把不同的绘制操作隔开。闭合路径会自动把最后的线头和开始的线头连在一起。 * beginPath: 核心的作用是将 不同绘制的形状进行隔离， 每次执行此方法，表示重新绘制一个路径,跟之前的绘制的墨迹可以进行分开样式设置和管理。 2.3.5 描边(stroke)* 语法：ctx.stroke(); * 解释：根据路径绘制线。路径只是草稿，真正绘制线必须执行stroke * stroke: （用笔等）画；轻抚；轻挪；敲击；划尾桨；划掉；（打字时）击打键盘 英 [strəʊk] 美 [strok] canvas绘制的基本步骤： 第一步：获得上下文 =&gt;canvasElem.getContext(‘2d’); 第二步：开始路径规划 =&gt;ctx.beginPath() 第三步：移动起始点 =&gt;ctx.moveTo(x, y) 第四步：绘制线(矩形、圆形、图片…) =&gt;ctx.lineTo(x, y) 第五步：闭合路径 =&gt;ctx.closePath(); 第六步：绘制描边 =&gt;ctx.stroke();1234567891011121314151617181920212223html部分： &lt;canvas id=&quot;cavsElem&quot;&gt; 你的浏览器不支持canvas，请升级浏览器 &lt;/canvas&gt;javascript部分：//===============基本绘制api====================//获得画布var canvas = document.querySelector(&apos;#cavsElem&apos;);var ctx = canvas.getContext(&apos;2d&apos;); //获得上下文canvas.width = 900; //设置标签的属性宽高canvas.height = 600; //千万不要用 canvas.style.heightcanvas.style.border = &quot;1px solid #000&quot;;//绘制三角形ctx.beginPath(); //开始路径ctx.moveTo(100,100); //三角形，左顶点ctx.lineTo(300, 100); //右顶点ctx.lineTo(300, 300); //底部的点ctx.closePath(); //结束路径ctx.stroke(); //描边路径 综合案例：02绘制定位表格.html 综合案例：03画画板.html 2.3.7 填充(fill)* 语法：ctx.fill(); * 解释：填充，是将闭合的路径的内容填充具体的颜色。默认黑色。 * 注意：交叉路径的填充问题，“非零环绕原则”，顺逆时针穿插次数决定是否填充。 以下是非0环绕原则的原理：（了解即可，非常少会用到复杂的路径） “非零环绕规则”是这么来判断有自我交叉情况的路径的：对于路径中的任意给定区域，从该区域内部画一条足够长的线段， 使此线段的终点完全落在路径范围之外。 图2-14中的那三个箭头所描述的就是上面这个步骤。 接下来，将计数器初始化为0， 然后，每当这条线段与路径上的直线或曲线相交时， 就改变计数器的值。如果是与路径的顺时针部分相交，则加1， 如果是与路径的逆时针部分相交，则减1。若计数器的最终值不是0，那么此区域就在路径里面，在调用fill()方法时， 浏览器就会对其进行填充。 如果最终值是0，那么此区域就不在路径内部，浏览器也就不会对其进行填充了 * 案例： 04填充矩形.html 2.3.8 快速创建矩形rect()方法* 语法：ctx.rect(x, y, width, height); * 解释：x, y是矩形左上角坐标， width和height都是以像素计 * rect方法只是规划了矩形的路径，并没有填充和描边。 * 改造案例：04填充矩形.html *rect: abbr. 矩形（rectangular）；收据（receipt） 2.3.9 快速创建描边矩形和填充矩形* 语法： ctx.strokeRect(x, y, width, height); - 参数跟2.3.8相同，注意此方法绘制完路径后立即进行stroke绘制 * 语法：ctx.fillRect(x, y, width, height); - 参数跟2.3.8相同， 此方法执行完成后。立即对当前矩形进行fill填充。 2.3.10 清除矩形(clearRect)* 语法：ctx.clearRect(x, y, width, hegiht); * 解释：清除某个矩形内的绘制的内容，相当于橡皮擦。 2.4 绘制圆形（arc) 概述：arc() 方法创建弧/曲线（用于创建圆或部分圆）。 语法：ctx.arc(x,y,r,sAngle,eAngle,counterclockwise); arc: 弧（度）弧形物；天穹 英 [ɑːk] 美 [ɑrk] counter 反击，还击；反向移动，对着干；反驳，回答 [‘kaʊntə] 美 [‘kaʊntɚ] 解释： x,y：圆心坐标。 r：半径大小。 sAngle:绘制开始的角度。 圆心到最右边点是0度，顺时针方向弧度增大。 eAngel:结束的角度，注意是弧度。π counterclockwise：是否是逆时针。true是逆时针，false：顺时针 弧度和角度的转换公式： rad = deg*Math.PI/180; 在Math提供的方法中sin、cos等都使用的弧度 案例：05绘制圆形.html 案例：06绘制饼状图.html 2.5 绘制文字（会使用就可以了）2.5.1 绘制上下文的文字属性 （有印象就行了） font 设置或返回文本内容的当前字体属性 font 属性使用的语法与 CSS font 属性相同。1例如：ctx.font = &quot;18px &apos;微软雅黑&apos;&quot;; textAlign 设置或返回文本内容的当前对齐方式 start : 默认。文本在指定的位置开始。 end : 文本在指定的位置结束。 center: 文本的中心被放置在指定的位置。 left : 文本左对齐。 right : 文本右对齐。 1* 例如：ctx.textAlign = &apos;left&apos;; textBaseline 设置或返回在绘制文本时使用的当前文本基线 alphabetic ： 默认。文本基线是普通的字母基线。 top ： 文本基线是 em 方框的顶端。。 hanging ： 文本基线是悬挂基线。 middle ： 文本基线是 em 方框的正中。 ideographic： 文本基线是em基线。 bottom ： 文本基线是 em 方框的底端。 1234例如： ctx.textBaseline = &apos;top&apos;;单词: alphabetic: 字母的；照字母次序的 [,ælfə&apos;bɛtɪk] ideographic：表意的；表意字构成的 英 [,ɪdɪəʊ&apos;ɡræfɪk] 美 [,ɪdɪə&apos;græfɪk] 2.5.2 上下文绘制文字方法* ctx.fillText() 在画布上绘制“被填充的”文本 * ctx.strokeText() 在画布上绘制文本（无填充） * ctx.measureText() 返回包含指定文本宽度的对象 * 单词：measure 测量；估量；权衡 英 [&apos;meʒə] 美 [&apos;mɛʒɚ] 12345678//综合案例代码：ctx.moveTo( 300, 300 );ctx.fillStyle = &quot;purple&quot;; //设置填充颜色为紫色ctx.font = &apos;20px &quot;微软雅黑&quot;&apos;; //设置字体ctx.textBaseline = &quot;bottom&quot;; //设置字体底线对齐绘制基线ctx.textAlign = &quot;left&quot;; //设置字体对齐的方式//ctx.strokeText( &quot;left&quot;, 450, 400 );ctx.fillText( &quot;Top-g&quot;, 100, 300 ); //填充文字 2.5.3 案例07文字绘制.html 2.6 绘制图片（drawImage） （重点）2.6.1 基本绘制图片的方式context.drawImage(img,x,y); 参数说明： x,y 绘制图片左上角的坐标， img是绘制图片的dom对象。 2.6.2 在画布上绘制图像，并规定图像的宽度和高度context.drawImage(img,x,y,width,height); 参数说明：width 绘制图片的宽度， height：绘制图片的高度 如果指定宽高，最好成比例，不然图片会被拉伸&lt;/em&gt; 等比公式： toH = Height * toW / Width; //等比 设置高 = 原高度 * 设置宽/ 原宽度; 2.6.3 图片裁剪，并在画布上定位被剪切的部分context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数说明： sx,sy 裁剪的左上角坐标， swidth：裁剪图片的高度。 sheight:裁剪的高度 其他同上 2.6.4 用JavaScript创建img对象第一种方式： var img = document.getElementById(&quot;imgId&quot;); 第二种方式： var img = new Image();//这个就是 img标签的dom对象 img.src = &quot;imgs/arc.gif&quot;; img.alt = &quot;文本信息&quot;; img.onload = function() { //图片加载完成后，执行此方法 } 2.6.5 面向对象基础复习补充： 创建对象的方式： 123* var o = &#123; name: &apos;123&apos;, age: 18 &#125;; //json方式创建* var o = new Object(); //通过new的方式创建* var o = new Persion(); //通过类的构造函数创建 JS中对象的属性创建方式 12345* json的方式： var o = &#123; age: 19 &#125;;* 直接添加属性：var o = &#123;&#125;; o.age = 19;//太分散了，不利于管理* 由于js动态语言的特性，如果属性不存在的时候，直接添加属性。* 构造函数添加属性* 原型添加公共的属性 JS的构造函数的原型 构造函数的原型就是：构造对象的模板，构造函数原型里面的所有的属性和方法都会共享给所有的 构造函数构造出来的所有实例。 案例： 08绘制图片.html 案例： 09绘制图片裁剪.html 案例： 10序列帧动画.html 案例： 11面向对象版本的动画帧.html 重点 2.6.6 补充 sublime制作代码段（推荐–已结讲过了）第一步：sublime菜单栏→ 工具 → 制作代码段 第二步：修改输出的sublime代码段文本 &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[ 1、这里放要tab键 输出的内容 2、 ${1:this} 占位符，tab可以进行切换，数字是切换的索引。 ：后面的是默认的文本。 ]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;简写的字母&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt; &lt;/snippet&gt; 第三步：保存到插件的文件夹中，后缀名为：.sublime-snippet比如我存放的位置： C:\Users\malunmac\AppData\Roaming\Sublime Text 3\Packages\User\snippetssnippets是我自己新建的文件夹。 三、 canvas进阶3.1 Canvas颜色样式和阴影3.1.1 设置填充和描边的颜色（掌握） fillStyle : 设置或返回用于填充绘画的颜色 strokeStyle: 设置或返回用于笔触的颜色 以上两个值都可以接受颜色名,16进制数据，rgb值，甚至rgba.一般先进行设置样式然后进行绘制。 例如： ctx.strokeStyle = &quot;red&quot;; ctx.strokeStyle = &quot;#ccc&quot;; ctx.strokeStyle = &quot;rgb(255,0,0)&quot;; ctx.strokeStyle = &quot;rgba(255,0,0,6)&quot;; 3.1.2 设置阴影（了解，少用，性能差） 类比于CSS3的阴影。 shadowColor ： 设置或返回用于阴影的颜色 shadowBlur ： 设置或返回用于阴影的模糊级别,大于1的正整数，数值越高，模糊程度越大 shadowOffsetX： 设置或返回阴影距形状的水平距离 shadowOffsetY： 设置或返回阴影距形状的垂直距离 123456ctx.fillStyle = &quot;rgba(255,0,0, .9)&quot;ctx.shadowColor = &quot;teal&quot;;ctx.shadowBlur = 10;ctx.shadowOffsetX = 10;ctx.shadowOffsetY = 10;ctx.fillRect(100, 100, 100, 100); 例如： 案例： 12设置box盒子阴影.html 设置png图片的阴影，图片透明部分不会被投影。 3.2 复杂样式（了解）3.2.1 创建线性渐变的样式（了解） 一般不用，都是用图片代替，canvas绘制图片效率更高。 线性渐变可以用于 矩形、圆形、文字等颜色样式 线性渐变是一个对象 语法：ctx.createLinearGradient(x0,y0,x1,y1); //参数：x0,y0起始坐标，x1,y1结束坐标123456例如：//创建线性渐变的对象，var grd=ctx.createLinearGradient(0,0,170,0);grd.addColorStop(0,&quot;black&quot;); //添加一个渐变颜色，第一个参数介于 0.0 与 1.0 之间的值，表示渐变中开始与结束之间的位置。grd.addColorStop(1,&quot;white&quot;); //添加一个渐变颜色ctx.fillStyle =grd; //关键点，把渐变设置到 填充的样式 案例13设置线性渐变.html 3.2.2 设置圆形渐变（径向渐变） 了解 创建放射状/圆形渐变对象。可以填充文本、形状等 context.createRadialGradient(x0,y0,r0,x1,y1,r1); radial 半径的；放射状的；光线的；光线状的 英 [‘reɪdɪəl] 美 [‘redɪəl] 参数详解： x0: 渐变的开始圆的 x 坐标 y0: 渐变的开始圆的 y 坐标 r0: 开始圆的半径 x1: 渐变的结束圆的 x 坐标 y1: 渐变的结束圆的 y 坐标 r1: 结束圆的半径123456var rlg = ctx.createRadialGradient(300,300,10,300,300,200);rlg.addColorStop(0, &apos;teal&apos;); //添加一个渐变颜色rlg.addColorStop(.4, &apos;navy&apos;);rlg.addColorStop(1, &apos;purple&apos;);ctx.fillStyle = rlg;//设置 填充样式为延续渐变的样式ctx.fillRect(100, 100, 500, 500); 案例14圆形渐变.html 3.2.3 绘制背景图（了解） ctx.createPattern(img,repeat) 方法在指定的方向内重复指定的元素了解 pattern：n. 模式；图案；样品 英 [‘pæt(ə)n] 美 [‘pætɚn] 第一参数：设置平铺背景的图片，第二个背景平铺的方式。 image ： 规定要使用的图片、画布或视频元素。 repeat ： 默认。该模式在水平和垂直方向重复。 repeat-x ： 该模式只在水平方向重复。 repeat-y ： 该模式只在垂直方向重复。 no-repeat： 该模式只显示一次（不重复）。123456var ctx=c.getContext(&quot;2d&quot;);var img=document.getElementById(&quot;lamp&quot;);var pat=ctx.createPattern(img,&quot;repeat&quot;);ctx.rect(0,0,150,100);ctx.fillStyle=pat;// 把背景图设置给填充的样式ctx.fill(); 案例15背景图填充.html 3.3 变换（重点）3.3.1 缩放（重点） scale() 方法缩放当前绘图，更大或更小 语法：context.scale(scalewidth,scaleheight) scalewidth : 缩放当前绘图的宽度 (1=100%, 0.5=50%, 2=200%, 依次类推) scaleheight : 缩放当前绘图的高度 (1=100%, 0.5=50%, 2=200%, etc.)+注意：缩放的是整个画布，缩放后，继续绘制的图形会被放大或缩小。 案例16缩放案例.html 3.3.2 位移画布（重点） ctx.translate(x,y) 方法重新映射画布上的 (0,0) 位置 参数说明： x： 添加到水平坐标（x）上的值 y： 添加到垂直坐标（y）上的值 发生位移后，相当于把画布的0,0坐标 更换到新的x,y的位置，所有绘制的新元素都被影响。 位移画布一般配合缩放和旋转等。 案例： 17位移画布.html 3.3.3 旋转（重点） context.rotate(angle); 方法旋转当前的绘图 注意参数是弧度（PI） 如需将角度转换为弧度，请使用 degrees*Math.PI/180 公式进行计算。 案例：18旋转画布.html 3.3 绘制环境保存和还原（重要） ctx.save() 保存当前环境的状态 可以把当前绘制环境进行保存到缓存中。 ctx.restore() 返回之前保存过的路径状态和属性 获取最近缓存的ctx 一般配合位移画布使用。 案例： 19矩形旋转案例.html 3.4 设置绘制环境的透明度（了解） context.globalAlpha=number; number:透明值。必须介于 0.0（完全透明） 与 1.0（不透明） 之间。 设置透明度是全局的透明度的样式。注意是全局的。 3.5 画布限定区域绘制（了解） ctx.clip(); 方法从原始画布中剪切任意形状和尺寸 一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域） 一般配合绘制环境的保存和还原。 3.6 画布保存base64编码内容（重要） 把canvas绘制的内容输出成base64内容。 语法：canvas.toDataURL(type, encoderOptions); 例如：canvas.toDataURL(“image/jpg”,1); 参数说明： type，设置输出的类型，比如 image/png image/jpeg等 encoderOptions： 0-1之间的数字，用于标识输出图片的质量，1表示无损压缩，类型为： image/jpeg 或者image/webp才起作用。 123456789案例1：var canvas = document.getElementById(&quot;canvas&quot;);var dataURL = canvas.toDataURL();console.log(dataURL);// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;var img = document.querySelector(&quot;#img-demo&quot;);//拿到图片的dom对象img.src = canvas.toDataURL(&quot;image/png&quot;); //将画布的内容给图片标签显示 3.7 画布渲染画布（重要） context.drawImage(img,x,y); img参数也可以是画布，也就是把一个画布整体的渲染到另外一个画布上。1234567var canvas1 = document.querySelector(&apos;#cavsElem1&apos;);var canvas2 = document.querySelector(&apos;#cavsElem2&apos;);var ctx1 = canvas1.getContext(&apos;2d&apos;);var ctx2 = canvas2.getContext(&apos;2d&apos;);ctx1.fillRect(20, 20, 40, 40); //在第一个画布上绘制矩形ctx2.drawImage(canvas1, 10, 10); //将第一个画布整体绘制到第二个画布上 3.8 了解：线条样式（了解） lineCap 设置或返回线条的结束端点(线头、线冒)样式 butt ： 默认。向线条的每个末端添加平直的边缘。 翻译.：屁股；烟头；笑柄；靶垛；粗大的一端 英 [bʌt] 美 [bʌt] round ： 向线条的每个末端添加圆形线帽。 square： 向线条的每个末端添加正方形线帽。参考：23线的样式.html lineJoin 设置或返回两条线相交时，所创建的拐角类型 bevel: 创建斜角。 翻译. 斜角；斜面；[测] 斜角规 英 [‘bev(ə)l] 美 [‘bɛvl] round: 创建圆角。 miter: 默认。创建尖角 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 意思: 斜接 英 [‘maɪtə] 斜接长度指的是在两条线交汇处内角和外角之间的距离。 一般用默认值：10就可以了。除非需要特别长的尖角时，使用此属性。 3.9 了解贝塞尔曲线（知道有）3.9.1 绘制一条二次方曲线。 微软的画图板中的曲线的颜色。 quadratic：二次方的意思， 英 [kwɒ’drætɪk] 美 [kwɑ’drætɪk] Curve：曲线的意思， 英 [kɜːv] 美 [kɝv] 语法： context.quadraticCurveTo(cpx,cpy,x,y); 参数： cpx： 贝塞尔控制点的 x 坐标 cpy： 贝塞尔控制点的 y 坐标 x ： 结束点的 x 坐标 y ： 结束点的 y 坐标12345ctx.beginPath();ctx.moveTo(20,20);//绘制2次方曲线，贝赛尔曲线ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); 3.9.2 绘制贝塞尔曲线（知道有） 绘制一条三次贝塞尔曲线 语法：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y); 提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，那么请使用 beginPath() 和 moveTo() 方法来定义开始点。 参数说明： cp1x： 第一个贝塞尔控制点的 x 坐标 cp1y： 第一个贝塞尔控制点的 y 坐标 cp2x： 第二个贝塞尔控制点的 x 坐标 cp2y： 第二个贝塞尔控制点的 y 坐标 x: 结束点的 x 坐标 y: 结束点的 y 坐标 123456789101112//绘制复杂的贝塞尔曲线ctx.beginPath();ctx.moveTo(400,400);//参数说明：context.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);// cp1x： 第一个贝塞尔控制点的 x 坐标// cp1y： 第一个贝塞尔控制点的 y 坐标// cp2x： 第二个贝塞尔控制点的 x 坐标// cp2y： 第二个贝塞尔控制点的 y 坐标// x: 结束点的 x 坐标// y: 结束点的 y 坐标ctx.bezierCurveTo(500, 200, 600, 600, 700, 300);ctx.stroke(); 案例：25绘制贝塞尔曲线.html 3.10了解创建两条切线的弧（知道有） 在画布上创建介于当前起点和两个点形成的夹角的切线之间的弧 语法： context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。 例如： ctx.arcTo(240, 100, 240, 110, 40); 参数： x1: 弧的端点1的 x 坐标 y1: 弧的端点1的 y 坐标 x2: 弧的端点2(终点)的 x 坐标 y2: 弧的端点2(终点)的 y 坐标 r : 弧的半径 12345678//代码demo：ctx.beginPath();ctx.moveTo(100,100);ctx.lineTo(200,100);//context.arcTo(x1,y1,x2,y2,r); //类比：css3中的圆角。ctx.arcTo(240, 100, 240, 110, 40);ctx.lineTo(240, 300);ctx.stroke(); 3.11了解判断点是否在路径中（知道有）context.isPointInPath(x,y); //isPointInPath() 方法返回 true，如果指定的点位于当前路径中；否则返回 false。 //判断x,y坐标的点是否在当前的路径中。 3.12了解文本宽度计算（知道有）context.measureText(text).width; 3.13 如果以后做canvas游戏方向开发深入学习可以扩展内以下容： setTransform() 将当前转换重置为单位矩阵。然后运行 transform() transform() 替换绘图的当前转换矩阵 globalCompositeOperation 设置或返回新图像如何绘制到已有的图像上 像素操作 四、 Canvas开发库封装4.1封装常用的绘制函数4.1.1封装一个矩形//思考：我们用到的矩形需要哪些绘制的东西呢？ 1、矩形的 x、y坐标 2、矩形的宽高 3、矩形的边框的线条样式、线条宽度 4、矩形填充的样式 5、矩形的旋转角度 6、矩形的缩小放大 //下面是把上面所有的功能进行封装的代码： function ItcastRect( option ) {//矩形构造函数 this._init(option); } ItcastRect.prototype = { //矩形的原型对象 _init: function( option ) { //初始化方法 option = option || {}; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || &apos;silver&apos;; this.strokeStyle = option.strokeStyle || &apos;red&apos;; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; }, render: function( ctx ) {//把矩形渲染到canvas中 ctx.save(); ctx.translate( this.x, this.y );//位移画布 ctx.rotate( this.angle * Math.PI / 180 );//旋转角度 ctx.scale( this.scaleX, this.scaleY );//缩放 ctx.fillStyle = this.fillStyle; ctx.fillRect( 0, 0, this.w, this.h ); //填充矩形 ctx.lineWidth = this.strokeWidth; //线宽 ctx.strokeStyle = this.strokeStyle; //填充样式 ctx.strokeRect( 0,0,this.w,this.h ); //描边样式 ctx.restore(); }, constructor: ItcastRect }; 4.1.2作业：尝试着封装一个圆形？123456789101112131415161718192021222324252627282930313233343536373839404142//封装圆形的代码的答案：不要偷看function ItcastCircle( option ) &#123; this._init( option );&#125;ItcastCircle.prototype = &#123; _init: function( option ) &#123; option = option || &#123;&#125;; this.x = option.x === 0 ? 0 : option.x || 100; this.y = option.y === 0 ? 0 : option.y || 100; this.w = option.w || 100; this.h = option.h || 100; this.angle = option.angle === 0 ? 0 : option.angle || 0; this.fillStyle = option.fillStyle || &apos;silver&apos;; this.strokeStyle = option.strokeStyle || &apos;red&apos;; this.strokeWidth = option.strokeWidth || 4; this.scaleX = option.scaleX || 1; this.scaleY = option.Y || 1; this.opactity = option.opactity || 1; this.counterclockwise = option.counterclockwise === true ? true : option.counterclockwise || false; this.startAngle = option.startAngle == 0 ? 0 : option.startAngle || 0; this.endAngle = option.endAngle == 0 ? 0 : option.endAngle || 0; this.startAngle = this.startAngle * Math.PI/180; this.endAngle = this.endAngle * Math.PI / 180; this.r = option.r || 100; &#125;, render: function( ctx ) &#123; ctx.save(); ctx.translate( this.x, this.y); ctx.scale( this.scaleX, this.scaleY ); ctx.rotate( this.agnle * Math.PI / 180 ); ctx.globalAlpha = this.opacity; ctx.fillStyle = this.fillStyle; ctx.strokeStyle = this.strokeStyle; ctx.moveTo(0, 0); ctx.arc( 0, 0, this.r, this.startAngle, this.endAngle, this.counterclockwise); ctx.fill(); ctx.stroke(); ctx.restore(); &#125;, constructor: ItcastCircle&#125;; 4.2 第三方库使用 Rgraph vs 百度的echart 1https://roopons.com.au/wp-content/plugins/viral-optins/js/rgraph/ 国产的egret引擎 1http://www.egret-labs.org/ 比较火的3d引擎：treejs 1http://threejs.org/ Konva 12345678官网：http://konvajs.github.io/ 特点： * 小巧、使用方便、适合移动端和pc端 * 支持丰富的事件处理操作 * 支持类似JQuery的操作方式（顺带能复习jQueyr） * 开源，可以随意更改 * 社区更新比较活跃，github托管源码 * 性能也不错 其他的还有很多，希望以后能用到你们的库。 五、Konva的使用快速上手5.1 Konva的整体理念 舞台的概念的引入。整个视图看做是一个舞台 stage 舞台中可以绘制很多个层 layer layer下面可以有很多的group group下面可以有 矩形、图片、其他形状等 参看：快速上手文档—查看翻译文档1234567891011121314151617 Stage | +------+------+ | | Layer Layer | | +-----+-----+ Shape | | Group Group | | + +---+---+ | | |Shape Group Shape | + | Shape 5.2 Konva矩形案例5.2.1 创建一个矩形： Konva.Rect(option);12345678910111213141516171819202122232425262728293031323334353637383940//Konva使用的基本案例//第一步：创建舞台var stage = new Konva.Stage(&#123; container: &apos;container&apos;, //需要存放舞台的Dom容器 width: window.innerWidth, //设置全屏 height: window.innerHeight&#125;);//第二步：创建层var layer = new Konva.Layer(); //创建一个层stage.add(layer); //把层添加到舞台//第三步： 创建矩形var rect = new Konva.Rect(&#123; //创建一个矩形 x: 100, //矩形的x坐标，相对其父容器的坐标 y: 100, width: 100, //矩形的宽度 height: 100, //矩形高度 fill: &apos;gold&apos;, //矩形填充的颜色 stroke: &apos;navy&apos;, //矩形描边的颜色 strokeWidth: 4, //填充宽度 opactity: .2, //矩形的透明度 scale: 1.2, //矩形的缩放 1：原来大小 rotation: 30, //旋转的角度，是deg不是弧度。 cornerRadius: 10, //圆角的大小（像素） id: &apos;rect1&apos;, //id属性，类似dom的id属性 name: &apos;rect&apos;, draggable: true //是否可以进行拖拽&#125;);//创建一个组var group = new Konva.Group(&#123; x: 40, y: 40,&#125;);group.add( rect ); //把矩形添加到组中//第四步： 把形状放到层中layer.add( group ); //把组添加到层中layer.draw(); //绘制层到舞台上 5.3 Konva的动画系统5.3.1 tween对象(重点) tween，英文意思：两者之间， 英 [twiːn] 美 [twin] tween是控制Konva对象进行动画的核心对象。 tween可以控制所有数字类型的属性进行动画处理，比如：x, y, rotation,width, height, radius, strokeWidth, opacity, scaleX等 1234567891011121314//案例：var tween = new Konva.Tween(&#123; node: rect, //要进行动画的Konva对象 x: 300, //要进行动画的属性 opacity: .8, duration: 1, //持续时间 easing: Konva.Easings.EaseIn, //动画的动画效果 yoyo: true, //是否进行循环播放的设置 onFinish: function() &#123; //动画执行结束后，执行此方法 &#125;&#125;);tween.play(); //启动动画 tween的控制方法 tween.play(), //播放动画 tween.pause(), //暂停动画 tween.reverse(), //动画逆播放 tween.reset(), //重置动画 tween.finish(), //立即结束动画 seek：英文：寻找 英 [siːk] 美 [sik] tween的缓动控制选项 Konva.Easings.Linear //线性 Konva.Easings.EaseIn //缓动，先慢后快 Konva.Easings.EaseOut //先快后慢 Konva.Easings.EaseInOut //两头慢，中间快 Konva.Easings.BackEaseIn //往回来一点，然后往前冲，汽车启动类似… Konva.Easings.BackEaseOut Konva.Easings.BackEaseInOut Konva.Easings.ElasticEaseIn //橡皮筋 英 [ɪ’læstɪk] 美 [ɪ’læstɪk] Konva.Easings.ElasticEaseOut Konva.Easings.ElasticEaseInOut Konva.Easings.BounceEaseIn //弹跳；弹起，反跳；弹回 英 [baʊns] 美 [baʊns] Konva.Easings.BounceEaseOut Konva.Easings.BounceEaseInOut Konva.Easings.StrongEaseIn //强力 Konva.Easings.StrongEaseOut Konva.Easings.StrongEaseInOut 动画效果参考： 29Konva动画缓动效果案例.html 5.3.2 动画to的使用 to就是对tween的封装，比较简单好用。1234567891011121314151617181920212223//案例：var rect = new Konva.Rect(&#123; x: 10, y: 10, width: 100, height: 100, fill: &apos;red&apos;&#125;);layer.add(rect);layer.draw();//动画系统rect.to(&#123; x: 100, y: 100, opactity: .1, duration: 3, onFinish: function() &#123; &#125;&#125;);//to: 就是对tween的简单应用。 5.3.3 Animate的应用 Animation动画，实际上就是浏览器通知开发者进行绘制，并提供当前的时间12345678910111213var anim = new Konva.Animation(function(frame) &#123; //动画系统提供的frame有三个属性可以使用： var time = frame.time, // 动画执行的总时间 timeDiff = frame.timeDiff, // 距离上一帧的时间 frameRate = frame.frameRate; // 帧率（既1000/间隔时间） //动画的动作&#125;, layer);anim.start();//启动动画//anim.stop();//结束动画 5.3.4 循环播放动画的实现12345678910111213//总体思路，使用tween 配合onFinish事件中重新播放动画，达到循环播放的效果var loopTween = new Konva.Tween(&#123; node: star, //设置要表现动画的 Konva对象 rotation: 360, //旋转360度 duration: 2, //动画持续时间 easing: Konva.Easings.Linear, onFinish: function() &#123; // this === loopTween //true this.reset();//重置动画 this.play(); //重新播放动画 &#125;&#125;);loopTween.play(); 5.3.5 回放且循环播放动画 yoyo属性可以进行对动画进行播放完后，回放当前动画，并持续循环来回切换播放。12345rect.to(&#123; duration: 2, scale: 1.5, yoyo: true// 此设置也可以用于 tween&#125;); 5.3.6 进度条案例5.3.7 传智官网案例 三角函数的补充 Math.sin(弧度); //夹角对面的边 和 斜边的比值 Math.cos(弧度); //夹角侧边 与斜边的比值 圆形上面的点的坐标的计算公式 x =x0 + Math.cos(rad) * R;//x0和y0是圆心点坐标 y =y0 + Math.sin(rad) * R;//注意都是弧度 group的灵活运用 konva的group很灵活，每个group都有自己的坐标系 group可以包含其他的group，可以对group做整个组的动画 group可以通过getChidren();//可以拿到直接子级元素。12345var group = new Konva.Group(&#123; x: 0, y: 0&#125;);group.add(rect); 5.4 Konva的事件（重要）123456789101112131415161718192021222324252627282930var rect = new Konva.Rect(&#123; x: 100, y: 100, fill: &apos;red&apos;, width: 200, height: 200&#125;);//绑定事件 Konva支持事件：mouseover, mouseout, mouseenter, mouseleave, mousemove, mousedown, mouseup, mousewheel, click, dblclick, dragstart, dragmove, and dragendrect.on(&apos;click&apos;, function()&#123; //jQuery一模一样！！ console.log(&apos;^_^ ^_^&apos;);&#125;);//绑定多个事件rect.on(&apos;click mousemove&apos;,function(e)&#123;&#125;);//解除绑定事件rect.off(&apos;click&apos;); //这不是jQuery吗？//触发事件rect.fire(&apos;click&apos;);//取消事件冒泡rect.on(&apos;click&apos;, function(evt) &#123; alert(&apos;You clicked the circle!&apos;); evt.cancelBubble = true; //取消事件冒泡&#125;); 5.5 Konva的选择器 选择方法。 ID选择法：stage.find(‘#id’); //此方法返回的是一个数组 name选择法：group.findOne(‘.name’);//返回一个Konva对象 type选择法： group.find(‘Circle’);//查找所有的圆形Konva对象1234//组中查找圆形的Konva对象groupCircle.find(&apos;Circle&apos;).each(function( circle, index )&#123; circle.setZIndex( 3 - index );&#125;); 5.6 饼状图案例 wedge: 楔形 5.7 柱状图案例 histogram n. [统计] 直方图；柱状图 英 [‘hɪstəgræm] 美 [‘hɪstəɡræm] 六、Canvas项目实战七、Canvas优化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;!-- requestAnim shim layer by Paul Irish --&gt; window.requestAnimFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(/* function */ callback, /* DOMElement */ element)&#123; window.setTimeout(callback, 1000 / 60); &#125;; &#125;)(); // example code from mr doob : http://mrdoob.com/lab/javascript/requestanimationframe/var canvas, context, toggle;init();animate();function init() &#123; canvas = document.createElement( &apos;canvas&apos; ); canvas.width = 512; canvas.height = 512; context = canvas.getContext( &apos;2d&apos; ); document.body.appendChild( canvas );&#125;function animate() &#123; requestAnimFrame( animate ); draw();&#125;function draw() &#123; var time = new Date().getTime() * 0.002; var x = Math.sin( time ) * 192 + 256; var y = Math.cos( time * 0.9 ) * 192 + 256; toggle = !toggle; context.fillStyle = toggle ? &apos;rgb(200,200,20)&apos; : &apos;rgb(20,20,200)&apos;; context.beginPath(); context.arc( x, y, 10, 0, Math.PI * 2, true ); context.closePath(); context.fill();&#125;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript6的let和const命令]]></title>
    <url>%2F2016%2F06%2F05%2FECMAScript6%E7%9A%84let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.let 命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。1234567891011if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // &quot;undefined&quot;上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 function func(arg) { let arg; // 报错} function func(arg) { { let arg; // 不报错 }} 块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = &apos;hello world&apos;; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。1234567var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。1&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。1234&#123;&#123;&#123;&#123; &#123;let insane = &apos;Hello World&apos;&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。1234&#123;&#123;&#123;&#123; let insane = &apos;Hello World&apos;; &#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。12345678910function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。123456789// ES5 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; function f() &#123; console.log(&apos;I am inside!&apos;); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。12345678910111213// 浏览器的 ES6 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。1234567891011// 浏览器的 ES6 环境function f() &#123; console.log(&apos;I am outside!&apos;); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log(&apos;I am inside!&apos;); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。123456789101112131415// 函数声明语句&#123; let a = &apos;secret&apos;; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = &apos;secret&apos;; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。12345678910// 不报错&apos;use strict&apos;;if (true) &#123; function f() &#123;&#125;&#125;// 报错&apos;use strict&apos;;if (true) function f() &#123;&#125; 2.const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。123456var message = &quot;Hello!&quot;;let age = 25;// 以下两行都会报错const message = &quot;Goodbye!&quot;;const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === &apos;object&apos; ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。12345678910111213141516// 方法一(typeof window !== &apos;undefined&apos; ? window : (typeof process === &apos;object&apos; &amp;&amp; typeof require === &apos;function&apos; &amp;&amp; typeof global === &apos;object&apos;) ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125; if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125; if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125; throw new Error(&apos;unable to locate global object&apos;);&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。12345// CommonJS 的写法require(&apos;system.global/shim&apos;)();// ES6 模块的写法import shim from &apos;system.global/shim&apos;; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。123456// CommonJS 的写法var global = require(&apos;system.global&apos;)();// ES6 模块的写法import getGlobal from &apos;system.global&apos;;const global = getGlobal(); 上面代码将顶层对象放入变量global。]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>ECMAScript6</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web开发基础]]></title>
    <url>%2F2016%2F06%2F04%2F%E7%A7%BB%E5%8A%A8web%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.1 布局1.1.1三种布局有最大、最小宽度的百分比自适应布局适用场景：门户网站首页，图片较多的首页。百分比自适应布局适用场景：信息文字较多的网页，内容较多网页。全屏自适应布局适用场景：单页面网页，移动web app 页面。 ###1.1.2Box-sizing在移动端的使用在百分比定宽的页面经常使用。*, ::before, ::after{ -webkit-box-sizing: border-box; /*以你的border开始计算你的宽度*/ } 1.2移动端事件Touchtouchstart：当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove：当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend：当手指离开屏幕时触发 touchcancel：系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用触摸事件的响应顺序1、ontouchstart2、ontouchmove3、ontouchend4、onclick 300ms延时 EventoriginalEvent （原生事件） 是jquery 封装的事件。targetTouches 目标元素的所有当前触摸changedTouches 页面上最新更改的所有触摸touches 页面上的所有触摸 clientX、clientY 相对于当前屏幕的X或Y位置pageX、pageY 相对于整体页面的X或Y位置 transitionEnd 过渡结束事件。animationEnd 动画结束事件 移动端事件框架例如 zepto touch.js ‘swipe’,‘swipeLeft’,‘swipeRight’,‘swipeUp’,‘swipeDown’, ‘doubleTap’,‘tap’,‘singleTap’,‘longTap’都是由我们的原生touch事件封装的。 1.3常见的移动端问题1.3.1什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍。那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2//例如图片宽高为：200px*200px，那么写法如下.css{width:100px;height:100px;background-size:100px 100px;}其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px.css{font-size:20px} 1.3.2百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; 1.3.3移动端手机号码识别（IOS）在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：1 7位数字，形如：12345672 带括号及加号的数字，形如：(+86)1234567893 双连接线的数字，形如：00-00-001114 11位数字，形如：13800138000可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt;开启电话功能&lt;a href=&quot;tel:123456&quot;&gt;123456&lt;/a&gt;开启短信功能：&lt;a href=&quot;sms:123456&quot;&gt;123456&lt;/a&gt; ###1.3.4移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：&lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&gt;同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：&lt;a mailto:dooyoe@gmail.com&quot;&gt;dooyoe@gmail.com&lt;/a&gt; 1.3.5ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩。{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 1.3.6webkit表单元素的默认外观怎么重置.css{-webkit-appearance:none;} 1.3.7禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算（或者在内嵌浏览器中设置字体的大小），进行相应的缩放，当我们不需要这种情况时，可以选择禁止：123 html &#123; -webkit-text-size-adjust: 100%;&#125; 1.3.8移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：123.user-select-none &#123; -webkit-user-select: none;｝ 1.3.9如何禁止保存或拷贝图像（IOS）通常当你在手机或者pad上长按图像 img ，会弹出选项存储图像 或者拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：img { -webkit-touch-callout: none; } 1.3.10摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 1.3.11 android 上去掉语音输入按钮input::-webkit-input-speech-button {display: none} 1.3.12移动端基础框架zepto.js语法与jquery几乎一样，会jquery基本会zepto；搭配backbone underscore动画css]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>移动web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2016%2F05%2F06%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器 http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态. 详细请点击]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3基础笔记]]></title>
    <url>%2F2016%2F04%2F25%2FCSS3%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第1章CSS3简介如同人类的的进化一样，CSS3是CSS2的“进化”版本，在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 1.1 CSS3的现状1、浏览器支持程度差，需要添加私有前缀 2、移动端支持优于PC端 3、不断改进中 4、应用相对广泛 1.2 如何对待1、坚持渐进增强原则 2、考虑用户群体 3、遵照产品的方案 4、听Boss的 第2章准备工作2.1统一环境由于CSS3兼容性问题的普遍存在，为了避免因兼容性带来的干扰，我们约定统一的环境，以保证学习的效率，在最后会单独说明兼容性的问题。 1、Chrome浏览器 version 46+ 2、Firefox浏览器 firefox 42+ 3、PhotoShop CS6（建议） 2.2如何使用手册学会使用工具，可以让我们事半功倍。[] 表示全部可选项|| 表示或者| 表示多选一？ 表示0个或者1个* 表示0个或者多个{} 表示范围 第3章基础知识3.1选择器CSS3新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。CSS3选择器与jQuery中所提供的绝大部分选择器兼容。 3.1.1属性选择器参考手册1、E[attr] 表示存在attr属性即可；2、E[attr=val] 表示属性值完全等于val3、E[attr~=val] 表示的一个单独的属性值 这个属性值是以空格分隔的4、E[attr|=val] 表示的要么一个单独的属性值 要么这个属性值是以“-”分隔的5、E[attr*=val] 表示的属性值里包含val字符并且在“任意”位置6、E[attr^=val] 表示的属性值里包含val字符并且在“开始”位置7、E[attr$=val] 表示的属性值里包含val字符并且在“结束”位置 3.1.2伪类选择器参考手册重点理解E是用来参考确定其父元素的，nth-child(n) 对应根据E元素确定的父元素的所有子元素，nth-of-type(n) 的不同之处在于其对应的是只有E元素，会忽略其子元素。（此处要配合案例加强理解）E:nth-child(n) 第n个子元素，计算方法是E元素的全部兄弟元素E:nth-of-type(n) 第n个子元素，计算方法只是E元素，会忽略其子元素的存在E:nth-last-child(n) 同E:nth-child(n) 计算顺序相反。E:nth-last-of-type(n) 同E:nth-of-type(n) 计算顺序相反。n遵循线性变化，其取值1、2、3、4、…关于n的取值范围：1、当n做为一个独立值时，n取值为n&gt;=1，例如nth-child(n)2、当n做一个系数时，n取值为n&gt;=0者n&lt;0，例如nth-child(2n+1)、nth-child(-1n+5) 此处需要理解2n+1或者-n+5做为一个整体不能小于1；E:only-child 表示当前以E确定的父元素，除E之外并无其它子元素（独生子）；E:only-of-type表示当前以E确定的父元素， 除E之外不能包含其它和E同类型的子元素；E:target 结合锚点进行使用，处于当前锚点的元素会被选中；E:empty 选中没有任何子节点的E元素； ###3.1.3伪元素选择器E::selection 可改变选中文本的样式E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。“:” 与 “::” 区别在于区分伪类和伪元素 3.2颜色新增了RGBA、HSLA模式，其中的A 表示透明度通道，即可以设置颜色值的透明度，相较opacity，不具有继承性，即不会影响子元素的透明度。Red、Green、Blue、Alpha即RGBAHue、Saturation、Lightness、Alpha即HSLAR、G、B 取值范围0~255H 取值范围0~360，0/360表示黑色、120表示绿色、240表示蓝色S 取值范围0%~100%L 取值范围0%~100%A 取值范围0~1关于透明度：1、opacity子元素会继承父元素的透明度，在实际开发中会带来干扰；2 、transparent 设置透明度时完全类似于“玻璃”一样的透明； 3.3文本参考手册文字阴影与边框阴影相似，可分别设置偏移量、模糊度、颜色（可设透明度）。单行文本溢出，需要配合overflow:hidden; white-space: nowrap;难理解的点：自已要多试着理解一下关于white-space的各个属性值之间的差异；换行符指的我们在键盘上的Enter键，Enter换行符会被当成空行来对待，而由Tab、Space产生的换行，则会视为一个空格。上述方法只能解决单行文本的溢出问题，多行文本溢出处理可参照下面的方法，但是有比较严重的兼容性，需要慎重选择，比较完备的多行溢出需要JS辅助完成，可自行尝试。多行文本文字溢出处理，非标准属性，可应用于移动端 了解常握white-space 使用 3.4边框其边框圆角、边框阴影属性，应用十分广泛，兼容性也相对较好，具有符合渐进增强原则的特征，我们需要重点掌握。 3.4.1边框圆角圆角处理时，脑中要形成圆、圆心、长半径、短半径的概念，正圆是椭圆的一种特殊情况。 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ）参考手册练习熟悉各种简写方式。 表格运用圆角需要要 border-collapse: separate;当圆角半径小于或等于边框宽度时，元素内角是直角 如何在PS中查看圆角半径？ 3.4.2边框图片设置的图片将会被“切割”成九宫格形式，然后进行设置。如下图 “切割”完成后生成虚拟的9块图形，然后按对应位置设置背景，其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。如下图 round 会自动调整尺寸，完整显示边框图片。 repeat 单纯平铺多余部分，会被“裁切”而不显示。 background-slice: 27 40 40 27 分别设置裁切如下图 3.4.3边框阴影水平偏移量 正值向右 负值向左 垂直正值向下 负值向上。模糊度是不能为负关于模糊度：从一个颜色值在一定距离内进行一个渐变至透明的过程。移量和扩展也是数学运算的，即正负会相互抵消。偏移量和模糊度是可以相加计算，偏移量负号只代表方向。设置边框阴影不会影响盒子的布局，即不会影响其兄弟元素的布局。spread可以与blur、h-shadow、v-shadow相互抵消，blur不可为负值可以设置多重边框阴影，实现更好的效果，增强立体感。 3.5盒模型关于盒模型存在两种形式，分别是W3C标准盒模型和IE盒模型，如下图所示，其区别主要在于宽度和高度的计算方式，CSS3对盒模型做出了新的定义，即允许开发人员指定盒子宽度和高度的计算方式。 IE模型下 width = padding + content + border;W3C盒模型下 width = contentbox-sizing: border-box width = border + padding + contentbox-sizing: content-box width = contentIE盒模型只会出现在IE5版本和IE6+的怪异模式中。怪异模式http://www.cnblogs.com/coco1s/p/4034937.htmlCSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box; 3.6背景背景在CSS3中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。background-size 与 background-clip无关background-size 与 background-origin 保持一致背景图片尺寸在实际开发中应用十分广泛。参照手册 3.7渐变渐变是CSS3当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。可分为线性渐变、径向渐变、重复渐变。线性渐变指沿着某条直线朝一个方向产生渐变效果。 上图是从黄色渐变到绿色必要的元素：方向、起始颜色、终止色；关于方向如下图 关于颜色起止，可以设置多个色值的渐变，并且可以分别设置渐变的距离如 linear-gradient(to left, yellow 10%, blue 15%, red 50%)径向渐变指从一个中心点开始沿着四周产生渐变效果 特点：1、辐射范围2、中心点3、颜色的起止关于中心点：中心位置参照的是盒子的左上角关于辐射范围：其半径可以不等即可以是椭圆关于圆的知识同边框圆角章节的介绍 3.8伸缩布局CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用，使得开发人员一下子就过上了小康的生活。伸缩盒模型经历了几次演变，大致分为旧版伸缩布局、过渡伸缩布局、新版伸缩布局，同样为了避免混淆，我们以学习新版伸缩布局为主。 3.8.1新版伸缩布局这里我们需要引入一些新的概念：主轴：Flex容器的主轴主要用来配置Flex项目。侧轴：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。主轴和侧轴并不是固定不变的，通过flex-direction可以调整。 1、指定一个盒子为伸缩盒子 display: flex2、设置属性来调整此盒的子元素的布局方式 例如 flex-direction3、明确主侧轴的方向4、可互换主侧轴，也可改变方向其相关属性可参照源代码里的解释如flex-direction、flex-wrap、flex-flow、align-items、align-content、justify-content、align-self、flex、order等另个两个版本伸缩布局其实现思路与新版基本一致，区别在于其属性及属性值不同，熟练掌握新版伸缩布局后，要参照对比另外两个版本的不同。 3.9多列布局类似报纸或杂志中的排版方式，上要用以控制大篇幅文本。参照手册 3.10过渡过渡是CSS3中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。帧动画：通过一帧一帧的关键画面按照固定顺序和速度播放。如电影胶片 补间动画：自动完成从起始状到终止状的的过度。关于补间动画更多学习可查看http://mux.alimama.com/posts/1009特点：当前元素只要有“属性”发生变化时，可以平滑的进行过渡。transition-property设置过渡属性transition-duration设置过渡时间transition-timing-function设置过渡速度transition-delay设置过渡延时贝塞尔曲线限定了过渡的轨迹。这部分没有提及，有兴趣同学自行查阅相关资料了解一下即可。以上四属性重在更解，具体细节可参考手册辅助记忆 3.11动画动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。参考手册 3.12转换转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合即将学习的过渡和动画知识，可以取代大量之前只能靠Flash才可以实现的效果。2D 转换translate(x,y) x、y 可为负值，相对自身移动，并未脱离文档流。左手坐标系：伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。左手法则：左手握住旋转轴，竖起拇指指向旋转轴正方向，正向旋转方向就是其余手指卷曲的方向。 3D坐标轴，用X、Y、Z分别表示空间的3个维度，三条轴上互相垂直。 3.13媒体查询由于网页呈现终端设备越来越趋向于多样化，尤其是移动终端（手机），具有不同屏幕尽寸、不同分辨率，为了保证网页能十分友好的呈现，CSS3为开发人员提供了可以识别呈现终端的方法，这样便可以有针对性的为不同的呈现终端分别进行处理，被广泛应用于响应式开发中。html 标签方式：css 属性方式：常使用的是检测设备宽度参考手册第4章Web字体开发人员可以为自已的网页指定特殊的字体，无需考虑用户电脑上是否安装了此特殊字体，从此把特殊字体处理成图片的时代便成为了过去。支持程度比较好，甚至IE低版本浏览器也能支持。 4.1字体格式不同浏览器所支持的字体格式是不一样的，我们有必要了解一下有关字体格式的知识。1、TureTpe(.ttf)格式.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；2、OpenType(.otf)格式.otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；3、Web Open Font Format(.woff)格式woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；4、Embedded Open Type(.eot)格式.eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；5、SVG(.svg)格式.svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；关于字体介绍摘自http://www.w3cplus.com/content/css3-font-face/了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。推荐http://www.zhaozi.cn/、http://www.youziku.com/ 查找更多中文字体 4.2字体图标其实我们可以把文字理解成是一种特殊形状的图片，反之我们是不是也可以把图片制作成字体呢？答案是肯定的。常见的是把网页常用的一些小的图标，借助工具帮我们生成一个字体库，然后就可以像使用文字一样使用图标了。优点：1、将所有图标打包成字体库，减少请求；2、具有矢量性，可保证清晰度；3、使用灵活，便于维护；Font Awesome 使用介绍http://fontawesome.dashgame.com/定制自已的字体图标库http://iconfont.cn/https://icomoon.io/SVGhttp://www.iconsvg.com/ 第5章兼容性通过http://caniuse.com/ 可查询CSS3各特性的支持程度，一般兼容性处理的常见方法是为属性添加私有前缀，如不能解决，应避免使用，无需刻意去处理CSS3的兼容性问题。 第6章高级应用]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5触摸事件]]></title>
    <url>%2F2016%2F04%2F20%2FHTML5%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. HTML5触摸事件HTML5中新添加了很多事件，但是由于他们的兼容问题不是很理想，应用实战性不是太强，所以在这里基本省略，咱们只分享应用广泛兼容不错的事件，日后随着兼容情况提升以后再陆续添加分享。今天为大家介绍的事件主要是触摸事件：touchstart、touchmove和touchend。 一开始触摸事件touchstart、touchmove和touchend是iOs版Safari浏览器为了向开发人员传达一些信息新添加的事件。因为iOs设备既没有鼠标也没有键盘，所以在为移动Safari浏览器开发交互性网页的时候，PC端的鼠标和键盘事件是不够用的。 在iPhone 3Gs发布的时候，其自带的移动Safari浏览器就提供了一些与触摸(touch)操作相关的新事件。随后，Android上的浏览器也实现了相同的事件。触摸事件(touch)会在用户手指放在屏幕上面的时候、在屏幕上滑动的时候或者是从屏幕上移开的时候出发。下面具体说明： touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。 touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 touchend事件：当手指从屏幕上离开的时候触发。 touchcancel事件：当系统停止跟踪触摸的时候触发。关于这个事件的确切出发时间，文档中并没有具体说明，咱们只能去猜测了。 上面的这些事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但是它们却是以兼容DOM的方式实现的。所以，每个触摸事件的event对象都提供了在鼠标实践中常见的属性：bubbles(起泡事件的类型)、cancelable(是否用 preventDefault() 方法可以取消与事件关联的默认动作)、clientX(返回当事件被触发时，鼠标指针的水平坐标)、clientY(返回当事件触发时，鼠标指针的垂直坐标)、screenX(当某个事件被触发时，鼠标指针的水平坐标)和screenY(返回当某个事件被触发时，鼠标指针的垂直坐标)。除了常见的DOM属性，触摸事件还包含下面三个用于跟踪触摸的属性。 touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。 每个Touch对象包含的属性如下。 clientX：触摸目标在视口中的x坐标。 clientY：触摸目标在视口中的y坐标。 identifier：标识触摸的唯一ID。 pageX：触摸目标在页面中的x坐标。 pageY：触摸目标在页面中的y坐标。 screenX：触摸目标在屏幕中的x坐标。 screenY：触摸目标在屏幕中的y坐标。 target：触目的DOM节点目标。 上面的属性光这么看，果然非常繁琐，每个属性说的都是那么的细致，只有真刀实枪的来点小例子才能更加明白其中的奥妙。所以小例子如下。 123456789101112131415161718192021222324252627function load ()&#123; document.addEventListener(&apos;touchstart&apos;,touch, false); document.addEventListener(&apos;touchmove&apos;,touch, false); document.addEventListener(&apos;touchend&apos;,touch, false); function touch (event)&#123; var event = event || window.event; var oInp = document.getElementById(&quot;inp&quot;); switch(event.type)&#123; case &quot;touchstart&quot;: oInp.innerHTML = &quot;Touch started (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;; break; case &quot;touchend&quot;: oInp.innerHTML = &quot;&lt;br&gt;Touch end (&quot; + event.changedTouches[0].clientX + &quot;,&quot; + event.changedTouches[0].clientY + &quot;)&quot;; break; case &quot;touchmove&quot;: event.preventDefault(); oInp.innerHTML = &quot;&lt;br&gt;Touch moved (&quot; + event.touches[0].clientX + &quot;,&quot; + event.touches[0].clientY + &quot;)&quot;; break; &#125; &#125; &#125; window.addEventListener(&apos;load&apos;,load, false); touches: 当前屏幕上所有触摸点的列表; targetTouches: 当前对象上所有触摸点的列表; changedTouches: 涉及当前(引发)事件的触摸点的列表 通过一个例子来区分一下触摸事件中的这三个属性： 用一个手指接触屏幕，触发事件，此时这三个属性有相同的值。 用第二个手指接触屏幕，此时，touches有两个元素，每个手指触摸点为一个值。当两个手指触摸相同元素时，targetTouches和touches的值相同，否则targetTouches 只有一个值。changedTouches此时只有一个值，为第二个手指的触摸点，因为第二个手指是引发事件的原因 用两个手指同时接触屏幕，此时changedTouches有两个值，每一个手指的触摸点都有一个值 手指滑动时，三个值都会发生变化 一个手指离开屏幕，touches和targetTouches中对应的元素会同时移除，而changedTouches仍然会存在元素。 手指都离开屏幕之后，touches和targetTouches中将不会再有值，changedTouches还会有一个值，此值为最后一个离开屏幕的手指的接触点。 2. 触点坐标选取123touchstart和touchmove使用: e.targetTouches[0].pageX 或 (jquery)e.originalEvent.targetTouches[0].pageXtouchend使用: e.changedTouches[0].pageX 或 (jquery)e.originalEvent.changedTouches[0].pageX 3.touchmove事件对象的获取想要在touchmove:function(e,参数一)加一个参数，结果直接使用e.preventDefault()就会 e 报错，处理方法为使用arguments[0]获取event参数1234touchmove:function(e,参数一)&#123; var e=arguments[0] e.preventDefault()&#125;]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5基础]]></title>
    <url>%2F2016%2F03%2F09%2FHTML5%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[用普通文本描述富文本的语法扩展名md,markdown HTML5之HTML篇回顾 新标签 语义化标签 新属性 链接关系描述 ARIA 无障碍富互联网应用程序属性 自定义属性 data- 可以给HTML里的所有DOM对象都可以添加一些DATA-xxx的属性 用来记录与当前DOM强相关的数据 智能表单 新的表单类型 功能型的表单类型 虚拟键盘适配 通过type方式指定弹出键盘 网页多媒体 之前强依赖flash 音频 多媒体的dom对象有一些新的方法可以去做播放暂停 视频 了解字幕 SVG 文件基本使用 iframe iframe的作用就是在网页中挖个坑，在这个坑里再展示一个页面 svg本身也是文档 所以可以使用iframe的方式载入 ajax 直接可以修改样式 JavaScript2.1. 基础API提升2.1.1 新选择器JS多了一个原始支持，类似jqueryDOM选择器 document.getElementById() 需要给DOM元素设置IDdocument.querySelector(selector) 可以通过CSS选择器的语法找到DOM元素 document.getElementsByTagName()document.querySelectorAll(‘.item’) $(‘.item’).on document.querySelector(selector); 返回第一个满足选择器条件的元素 一个dom对象 document.querySelectorAll(‘.item’); 返回所有满足该条件的元素 一个元素类型是dom类型的数组 $(‘.item’) 返回一个jQuery对象（dom元素的数组） 本质上jquery方式和qs方式都是获取DOM数组， 只不过jquery会多一些其他成员 DOM数组的每一个成员注册事件不能像jquery一样直接注册， 必须分别给每个元素注册 h5就是将我们经常需要的操作又包装一层 2.1.2 元素.classList 新H5中DOM对象多了一个classList属性，是一个数组 add 添加一个新的类名 remove 删除一个的类名 contains 判断是否包含一个指定的类名 toggle 切换一个class element.toggle(‘class-name’,[add_or_remove]) toggle函数的第二个参数true为添加 false删除 2.1.3 访问历史 API界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态 window.history.forward(); // 前进 window.history.back(); // 后退 window.history.go(); // 刷新 通过JS可以加入一个访问状态 history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态) 2.1.4 全屏 API JavaScript中可以通过调用requestFullScreen()方式实现指定元素的全屏显示var element = document.querySelector(‘…’);element.requestFullScreen(); 2.2 网页存储2.2.1 Web Storage getItem方式获取一个不存在的键 返回空字符串 []返回 undefined 2.2.2 Web SQL2.2.3 IndexedDB2.3 文件系统2.3.1 File API2.3.2 FileReader2.4 拖放操作2.4.1 网页内拖放2.4.2 文件拖入]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
</search>
